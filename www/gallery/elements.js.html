<!DOCTYPE html>
            <html>
              <head>
                <title>example/elements.js</title>
                <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
                <meta charset=utf-8>
              </head>
              <body>
              <script type='text/javascript'>
              (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var regl = require('../regl')()

regl.clear({
  color: [0, 0, 0, 1],
  depth: 1
})

regl({
  frag: [
    'precision mediump float;',
    'uniform vec4 color;',
    'void main() {',
    '  gl_FragColor = color;',
    '}'
  ].join('\n'),

  vert: [
    'precision mediump float;',
    'attribute vec2 position;',
    'void main() {',
    '  gl_Position = vec4(position, 0, 1);',
    '}'
  ].join('\n'),

  attributes: {
    position: regl.buffer((new Array(5)).fill().map(function (x, i) {
      var theta = 2.0 * Math.PI * i / 5
      return [ Math.sin(theta), Math.cos(theta) ]
    }))
  },

  uniforms: {
    color: [1, 0, 0, 1]
  },

  elements: regl.elements([
    [0, 1],
    [0, 2],
    [0, 3],
    [0, 4],
    [1, 2],
    [1, 3],
    [1, 4],
    [2, 3],
    [2, 4],
    [3, 4]
  ]),

  lineWidth: 3
})()

},{"../regl":31}],2:[function(require,module,exports){
var glTypes = require('./constants/dtypes.json')

var GL_FLOAT = 5126

function AttributeRecord () {
  this.pointer = false

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

Object.assign(AttributeRecord.prototype, {
  equals: function (other, size) {
    if (!this.pointer) {
      return !other.pointer &&
        this.x === other.x &&
        this.y === other.y &&
        this.z === other.z &&
        this.w === other.w
    } else {
      return other.pointer &&
        this.buffer === other.buffer &&
        this.size === size &&
        this.normalized === other.normalized &&
        this.type === other.type &&
        this.offset === other.offset &&
        this.stride === other.stride &&
        this.divisor === other.divisor
    }
  },

  set: function (other, size) {
    var pointer = this.pointer = other.pointer
    if (pointer) {
      this.buffer = other.buffer
      this.size = size
      this.normalized = other.normalized
      this.type = other.type
      this.offset = other.offset
      this.stride = other.stride
      this.divisor = other.divisor
    } else {
      this.x = other.x
      this.y = other.y
      this.z = other.z
      this.w = other.w
    }
  }
})

module.exports = function wrapAttributeState (gl, extensionState, bufferState) {
  var extensions = extensionState.extensions

  var attributeState = {}

  var NUM_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS)
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }

  function AttributeStack () {
    var records = new Array(16)
    for (var i = 0; i < 16; ++i) {
      records[i] = new AttributeRecord()
    }
    this.records = records
    this.top = 0
  }

  function pushAttributeStack (stack) {
    var records = stack.records
    var top = stack.top

    while (records.length - 1 <= top) {
      records.push(new AttributeRecord())
    }

    return records[++stack.top]
  }

  Object.assign(AttributeStack.prototype, {
    pushVec: function (x, y, z, w) {
      var head = pushAttributeStack(this)
      head.pointer = false
      head.x = x
      head.y = y
      head.z = z
      head.w = w
    },

    pushPtr: function (
      buffer,
      size,
      offset,
      stride,
      divisor,
      normalized,
      type) {
      var head = pushAttributeStack(this)
      head.pointer = true
      head.buffer = buffer
      head.size = size
      head.offset = offset
      head.stride = stride
      head.divisor = divisor
      head.normalized = normalized
      head.type = type
    },

    pushDyn: function (data) {
      if (typeof data === 'number') {
        this.pushVec(data, 0, 0, 0)
      } else if (Array.isArray(data)) {
        this.pushVec(data[0], data[1], data[2], data[3])
      } else {
        var buffer = bufferState.getBuffer(data)
        var size = 0
        var stride = 0
        var offset = 0
        var divisor = 0
        var normalized = false
        var type = GL_FLOAT
        if (!buffer) {
          buffer = bufferState.getBuffer(data.buffer)
          size = data.size || 0
          stride = data.stride || 0
          offset = data.offset || 0
          divisor = data.divisor || 0
          normalized = data.normalized || false
          type = buffer.dtype
          if ('type' in data) {
            type = glTypes[data.type]
          }
        } else {
          type = buffer.dtype
        }
        this.pushPtr(buffer, size, offset, stride, divisor, normalized, type)
      }
    },

    pop: function () {
      this.top -= 1
    }
  })

  // ===================================================
  // BIND AN ATTRIBUTE
  // ===================================================
  function bindAttribute (index, current, next, size) {
    size = next.size || size
    if (current.equals(next, size)) {
      return
    }
    if (!next.pointer) {
      if (current.pointer) {
        gl.disableVertexAttribArray(index)
      }
      gl.vertexAttrib4f(index, next.x, next.y, next.z, next.w)
    } else {
      if (!current.pointer) {
        gl.enableVertexAttribArray(index)
      }
      if (current.buffer !== next.buffer) {
        next.buffer.bind()
      }
      gl.vertexAttribPointer(
        index,
        size,
        next.type,
        next.normalized,
        next.stride,
        next.offset)
      var extInstancing = extensions.angle_instanced_arrays
      if (extInstancing) {
        extInstancing.vertexAttribDivisorANGLE(index, next.divisor)
      }
    }
    current.set(next, size)
  }

  // ===================================================
  // DEFINE A NEW ATTRIBUTE
  // ===================================================
  function defAttribute (name) {
    if (name in attributeState) {
      return
    }
    attributeState[name] = new AttributeStack()
  }

  return {
    bindings: attributeBindings,
    attributes: attributeState,
    bind: bindAttribute,
    def: defAttribute
  }
}

},{"./constants/dtypes.json":12}],3:[function(require,module,exports){
// Array and element buffer creation
var check = require('./check')
var isTypedArray = require('./is-typed-array')
var arrayTypes = require('./constants/arraytypes.json')

var GL_UNSIGNED_BYTE = 5121
var GL_STATIC_DRAW = 35044
var GL_FLOAT = 5126

var usageTypes = {
  'static': 35044,
  'dynamic': 35048,
  'stream': 35040
}

function flatten (data, dimension) {
  var result = new Float32Array(data.length * dimension)
  var ptr = 0
  for (var i = 0; i < data.length; ++i) {
    var v = data[i]
    for (var j = 0; j < dimension; ++j) {
      result[ptr++] = v[j]
    }
  }
  return result
}

module.exports = function wrapBufferState (gl) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (buffer, type) {
    this.id = bufferCount++
    this.buffer = buffer
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.data = null
    this.dtype = GL_UNSIGNED_BYTE
  }

  Object.assign(REGLBuffer.prototype, {
    bind: function () {
      gl.bindBuffer(this.type, this.buffer)
    },

    update: function (options) {
      if (Array.isArray(options) || isTypedArray(options)) {
        options = {
          data: options
        }
      } else if (typeof options === 'number') {
        options = {
          length: options | 0
        }
      } else if (options === null || options === void 0) {
        options = {}
      }

      check.type(
        options, 'object',
        'buffer arguments must be an object, a number or an array')

      if ('usage' in options) {
        var usage = options.usage
        check.parameter(usage, usageTypes, 'buffer usage')
        this.usage = usageTypes[options.usage]
      }

      var dimension = (options.dimension | 0) || 1
      if ('data' in options) {
        var data = options.data
        if (data === null) {
          this.byteLength = options.length | 0
          this.dtype = GL_UNSIGNED_BYTE
        } else {
          if (Array.isArray(data)) {
            if (data.length > 0 && Array.isArray(data[0])) {
              dimension = data[0].length
              data = flatten(data, dimension)
              this.dtype = GL_FLOAT
            } else {
              data = new Float32Array(data)
              this.dtype = GL_FLOAT
            }
          } else {
            check.isTypedArray(data, 'invalid data type buffer data')
            this.dtype = arrayTypes[Object.prototype.toString.call(data)]
          }
          this.dimension = dimension
          this.byteLength = data.byteLength
        }
        this.data = data
      } else if ('length' in options) {
        var byteLength = options.length
        check.nni(byteLength, 'buffer length must be a nonnegative integer')
        this.data = null
        this.byteLength = options.length | 0
        this.dtype = GL_UNSIGNED_BYTE
      }

      this.bind()
      gl.bufferData(this.type, this.data || this.byteLength, this.usage)
    },

    refresh: function () {
      if (!gl.isBuffer(this.buffer)) {
        this.buffer = gl.createBuffer()
      }
      this.update({})
    },

    destroy: function () {
      check(this.buffer, 'buffer must not be deleted already')
      gl.deleteBuffer(this.buffer)
      this.buffer = null
      delete bufferSet[this.id]
    }
  })

  function createBuffer (options, type) {
    options = options || {}
    var handle = gl.createBuffer()

    var buffer = new REGLBuffer(handle, type)
    buffer.update(options)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      buffer.update(options || {})
      return reglBuffer
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.destroy = function () { buffer.destroy() }

    return reglBuffer
  }

  return {
    create: createBuffer,

    clear: function () {
      Object.keys(bufferSet).forEach(function (bufferId) {
        bufferSet[bufferId].destroy()
      })
    },

    refresh: function () {
      Object.keys(bufferSet).forEach(function (bufferId) {
        bufferSet[bufferId].refresh()
      })
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    }
  }
}

},{"./check":4,"./constants/arraytypes.json":8,"./is-typed-array":21}],4:[function(require,module,exports){
// Error checking and parameter validation
var isTypedArray = require('./is-typed-array')

function raise (message) {
  console.error(message)
  throw new Error(message)
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  check(param in possibilities,
    'unknown parameter (' + param + ')' + encolon(message) +
    '. possible values: ' + Object.keys(possibilities).join())
}

function checkIsTypedArray (data, message) {
  check(
    isTypedArray(data),
    'invalid parameter type' + encolon(message) +
    '. must be a typed array')
}

function checkTypeOf (value, type, message) {
  check(typeof value === type,
    'invalid parameter type' + encolon(message) +
    '. expected ' + type + ', got ' + (typeof value))
}

function checkNonNegativeInt (value, message) {
  check(
    (value >= 0) &&
    ((value | 0) === value),
    'invalid parameter type, (' + value + ')' + encolon(message) +
    '. must be a nonnegative integer')
}

function checkOneOf (value, list, message) {
  check(
    list.indexOf(value) >= 0,
    'invalid value' + encolon(message) + '. must be one of: ' + list)
}

module.exports = Object.assign(check, {
  raise: raise,
  parameter: checkParameter,
  type: checkTypeOf,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf
})

},{"./is-typed-array":21}],5:[function(require,module,exports){
/* globals performance */
module.exports =
  (typeof performance !== 'undefined' && performance.now)
  ? function () { return performance.now() }
  : function () { return +(new Date()) }

},{}],6:[function(require,module,exports){
function slice (x) {
  return Array.prototype.slice.call(x)
}

module.exports = function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return Object.assign(push, {
      def: def,
      toString: function () {
        return [
          (vars.length > 0 ? 'var ' + vars + ';' : ''),
          code.join('')
        ].join('')
      }
    })
  }

  // procedure list
  var procedures = {}
  function proc (name) {
    var args = []
    function arg () {
      var name = 'a' + (varCounter++)
      args.push(name)
      return name
    }

    var body = block()
    var bodyToString = body.toString

    var result = procedures[name] = Object.assign(body, {
      arg: arg,
      toString: function () {
        return [
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ].join('')
      }
    })

    return result
  }

  // compiles and returns all blocks
  function compile () {
    var code = ['"use strict";return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var proc = Function.apply(null, linkedNames.concat([code.join('')]))
    return proc.apply(null, linkedValues)
  }

  return {
    link: link,
    block: block,
    proc: proc,
    compile: compile
  }
}

},{}],7:[function(require,module,exports){
var check = require('./check')
var createEnvironment = require('./codegen')

var primTypes = require('./constants/primitives.json')
var glTypes = require('./constants/dtypes.json')
var compareFuncs = require('./constants/comparefuncs.json')
var blendFuncs = require('./constants/blendfuncs.json')
var blendEquations_base = require('./constants/blendequations.json')
var stencilOps = require('./constants/stencil-ops.json')

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_FLOAT = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES = 4

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FRONT = 1028
var GL_BACK = 1029

var GL_CW = 0x0900
var GL_CCW = 0x0901

var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008

function typeLength (x) {
  switch (x) {
    case GL_FLOAT_VEC2:
    case GL_INT_VEC2:
    case GL_BOOL_VEC2:
      return 2
    case GL_FLOAT_VEC3:
    case GL_INT_VEC3:
    case GL_BOOL_VEC3:
      return 3
    case GL_FLOAT_VEC4:
    case GL_INT_VEC4:
    case GL_BOOL_VEC4:
      return 4
    default:
      return 1
  }
}

function setUniformString (gl, type, location, value) {
  var infix
  var separator = ','
  switch (type) {
    case GL_FLOAT:
      infix = '1f'
      break
    case GL_FLOAT_VEC2:
      infix = '2fv'
      break
    case GL_FLOAT_VEC3:
      infix = '3fv'
      break
    case GL_FLOAT_VEC4:
      infix = '4fv'
      break
    case GL_BOOL:
    case GL_INT:
      infix = '1i'
      break
    case GL_BOOL_VEC2:
    case GL_INT_VEC2:
      infix = '2iv'
      break
    case GL_BOOL_VEC3:
    case GL_INT_VEC3:
      infix = '3iv'
      break
    case GL_BOOL_VEC4:
    case GL_INT_VEC4:
      infix = '4iv'
      break
    case GL_FLOAT_MAT2:
      infix = 'Matrix2fv'
      separator = ',false,'
      break
    case GL_FLOAT_MAT3:
      infix = 'Matrix3fv'
      separator = ',false,'
      break
    case GL_FLOAT_MAT4:
      infix = 'Matrix4fv'
      separator = ',false,'
      break
    default:
      check.raise('unsupported uniform type')
  }
  return gl + '.uniform' + infix + '(' + location + separator + value + ');'
}

function stackTop (x) {
  return x + '[' + x + '.length-1]'
}

module.exports = function reglCompiler (
  gl,
  extensionState,
  bufferState,
  elementState,
  textureState,
  fboState,
  glState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  frameState) {
  var extensions = extensionState.extensions
  var contextState = glState.contextState

  var blendEquations = Object.create(blendEquations_base)
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var drawCallCounter = 0

  // ===================================================
  // ===================================================
  // SHADER SINGLE DRAW OPERATION
  // ===================================================
  // ===================================================
  function compileShaderDraw (program) {
    var env = createEnvironment()
    var link = env.link
    var draw = env.proc('draw')
    var def = draw.def

    var GL = link(gl)
    var PROGRAM = link(program.program)
    var BIND_ATTRIBUTE = link(attributeState.bind)
    var DRAW_STATE = {
      count: link(drawState.count),
      offset: link(drawState.offset),
      instances: link(drawState.instances),
      primitive: link(drawState.primitive)
    }
    var ELEMENT_STATE = link(elementState.elements)
    var TEXTURE_UNIFORMS = []

    // bind the program
    draw(GL, '.useProgram(', PROGRAM, ');')

    // set up attribute state
    program.attributes.forEach(function (attribute) {
      var STACK = link(attributeState.attributes[attribute.name])
      draw(BIND_ATTRIBUTE, '(',
        attribute.location, ',',
        link(attributeState.bindings[attribute.location]), ',',
        STACK, '.records[', STACK, '.top]', ',',
        typeLength(attribute.info.type), ');')
    })

    // set up uniforms
    program.uniforms.forEach(function (uniform) {
      var LOCATION = link(uniform.location)
      var STACK = link(uniformState.uniforms[uniform.name])
      var TOP = STACK + '[' + STACK + '.length-1]'
      if (uniform.info.type === GL_SAMPLER_2D ||
          uniform.info.type === GL_SAMPLER_CUBE) {
        var TEX_VALUE = def(TOP + '._texture')
        TEXTURE_UNIFORMS.push(TEX_VALUE)
        draw(setUniformString(GL, GL_INT, LOCATION, TEX_VALUE + '.bind()'))
      } else {
        draw(setUniformString(GL, uniform.info.type, LOCATION, TOP))
      }
    })

    // unbind textures immediately
    TEXTURE_UNIFORMS.forEach(function (TEX_VALUE) {
      draw(TEX_VALUE, '.unbind();')
    })

    // Execute draw command
    var CUR_PRIMITIVE = def(stackTop(DRAW_STATE.primitive))
    var CUR_COUNT = def(stackTop(DRAW_STATE.count))
    var CUR_OFFSET = def(stackTop(DRAW_STATE.offset))
    var CUR_ELEMENTS = def(stackTop(ELEMENT_STATE))

    // Only execute draw command if number elements is > 0
    draw('if(', CUR_COUNT, '){')

    var instancing = extensions.angle_instanced_arrays
    if (instancing) {
      var CUR_INSTANCES = def(stackTop(DRAW_STATE.instances))
      var INSTANCE_EXT = link(instancing)
      draw(
        'if(', CUR_ELEMENTS, '){',
        CUR_ELEMENTS, '.bind();',
        'if(', CUR_INSTANCES, '>0){',
        INSTANCE_EXT, '.drawElementsInstancedANGLE(',
        CUR_PRIMITIVE, ',',
        CUR_COUNT, ',',
        CUR_ELEMENTS, '.type,',
        CUR_OFFSET, ',',
        CUR_INSTANCES, ');}else{',
        GL, '.drawElements(',
        CUR_PRIMITIVE, ',',
        CUR_COUNT, ',',
        CUR_ELEMENTS, '.type,',
        CUR_OFFSET, ');}',
        '}else if(', CUR_INSTANCES, '>0){',
        INSTANCE_EXT, '.drawArraysInstancedANGLE(',
        CUR_PRIMITIVE, ',',
        CUR_OFFSET, ',',
        CUR_COUNT, ',',
        CUR_INSTANCES, ');}else{',
        GL, '.drawArrays(',
        CUR_PRIMITIVE, ',',
        CUR_OFFSET, ',',
        CUR_COUNT, ');}}')
    } else {
      draw(
        'if(', CUR_ELEMENTS, '){',
        GL, '.drawElements(',
        CUR_PRIMITIVE, ',',
        CUR_COUNT, ',',
        CUR_ELEMENTS, '.type,',
        CUR_OFFSET, ');}',
        '}else{',
        GL, '.drawArrays(',
        CUR_PRIMITIVE, ',',
        CUR_OFFSET, ',',
        CUR_COUNT, ');}')
    }

    return env.compile().draw
  }

  // ===================================================
  // ===================================================
  // BATCH DRAW OPERATION
  // ===================================================
  // ===================================================
  function compileBatch (
    program, options, uniforms, attributes, staticOptions) {
    // -------------------------------
    // code generation helpers
    // -------------------------------
    var env = createEnvironment()
    var link = env.link
    var batch = env.proc('batch')
    var exit = env.block()
    var def = batch.def
    var arg = batch.arg

    // -------------------------------
    // regl state
    // -------------------------------
    var GL = link(gl)
    var PROGRAM = link(program.program)
    var BIND_ATTRIBUTE = link(attributeState.bind)
    var FRAME_STATE = link(frameState)
    var DRAW_STATE = {
      count: link(drawState.count),
      offset: link(drawState.offset),
      instances: link(drawState.instances),
      primitive: link(drawState.primitive)
    }
    var ELEMENTS = link(elementState.elements)
    var CUR_COUNT = def(stackTop(DRAW_STATE.count))
    var CUR_OFFSET = def(stackTop(DRAW_STATE.offset))
    var CUR_PRIMITIVE = def(stackTop(DRAW_STATE.primitive))
    var CUR_ELEMENTS = def(stackTop(ELEMENTS))
    var CUR_INSTANCES
    var INSTANCE_EXT
    var instancing = extensions.angle_instanced_arrays
    if (instancing) {
      CUR_INSTANCES = def(stackTop(DRAW_STATE.instances))
      INSTANCE_EXT = link(instancing)
    }
    var hasDynamicElements = 'elements' in options

    // -------------------------------
    // batch/argument vars
    // -------------------------------
    var NUM_ARGS = arg()
    var ARGS = arg()
    var ARG = def()
    var BATCH_ID = def()

    // -------------------------------
    // load a dynamic variable
    // -------------------------------
    var dynamicVars = {}
    function dyn (x) {
      var id = x.id
      var result = dynamicVars[id]
      if (result) {
        return result
      }
      if (x.func) {
        result = batch.def(
          link(x.data), '(', ARG, ',', BATCH_ID, ',', FRAME_STATE, ')')
      } else {
        result = batch.def(ARG, '.', x.data)
      }
      dynamicVars[id] = result
      return result
    }

    // -------------------------------
    // retrieves the first name-matching record from an ActiveInfo list
    // -------------------------------
    function findInfo (list, name) {
      return list.find(function (item) {
        return item.name === name
      })
    }

    // -------------------------------
    // bind shader
    // -------------------------------
    batch(GL, '.useProgram(', PROGRAM, ');')

    // -------------------------------
    // set static uniforms
    // -------------------------------
    program.uniforms.forEach(function (uniform) {
      if (uniform.name in uniforms) {
        return
      }
      var LOCATION = link(uniform.location)
      var STACK = link(uniformState.uniforms[uniform.name])
      var TOP = STACK + '[' + STACK + '.length-1]'
      if (uniform.info.type === GL_SAMPLER_2D ||
          uniform.info.type === GL_SAMPLER_CUBE) {
        var TEX_VALUE = def(TOP + '._texture')
        batch(setUniformString(GL, GL_INT, LOCATION, TEX_VALUE + '.bind()'))
        exit(TEX_VALUE, '.unbind();')
      } else {
        batch(setUniformString(GL, uniform.info.type, LOCATION, TOP))
      }
    })

    // -------------------------------
    // set static attributes
    // -------------------------------
    program.attributes.forEach(function (attribute) {
      if (attributes.name in attributes) {
        return
      }
      var STACK = link(attributeState.attributes[attribute.name])
      batch(BIND_ATTRIBUTE, '(',
        attribute.location, ',',
        link(attributeState.bindings[attribute.location]), ',',
        STACK, '.records[', STACK, '.top]', ',',
        typeLength(attribute.info.type), ');')
    })

    // -------------------------------
    // set static element buffer
    // -------------------------------
    if (!hasDynamicElements) {
      batch(
        'if(', CUR_ELEMENTS, '){',
        GL, '.bindBuffer(', GL_ELEMENT_ARRAY_BUFFER, ',', CUR_ELEMENTS, '.buffer._buffer.buffer);',
        '}else{',
        GL, '.bindBuffer(', GL_ELEMENT_ARRAY_BUFFER, ',null);',
        '}')
    }

    // -------------------------------
    // loop over all arguments
    // -------------------------------
    batch(
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_ARGS, ';++', BATCH_ID, '){',
      ARG, '=', ARGS, '[', BATCH_ID, '];')

    // -------------------------------
    // set dynamic flags
    // -------------------------------
    Object.keys(options).forEach(function (option) {
      var VALUE = dyn(options[option])

      function setCap (flag) {
        batch(
          'if(', VALUE, '){',
          GL, '.enable(', flag, ');}else{',
          GL, '.disable(', flag, ');}')
      }

      switch (option) {
        // Caps
        case 'cull.enable':
          setCap(GL_CULL_FACE)
          break
        case 'blend.enable':
          setCap(GL_BLEND)
          break
        case 'dither':
          setCap(GL_DITHER)
          break
        case 'stencil.enable':
          setCap(GL_STENCIL_TEST)
          break
        case 'depth.enable':
          setCap(GL_DEPTH_TEST)
          break
        case 'scissor.enable':
          setCap(GL_SCISSOR_TEST)
          break
        case 'polygonOffset.enable':
          setCap(GL_POLYGON_OFFSET_FILL)
          break
        case 'sample.alpha':
          setCap(GL_SAMPLE_ALPHA_TO_COVERAGE)
          break
        case 'sample.enable':
          setCap(GL_SAMPLE_COVERAGE)
          break

        case 'depth.mask':
          batch(GL, '.depthMask(', VALUE, ');')
          break

        case 'depth.func':
          var DEPTH_FUNCS = link(compareFuncs)
          batch(GL, '.depthFunc(', DEPTH_FUNCS, '[', VALUE, ']);')
          break

        case 'depth.range':
          batch(GL, '.depthRange(', VALUE, '[0],', VALUE, '[1]);')
          break

        case 'blend.color':
          batch(GL, '.blendColor(',
            VALUE, '[0],',
            VALUE, '[1],',
            VALUE, '[2],',
            VALUE, '[3]);')
          break

        case 'blend.equation':
          var BLEND_EQUATIONS = link(blendEquations)
          batch(
            'if(typeof ', VALUE, '==="string"){',
            GL, '.blendEquation(', BLEND_EQUATIONS, '[', VALUE, ']);',
            '}else{',
            GL, '.blendEquationSeparate(',
            BLEND_EQUATIONS, '[', VALUE, '.rgb],',
            BLEND_EQUATIONS, '[', VALUE, '.alpha]);',
            '}')
          break

        case 'blend.func':
          var BLEND_FUNCS = link(blendFuncs)
          batch(
            GL, '.blendFuncSeparate(',
            BLEND_FUNCS,
            '["srcRGB" in ', VALUE, '?', VALUE, '.srcRGB:', VALUE, '.src],',
            BLEND_FUNCS,
            '["dstRGB" in ', VALUE, '?', VALUE, '.dstRGB:', VALUE, '.dst],',
            BLEND_FUNCS,
            '["srcAlpha" in ', VALUE, '?', VALUE, '.srcAlpha:', VALUE, '.src],',
            BLEND_FUNCS,
            '["dstAlpha" in ', VALUE, '?', VALUE, '.dstAlpha:', VALUE, '.dst]);')
          break

        case 'stencil.mask':
          batch(GL, '.stencilMask(', VALUE, ');')
          break

        case 'stencil.func':
          var STENCIL_FUNCS = link(compareFuncs)
          batch(GL, '.stencilFunc(',
            STENCIL_FUNCS, '[', VALUE, '.cmp||"always"],',
            VALUE, '.ref|0,',
            '"mask" in ', VALUE, '?', VALUE, '.mask:-1);')
          break

        case 'stencil.opFront':
        case 'stencil.opBack':
          var STENCIL_OPS = link(stencilOps)
          batch(GL, '.stencilOpSeparate(',
            option === 'stencil.opFront' ? GL_FRONT : GL_BACK, ',',
            STENCIL_OPS, '[', VALUE, '.fail||"keep"],',
            STENCIL_OPS, '[', VALUE, '.zfail||"keep"],',
            STENCIL_OPS, '[', VALUE, '.pass||"keep"]);')
          break

        case 'polygonOffset.offset':
          batch(GL, '.polygonOffset(',
            VALUE, '.factor||0,',
            VALUE, '.units||0);')
          break

        case 'cull.face':
          batch(GL, '.cullFace(',
            VALUE, '==="front"?', GL_FRONT, ':', GL_BACK, ');')
          break

        case 'lineWidth':
          batch(GL, '.lineWidth(', VALUE, ');')
          break

        case 'frontFace':
          batch(GL, '.frontFace(',
            VALUE, '==="cw"?', GL_CW, ':', GL_CCW, ');')
          break

        case 'colorMask':
          batch(GL, '.colorMask(',
            VALUE, '[0],',
            VALUE, '[1],',
            VALUE, '[2],',
            VALUE, '[3]);')
          break

        case 'sample.coverage':
          batch(GL, '.sampleCoverage(',
            VALUE, '.value,',
            VALUE, '.invert);')
          break

        case 'scissor.box':
          var SCISSOR_X = batch.def(VALUE + '.x||0')
          var SCISSOR_Y = batch.def(VALUE + '.y||0')
          batch(GL, '.scissor(',
            SCISSOR_X, ',',
            SCISSOR_Y, ',',
            '"w" in ', VALUE, '?', VALUE, '.w:', GL, '.drawingBufferWidth-', SCISSOR_X, ',',
            '"h" in ', VALUE, '?', VALUE, '.h:', GL, '.drawingBufferHeight-', SCISSOR_Y, ');')
          break

        case 'viewport':
          var VIEWPORT_X = batch.def(VALUE + '.x||0')
          var VIEWPORT_Y = batch.def(VALUE + '.y||0')
          batch(GL, '.viewport(',
            VIEWPORT_X, ',',
            VIEWPORT_Y, ',',
            '"w" in ', VALUE, '?', VALUE, '.w:', GL, '.drawingBufferWidth-', VIEWPORT_X, ',',
            '"h" in ', VALUE, '?', VALUE, '.h:', GL, '.drawingBufferHeight-', VIEWPORT_Y, ');')
          break

        case 'primitives':
        case 'offset':
        case 'count':
        case 'elements':
          break

        default:
          check.raise('unsupported option for batch', option)
      }
    })

    // -------------------------------
    // set dynamic uniforms
    // -------------------------------
    var programUniforms = program.uniforms
    var DYNAMIC_TEXTURES = []
    Object.keys(uniforms).forEach(function (uniform) {
      var data = findInfo(programUniforms, uniform)
      if (!data) {
        return
      }
      var TYPE = data.info.type
      var LOCATION = link(data.location)
      var VALUE = dyn(uniforms[uniform])
      if (uniform.info.type === GL_SAMPLER_2D ||
          uniform.info.type === GL_SAMPLER_CUBE) {
        var TEX_VALUE = def(VALUE + '._texture')
        DYNAMIC_TEXTURES.push(TEX_VALUE)
        batch(setUniformString(GL, GL_INT, LOCATION, TEX_VALUE + '.bind()'))
      } else {
        batch(setUniformString(GL, TYPE, LOCATION, VALUE))
      }
    })
    DYNAMIC_TEXTURES.forEach(function (VALUE) {
      batch(VALUE, '.unbind();')
    })

    // -------------------------------
    // set dynamic attributes
    // -------------------------------
    var programAttributes = program.attributes
    Object.keys(attributes).forEach(function (attribute) {
      var data = findInfo(programAttributes, attribute)
      if (!data) {
        return
      }
      batch(BIND_ATTRIBUTE, '(',
        data.location, ',',
        link(attribute.bindings[data.location]), ',',
        dyn(attributes[attribute]), ',',
        typeLength(data.info.type), ');')
    })

    // -------------------------------
    // set dynamic attributes
    // -------------------------------

    if (options.count) {
      batch(CUR_COUNT, '=', dyn(options.count), ';')
    } else if (!useElementOption('count')) {
      batch('if(', CUR_COUNT, '){')
    }
    if (options.offset) {
      batch(CUR_OFFSET, '=', dyn(options.offset), ';')
    }
    if (options.primitive) {
      var PRIM_TYPES = link(primTypes)
      batch(CUR_PRIMITIVE, '=', PRIM_TYPES, '[', dyn(options.primitive), '];')
    }

    function useElementOption (x) {
      return hasDynamicElements && !(x in options || x in staticOptions)
    }
    if (hasDynamicElements) {
      var dynElements = dyn(options.elements)
      batch(CUR_ELEMENTS, '=',
        dynElements, '?', dynElements, '._elements:null;')
    }
    if (useElementOption('offset')) {
      batch(CUR_OFFSET, '=0;')
    }

    // Emit draw command
    batch('if(', CUR_ELEMENTS, '){')
    if (useElementOption('count')) {
      batch(CUR_COUNT, '=', CUR_ELEMENTS, '.vertCount;',
        'if(', CUR_COUNT, '>0){')
    }
    if (useElementOption('primitive')) {
      batch(CUR_PRIMITIVE, '=', CUR_ELEMENTS, '.primType;')
    }
    if (hasDynamicElements) {
      batch(
        GL,
        '.bindBuffer(',
        GL_ELEMENT_ARRAY_BUFFER, ',',
        CUR_ELEMENTS, '.buffer._buffer.buffer);')
    }
    if (instancing) {
      if (options.instances) {
        batch(CUR_INSTANCES, '=', dyn(options.instances), ';')
      }
      batch(
        'if(', CUR_INSTANCES, '>0){',
        INSTANCE_EXT, '.drawElementsInstancedANGLE(',
        CUR_PRIMITIVE, ',',
        CUR_COUNT, ',',
        CUR_ELEMENTS, '.type,',
        CUR_OFFSET, ',',
        CUR_INSTANCES, ');}else{')
    }
    batch(
      GL, '.drawElements(',
      CUR_PRIMITIVE, ',',
      CUR_COUNT, ',',
      CUR_ELEMENTS, '.type,',
      CUR_OFFSET, ');')
    if (instancing) {
      batch('}')
    }
    if (useElementOption('count')) {
      batch('}')
    }
    batch('}else{')
    if (!useElementOption('count')) {
      if (useElementOption('primitive')) {
        batch(CUR_PRIMITIVE, '=', GL_TRIANGLES, ';')
      }
      if (instancing) {
        batch(
          'if(', CUR_INSTANCES, '>0){',
          INSTANCE_EXT, '.drawArraysInstancedANGLE(',
          CUR_PRIMITIVE, ',',
          CUR_OFFSET, ',',
          CUR_COUNT, ',',
          CUR_INSTANCES, ');}else{')
      }
      batch(
        GL, '.drawArrays(',
        CUR_PRIMITIVE, ',',
        CUR_OFFSET, ',',
        CUR_COUNT, ');}')
      if (instancing) {
        batch('}')
      }
    }
    batch('}}', exit)

    // -------------------------------
    // compile and return
    // -------------------------------
    return env.compile().batch
  }

  // ===================================================
  // ===================================================
  // MAIN DRAW COMMAND
  // ===================================================
  // ===================================================
  function compileCommand (
    staticOptions, staticUniforms, staticAttributes,
    dynamicOptions, dynamicUniforms, dynamicAttributes,
    hasDynamic) {
    // Create code generation environment
    var env = createEnvironment()
    var link = env.link
    var block = env.block
    var proc = env.proc

    var callId = drawCallCounter++

    // -------------------------------
    // Common state variables
    // -------------------------------
    var GL_POLL = link(glState.poll)
    var FRAG_SHADER_STATE = link(shaderState.fragShaders)
    var VERT_SHADER_STATE = link(shaderState.vertShaders)
    var PROGRAM_STATE = link(shaderState.programs)
    var DRAW_STATE = {
      count: link(drawState.count),
      offset: link(drawState.offset),
      instances: link(drawState.instances),
      primitive: link(drawState.primitive)
    }
    var ELEMENT_STATE = link(elementState.elements)
    var PRIM_TYPES = link(primTypes)
    var COMPARE_FUNCS = link(compareFuncs)
    var STENCIL_OPS = link(stencilOps)

    var CONTEXT_STATE = {}
    function linkContext (x) {
      var result = CONTEXT_STATE[x]
      if (result) {
        return result
      }
      result = CONTEXT_STATE[x] = link(contextState[x])
      return result
    }

    // ==========================================================
    // STATIC STATE
    // ==========================================================
    // Code blocks for the static sections
    var entry = block()
    var exit = block()

    // -------------------------------
    // update default context state variables
    // -------------------------------
    function handleStaticOption (param, value) {
      var STATE_STACK = linkContext(param)
      entry(STATE_STACK, '.push(', value, ');')
      exit(STATE_STACK, '.pop();')
    }

    var hasShader = false
    Object.keys(staticOptions).forEach(function (param) {
      var value = staticOptions[param]
      switch (param) {
        case 'frag':
          hasShader = true
          entry(FRAG_SHADER_STATE, '.push(', link(value), ');')
          exit(FRAG_SHADER_STATE, '.pop();')
          break

        case 'vert':
          hasShader = true
          entry(VERT_SHADER_STATE, '.push(', link(value), ');')
          exit(VERT_SHADER_STATE, '.pop();')
          break

        // Update draw state
        case 'count':
        case 'offset':
        case 'instances':
          check.nni(value, param)
          entry(DRAW_STATE[param], '.push(', value, ');')
          exit(DRAW_STATE[param], '.pop();')
          break

        // Update primitive type
        case 'primitive':
          check.parameter(value, primTypes, 'not a valid drawing primitive')
          var primType = primTypes[value]
          entry(DRAW_STATE.primitive, '.push(', primType, ');')
          exit(DRAW_STATE.primitive, '.pop();')
          break

        // Update element buffer
        case 'elements':
          var elements = elementState.getElements(value)
          var hasPrimitive = !('primitive' in staticOptions)
          var hasCount = !('count' in staticOptions)
          if (elements) {
            var ELEMENTS = link(elements)
            entry(ELEMENT_STATE, '.push(', ELEMENTS, ');')
            if (hasPrimitive) {
              entry(DRAW_STATE.primitive, '.push(', ELEMENTS, '.primType);')
            }
            if (hasCount) {
              entry(DRAW_STATE.count, '.push(', ELEMENTS, '.vertCount);')
            }
          } else {
            entry(ELEMENT_STATE, '.push(null);')
            if (hasPrimitive) {
              entry(DRAW_STATE.primitive, '.push(', GL_TRIANGLES, ');')
            }
            if (hasCount) {
              entry(DRAW_STATE.count, '.push(0);')
            }
          }
          if (hasPrimitive) {
            exit(DRAW_STATE.primitive, '.pop();')
          }
          if (hasCount) {
            exit(DRAW_STATE.count, '.pop();')
          }
          if (!('offset' in staticOptions)) {
            entry(DRAW_STATE.offset, '.push(0);')
            exit(DRAW_STATE.offset, '.pop();')
          }
          exit(ELEMENT_STATE, '.pop();')
          break

        case 'cull.enable':
        case 'blend.enable':
        case 'dither':
        case 'stencil.enable':
        case 'depth.enable':
        case 'scissor.enable':
        case 'polygonOffset.enable':
        case 'sample.alpha':
        case 'sample.enable':
        case 'depth.mask':
          check.type(value, 'boolean', param)
          handleStaticOption(param, value)
          break

        case 'depth.func':
          check.parameter(value, compareFuncs, param)
          handleStaticOption(param, compareFuncs[value])
          break

        case 'depth.range':
          check(
            Array.isArray(value) &&
            value.length === 2 &&
            value[0] <= value[1],
            'depth range is 2d array')
          var DEPTH_RANGE_STACK = linkContext(param)
          entry(DEPTH_RANGE_STACK, '.push(', value[0], ',', value[1], ');')
          exit(DEPTH_RANGE_STACK, '.pop();')
          break

        case 'blend.func':
          var BLEND_FUNC_STACK = linkContext(param)
          check.type(value, 'object', 'blend func must be an object')
          var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
          var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
          var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
          var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
          check.parameter(srcRGB, blendFuncs)
          check.parameter(srcAlpha, blendFuncs)
          check.parameter(dstRGB, blendFuncs)
          check.parameter(dstAlpha, blendFuncs)
          entry(BLEND_FUNC_STACK, '.push(',
            blendFuncs[srcRGB], ',',
            blendFuncs[dstRGB], ',',
            blendFuncs[srcAlpha], ',',
            blendFuncs[dstAlpha], ');')
          exit(BLEND_FUNC_STACK, '.pop();')
          break

        case 'blend.equation':
          var BLEND_EQUATION_STACK = linkContext(param)
          if (typeof value === 'string') {
            check.parameter(value, blendEquations, 'invalid blend equation')
            entry(BLEND_EQUATION_STACK,
              '.push(',
              blendEquations[value], ',',
              blendEquations[value], ');')
          } else if (typeof value === 'object') {
            check.parameter(
              value.rgb, blendEquations, 'invalid blend equation rgb')
            check.parameter(
              value.alpha, blendEquations, 'invalid blend equation alpha')
            entry(BLEND_EQUATION_STACK,
              '.push(',
              blendEquations[value.rgb], ',',
              blendEquations[value.alpha], ');')
          } else {
            check.raise('invalid blend equation')
          }
          exit(BLEND_EQUATION_STACK, '.pop();')
          break

        case 'blend.color':
          check(
            Array.isArray(value) &&
            value.length === 4,
            'blend color is a 4d array')
          var BLEND_COLOR_STACK = linkContext(param)
          entry(BLEND_COLOR_STACK,
            '.push(',
            value[0], ',',
            value[1], ',',
            value[2], ',',
            value[3], ');')
          exit(BLEND_COLOR_STACK, '.pop();')
          break

        case 'stencil.mask':
          check.type(value, 'number', 'stencil mask must be an integer')
          var STENCIL_MASK_STACK = linkContext(param)
          entry(STENCIL_MASK_STACK, '.push(', value, ');')
          exit(STENCIL_MASK_STACK, '.pop();')
          break

        case 'stencil.func':
          check.type(value, 'object', 'stencil func must be an object')
          var cmp = value.cmp || 'keep'
          var ref = value.ref || 0
          var mask = 'mask' in value ? value.mask : -1
          check.parameter(cmp, compareFuncs, 'invalid stencil func cmp')
          check.type(ref, 'number', 'stencil func ref')
          check.type(mask, 'number', 'stencil func mask')
          var STENCIL_FUNC_STACK = linkContext(param)
          entry(STENCIL_FUNC_STACK, '.push(',
            compareFuncs[cmp], ',',
            ref, ',',
            mask, ');')
          exit(STENCIL_FUNC_STACK, '.pop();')
          break

        case 'stencil.opFront':
        case 'stencil.opBack':
          check.type(value, 'object', param)
          var fail = value.fail || 'keep'
          var zfail = value.zfail || 'keep'
          var pass = value.pass || 'keep'
          check.parameter(fail, stencilOps, param)
          check.parameter(zfail, stencilOps, param)
          check.parameter(pass, stencilOps, param)
          var STENCIL_OP_STACK = linkContext(param)
          entry(STENCIL_OP_STACK, '.push(',
            stencilOps[fail], ',',
            stencilOps[zfail], ',',
            stencilOps[pass], ');')
          exit(STENCIL_OP_STACK, '.pop();')
          break

        case 'polygonOffset.offset':
          check.type(value, 'object', param)
          var factor = value.factor || 0
          var units = value.units || 0
          check.type(factor, 'number', 'offset.factor')
          check.type(units, 'number', 'offset.units')
          var POLYGON_OFFSET_STACK = linkContext(param)
          entry(POLYGON_OFFSET_STACK, '.push(',
            factor, ',', units, ');')
          exit(POLYGON_OFFSET_STACK, '.pop();')
          break

        case 'cull.face':
          var face = 0
          if (value === 'front') {
            face = GL_FRONT
          } else if (value === 'back') {
            face = GL_BACK
          }
          check(!!face, 'cull.face')
          var CULL_FACE_STACK = linkContext(param)
          entry(CULL_FACE_STACK, '.push(', face, ');')
          exit(CULL_FACE_STACK, '.pop();')
          break

        case 'lineWidth':
          check(value > 0 && typeof value === 'number', param)
          handleStaticOption(param, value)
          break

        case 'frontFace':
          var orientation = 0
          if (value === 'cw') {
            orientation = GL_CW
          } else if (value === 'ccw') {
            orientation = GL_CCW
          }
          check(!!orientation, 'frontFace')
          var FRONT_FACE_STACK = linkContext(param)
          entry(FRONT_FACE_STACK, '.push(', orientation, ');')
          exit(FRONT_FACE_STACK, '.pop();')
          break

        case 'colorMask':
          check(Array.isArray(value) && value.length === 4, 'color mask must be length 4 array')
          var COLOR_MASK_STACK = linkContext(param)
          entry(COLOR_MASK_STACK, '.push(',
            value.map(function (v) { return !!v }).join(),
            ');')
          exit(COLOR_MASK_STACK, '.pop();')
          break

        case 'sample.coverage':
          check.type(value, 'object', param)
          var sampleValue = 'value' in value ? value.value : 1
          var sampleInvert = !!value.invert
          check(
            typeof sampleValue === 'number' &&
            sampleValue >= 0 && sampleValue <= 1,
            'sample value')
          var SAMPLE_COVERAGE_STACK = linkContext(param)
          entry(SAMPLE_COVERAGE_STACK, '.push(',
            sampleValue, ',', sampleInvert, ');')
          exit(SAMPLE_COVERAGE_STACK, '.pop();')
          break

        case 'viewport':
        case 'scissor.box':
          check(typeof value === 'object' && value, param + ' is an object')
          var X = value.x || 0
          var Y = value.y || 0
          var W = -1
          var H = -1
          check(typeof X === 'number' && X >= 0, param + '.x must be a positive int')
          check(typeof Y === 'number' && Y >= 0, param + '.y must be a positive int')
          if ('w' in value) {
            W = value.w
            check(typeof W === 'number' && W >= 0, param + '.w must be a positive int')
          }
          if ('h' in value) {
            H = value.h
            check(typeof H === 'number' && H >= 0, param + '.h must be a positive int')
          }
          var BOX_STACK = linkContext(param)
          entry(BOX_STACK, '.push(', X, ',', Y, ',', W, ',', H, ');')
          exit(BOX_STACK, '.pop();')
          break

        default:
          // TODO Should this just be a warning instead?
          check.raise('unsupported parameter ' + param)
          break
      }
    })

    // -------------------------------
    // update shader program
    // -------------------------------
    if (hasShader) {
      if (staticOptions.frag && staticOptions.vert) {
        var fragSrc = staticOptions.frag
        var vertSrc = staticOptions.vert
        entry(PROGRAM_STATE, '.push(',
          link(shaderState.create(vertSrc, fragSrc)), ');')
      } else {
        var FRAG_SRC = entry.def(
          FRAG_SHADER_STATE, '[', FRAG_SHADER_STATE, '.length-1]')
        var VERT_SRC = entry.def(
          VERT_SHADER_STATE, '[', VERT_SHADER_STATE, '.length-1]')
        var LINK_PROG = link(shaderState.create)
        entry(
          PROGRAM_STATE, '.push(',
          LINK_PROG, '(', FRAG_SRC, ',', VERT_SRC, '));')
      }
      exit(PROGRAM_STATE, '.pop();')
    }

    // -------------------------------
    // update static uniforms
    // -------------------------------
    Object.keys(staticUniforms).forEach(function (uniform) {
      uniformState.def(uniform)
      var STACK = link(uniformState.uniforms[uniform])
      var VALUE
      var value = staticUniforms[uniform]
      if (typeof value === 'function' && value._reglType) {
        VALUE = link(value)
      } else if (Array.isArray(value)) {
        VALUE = link(value.slice())
      } else {
        VALUE = +value
      }
      entry(STACK, '.push(', VALUE, ');')
      exit(STACK, '.pop();')
    })

    // -------------------------------
    // update default attributes
    // -------------------------------
    Object.keys(staticAttributes).forEach(function (attribute) {
      attributeState.def(attribute)
      var ATTRIBUTE = link(attributeState.attributes[attribute])

      var data = staticAttributes[attribute]
      if (typeof data === 'number') {
        entry(ATTRIBUTE, '.pushVec(', +data, ',0,0,0);')
      } else {
        check(!!data, 'invalid attribute: ' + attribute)

        if (Array.isArray(data)) {
          entry(
            ATTRIBUTE, '.pushVec(',
            [data[0] || 0, data[1] || 0, data[2] || 0, data[3] || 0], ');')
        } else {
          var buffer = bufferState.getBuffer(data)
          var size = 0
          var stride = 0
          var offset = 0
          var divisor = 0
          var normalized = false
          var type = GL_FLOAT

          if (!buffer) {
            check.type(data, 'object', 'invalid attribute "' + attribute + '"')

            buffer = bufferState.getBuffer(data.buffer)
            size = data.size || 0
            stride = data.stride || 0
            offset = data.offset || 0
            divisor = data.divisor || 0
            normalized = data.normalized || false

            check(!!buffer, 'invalid attribute ' + attribute + '.buffer')

            // Check for user defined type overloading
            type = buffer.dtype
            if ('type' in data) {
              check.parameter(data.type, glTypes, 'attribute type')
              type = glTypes[data.type]
            }
          } else {
            type = buffer.dtype
          }

          check(!!buffer, 'invalid attribute ' + attribute + '.buffer')
          check.nni(stride, attribute + '.stride')
          check.nni(offset, attribute + '.offset')
          check.nni(divisor, attribute + '.divisor')
          check.type(normalized, 'boolean', attribute + '.normalized')
          check.oneOf(size, [0, 1, 2, 3, 4], attribute + '.size')

          entry(
            ATTRIBUTE, '.pushPtr(', [
              link(buffer), size, offset, stride,
              divisor, normalized, type
            ].join(), ');')
        }
      }
      exit(ATTRIBUTE, '.pop();')
    })

    // ==========================================================
    // DYNAMIC STATE (for scope and draw)
    // ==========================================================
    // Generated code blocks for dynamic state flags
    var dynamicEntry = env.block()
    var dynamicExit = env.block()

    var FRAMESTATE
    var DYNARGS
    if (hasDynamic) {
      FRAMESTATE = link(frameState)
      DYNARGS = entry.def()
    }

    var dynamicVars = {}
    function dyn (x) {
      var id = x.id
      var result = dynamicVars[id]
      if (result) {
        return result
      }
      if (x.func) {
        result = dynamicEntry.def(
          link(x.data), '(', DYNARGS, ',0,', FRAMESTATE, ')')
      } else {
        result = dynamicEntry.def(DYNARGS, '.', x.data)
      }
      dynamicVars[id] = result
      return result
    }

    // -------------------------------
    // dynamic context state variables
    // -------------------------------
    Object.keys(dynamicOptions).forEach(function (param) {
      // Link in dynamic variable
      var variable = dyn(dynamicOptions[param])

      switch (param) {
        case 'cull.enable':
        case 'blend.enable':
        case 'dither':
        case 'stencil.enable':
        case 'depth.enable':
        case 'scissor.enable':
        case 'polygonOffset.enable':
        case 'sample.alpha':
        case 'sample.enable':
        case 'lineWidth':
        case 'depth.mask':
          var STATE_STACK = linkContext(param)
          dynamicEntry(STATE_STACK, '.push(', variable, ');')
          dynamicExit(STATE_STACK, '.pop();')
          break

        // Draw calls
        case 'count':
        case 'offset':
        case 'instances':
          var DRAW_STACK = DRAW_STATE[param]
          dynamicEntry(DRAW_STACK, '.push(', variable, ');')
          dynamicExit(DRAW_STACK, '.pop();')
          break

        case 'primitive':
          var PRIM_STACK = DRAW_STATE.primitive
          dynamicEntry(PRIM_STACK, '.push(', PRIM_TYPES, '[', variable, ']);')
          dynamicExit(PRIM_STACK, '.pop();')
          break

        case 'depth.func':
          var DEPTH_FUNC_STACK = linkContext(param)
          dynamicEntry(DEPTH_FUNC_STACK, '.push(', COMPARE_FUNCS, '[', variable, ']);')
          dynamicExit(DEPTH_FUNC_STACK, '.pop();')
          break

        case 'blend.func':
          var BLEND_FUNC_STACK = linkContext(param)
          var BLEND_FUNCS = link(blendFuncs)
          dynamicEntry(
            BLEND_FUNC_STACK, '.push(',
            BLEND_FUNCS,
            '["srcRGB" in ', variable, '?', variable, '.srcRGB:', variable, '.src],',
            BLEND_FUNCS,
            '["dstRGB" in ', variable, '?', variable, '.dstRGB:', variable, '.dst],',
            BLEND_FUNCS,
            '["srcAlpha" in ', variable, '?', variable, '.srcAlpha:', variable, '.src],',
            BLEND_FUNCS,
            '["dstAlpha" in ', variable, '?', variable, '.dstAlpha:', variable, '.dst]);')
          dynamicExit(BLEND_FUNC_STACK, '.pop();')
          break

        case 'blend.equation':
          var BLEND_EQUATION_STACK = linkContext(param)
          var BLEND_EQUATIONS = link(blendEquations)
          dynamicEntry(
            'if(typeof ', variable, '==="string"){',
              BLEND_EQUATION_STACK, '.push(',
              BLEND_EQUATIONS, '[', variable, '],',
              BLEND_EQUATIONS, '[', variable, ']);',
            '}else{',
              BLEND_EQUATION_STACK, '.push(',
              BLEND_EQUATIONS, '[', variable, '.rgb],',
              BLEND_EQUATIONS, '[', variable, '.alpha]);',
            '}')
          dynamicExit(BLEND_EQUATION_STACK, '.pop();')
          break

        case 'blend.color':
          var BLEND_COLOR_STACK = linkContext(param)
          dynamicEntry(BLEND_COLOR_STACK, '.push(',
            variable, '[0],',
            variable, '[1],',
            variable, '[2],',
            variable, '[3]);')
          dynamicExit(BLEND_COLOR_STACK, '.pop();')
          break

        case 'stencil.mask':
          var STENCIL_MASK_STACK = linkContext(param)
          dynamicEntry(STENCIL_MASK_STACK, '.push(', variable, ');')
          dynamicExit(STENCIL_MASK_STACK, '.pop();')
          break

        case 'stencil.func':
          var STENCIL_FUNC_STACK = linkContext(param)
          dynamicEntry(STENCIL_FUNC_STACK, '.push(',
            COMPARE_FUNCS, '[', variable, '.cmp],',
            variable, '.ref|0,',
            '"mask" in ', variable, '?', variable, '.mask:-1);')
          dynamicExit(STENCIL_FUNC_STACK, '.pop();')
          break

        case 'stencil.opFront':
        case 'stencil.opBack':
          var STENCIL_OP_STACK = linkContext(param)
          dynamicEntry(STENCIL_OP_STACK, '.push(',
            STENCIL_OPS, '[', variable, '.fail||"keep"],',
            STENCIL_OPS, '[', variable, '.zfail||"keep"],',
            STENCIL_OPS, '[', variable, '.pass||"keep"]);')
          dynamicExit(STENCIL_OP_STACK, '.pop();')
          break

        case 'polygonOffset.offset':
          var POLYGON_OFFSET_STACK = linkContext(param)
          dynamicEntry(POLYGON_OFFSET_STACK, '.push(',
            variable, '.factor||0,',
            variable, '.units||0);')
          dynamicExit(POLYGON_OFFSET_STACK, '.pop();')
          break

        case 'cull.face':
          var CULL_FACE_STACK = linkContext(param)
          dynamicEntry(CULL_FACE_STACK, '.push(',
            variable, '==="front"?', GL_FRONT, ':', GL_BACK, ');')
          dynamicExit(CULL_FACE_STACK, '.pop();')
          break

        case 'frontFace':
          var FRONT_FACE_STACK = linkContext(param)
          dynamicEntry(FRONT_FACE_STACK, '.push(',
            variable, '==="cw"?', GL_CW, ':', GL_CCW, ');')
          dynamicExit(FRONT_FACE_STACK, '.pop();')
          break

        case 'colorMask':
          var COLOR_MASK_STACK = linkContext(param)
          dynamicEntry(COLOR_MASK_STACK, '.push(',
            variable, '[0],',
            variable, '[1],',
            variable, '[2],',
            variable, '[3]);')
          dynamicExit(COLOR_MASK_STACK, '.pop();')
          break

        case 'sample.coverage':
          var SAMPLE_COVERAGE_STACK = linkContext(param)
          dynamicEntry(SAMPLE_COVERAGE_STACK, '.push(',
            variable, '.value,',
            variable, '.invert);')
          dynamicExit(SAMPLE_COVERAGE_STACK, '.pop();')
          break

        case 'scissor.box':
        case 'viewport':
          var BOX_STACK = linkContext(param)
          dynamicEntry(BOX_STACK, '.push(',
            variable, '.x||0,',
            variable, '.y||0,',
            '"w" in ', variable, '?', variable, '.w:-1,',
            '"h" in ', variable, '?', variable, '.h:-1);')
          dynamicExit(BOX_STACK, '.pop();')
          break

        case 'elements':
          var hasPrimitive =
            !('primitive' in dynamicOptions) &&
            !('primitive' in staticOptions)
          var hasCount =
            !('count' in dynamicOptions) &&
            !('count' in staticOptions)
          var hasOffset =
            !('offset' in dynamicOptions) &&
            !('offset' in staticOptions)
          var ELEMENTS = dynamicEntry.def()
          dynamicEntry(
            'if(', variable, '){',
            ELEMENTS, '=', variable, '._elements;',
            ELEMENT_STATE, '.push(', ELEMENTS, ');',
            !hasPrimitive ? ''
              : DRAW_STATE.primitive + '.push(' + ELEMENTS + '.primType);',
            !hasCount ? ''
              : DRAW_STATE.count + '.push(' + ELEMENTS + '.vertCount);',
            !hasOffset ? ''
              : DRAW_STATE.offset + '.push(' + ELEMENTS + '.offset);',
            '}else{',
            ELEMENT_STATE, '.push(null);',
            '}')
          dynamicExit(
            ELEMENT_STATE, '.pop();',
            'if(', variable, '){',
            hasPrimitive ? DRAW_STATE.primitive + '.pop();' : '',
            hasCount ? DRAW_STATE.count + '.pop();' : '',
            hasOffset ? DRAW_STATE.offset + '.pop();' : '',
            '}')
          break

        default:
          check.raise('unsupported dynamic option: ' + param)
      }
    })

    // -------------------------------
    // dynamic uniforms
    // -------------------------------
    Object.keys(dynamicUniforms).forEach(function (uniform) {
      uniformState.def(uniform)
      var STACK = link(uniformState.uniforms[uniform])
      var VALUE = dyn(dynamicUniforms[uniform])
      dynamicEntry(STACK, '.push(', VALUE, ');')
      dynamicExit(STACK, '.pop();')
    })

    // -------------------------------
    // dynamic attributes
    // -------------------------------
    Object.keys(dynamicAttributes).forEach(function (attribute) {
      attributeState.def(attribute)
      var ATTRIBUTE = link(attributeState.attributes[attribute])
      var VALUE = dyn(dynamicAttributes[attribute])
      dynamicEntry(ATTRIBUTE, '.pushDyn(', VALUE, ');')
      dynamicExit(ATTRIBUTE, '.pop();')
    })

    // ==========================================================
    // SCOPE PROCEDURE
    // ==========================================================
    var scope = proc('scope')
    var SCOPE_ARGS = scope.arg()
    var SCOPE_BODY = scope.arg()
    scope(entry)
    if (hasDynamic) {
      scope(
        DYNARGS, '=', SCOPE_ARGS, ';',
        dynamicEntry)
    }
    scope(
      SCOPE_BODY, '();',
      hasDynamic ? dynamicExit : '',
      exit)

    // ==========================================================
    // DRAW PROCEDURE
    // ==========================================================
    var draw = proc('draw')
    draw(entry)
    if (hasDynamic) {
      draw(
        DYNARGS, '=', draw.arg(), ';',
        dynamicEntry)
    }
    var CURRENT_SHADER = stackTop(PROGRAM_STATE)
    draw(
      GL_POLL, '();',
      'if(', CURRENT_SHADER, ')',
      CURRENT_SHADER, '.draw(', hasDynamic ? DYNARGS : '', ');',
      hasDynamic ? dynamicExit : '',
      exit)

    // ==========================================================
    // BATCH DRAW
    // ==========================================================
    var batch = proc('batch')
    batch(entry)
    var CUR_SHADER = batch.def(stackTop(PROGRAM_STATE))
    var EXEC_BATCH = link(function (program, count, args) {
      var proc = program.batchCache[callId]
      if (!proc) {
        proc = program.batchCache[callId] = compileBatch(
          program, dynamicOptions, dynamicUniforms, dynamicAttributes,
          staticOptions)
      }
      return proc(count, args)
    })
    batch(
      'if(', CUR_SHADER, '){',
      GL_POLL, '();',
      EXEC_BATCH, '(',
      CUR_SHADER, ',',
      batch.arg(), ',',
      batch.arg(), ');')
    // Set dirty on all dynamic flags
    Object.keys(dynamicOptions).forEach(function (option) {
      var STATE = CONTEXT_STATE[option]
      if (STATE) {
        batch(STATE, '.setDirty();')
      }
    })
    batch('}', exit)

    // -------------------------------
    // eval and bind
    // -------------------------------
    return env.compile()
  }

  return {
    draw: compileShaderDraw,
    command: compileCommand
  }
}

},{"./check":4,"./codegen":6,"./constants/blendequations.json":9,"./constants/blendfuncs.json":10,"./constants/comparefuncs.json":11,"./constants/dtypes.json":12,"./constants/primitives.json":13,"./constants/stencil-ops.json":14}],8:[function(require,module,exports){
module.exports={
  "[object Int8Array]": 5120
, "[object Int16Array]": 5122
, "[object Int32Array]": 5124
, "[object Uint8Array]": 5121
, "[object Uint8ClampedArray]": 5121
, "[object Uint16Array]": 5123
, "[object Uint32Array]": 5125
, "[object Float32Array]": 5126
, "[object Float64Array]": 5121
, "[object ArrayBuffer]": 5121
}

},{}],9:[function(require,module,exports){
module.exports={
  "add":32774,
  "subtract":32778,
  "reverse subtract":32779
}

},{}],10:[function(require,module,exports){
module.exports={
  "0":0,
  "1":1,
  "zero":0,
  "one":1,
  "src color": 768,
  "one minus src color":769,
  "src alpha":770,
  "one minus src alpha":771,
  "dst color":774,
  "one minus dst color":775,
  "dst alpha":772,
  "one minus dst alpha":773,
  "constant color": 32769,
  "one minus constant color": 32770,
  "constant alpha": 32771,
  "one minus constant alpha": 32772,
  "src alpha saturate": 776
}

},{}],11:[function(require,module,exports){
module.exports={
  "never": 512,
  "less": 513,
  "<": 513,
  "equal": 514,
  "=": 514,
  "==": 514,
  "===": 514,
  "lequal": 515,
  "<=": 515,
  "greater": 516,
  ">": 516,
  "notequal": 517,
  "!=": 517,
  "!==": 517,
  "gequal": 518,
  ">=": 518,
  "always": 519
}

},{}],12:[function(require,module,exports){
module.exports={
  "int8": 5120
, "int16": 5122
, "int32": 5124
, "uint8": 5121
, "uint16": 5123
, "uint32": 5125
, "float": 5126
}

},{}],13:[function(require,module,exports){
module.exports={
  "points": 0,
  "lines": 1,
  "line loop": 2,
  "line strip": 3,
  "triangles": 4,
  "triangle strip": 5,
  "triangle fan": 6
}

},{}],14:[function(require,module,exports){
module.exports={
  "0": 0,
  "zero": 0,
  "keep": 7680,
  "replace": 7681,
  "increment": 7682,
  "decrement": 7683,
  "increment wrap": 34055,
  "decrement wrap": 34056,
  "invert": 5386
}

},{}],15:[function(require,module,exports){
// Context and canvas creation helper functions
/*globals HTMLElement,WebGLRenderingContext*/

var check = require('./check')

function createCanvas (element, options) {
  var canvas = document.createElement('canvas')
  var args = getContext(canvas, options)

  Object.assign(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    Object.assign(element.style, {
      margin: 0,
      padding: 0
    })
  }

  var scale = +window.devicePixelRatio
  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = element.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.top - bounds.bottom
    }
    canvas.width = scale * w
    canvas.height = scale * h
    Object.assign(canvas.style, {
      width: w + 'px',
      height: h + 'px'
    })
  }

  window.addEventListener('resize', resize, false)

  var prevDestroy = args.options.onDestroy
  args.options = Object.assign({}, args.options, {
    onDestroy: function () {
      window.removeEventListener('resize', resize)
      element.removeChild(canvas)
      prevDestroy && prevDestroy()
    }
  })

  resize()

  return args
}

function getContext (canvas, options) {
  var glOptions = options.glOptions

  function get (name) {
    try {
      return canvas.getContext(name, glOptions)
    } catch (e) {
      return null
    }
  }

  var gl = get('webgl') ||
           get('experimental-webgl') ||
           get('webgl-experimental')

  check(gl, 'webgl not supported')

  return {
    gl: gl,
    options: options
  }
}

module.exports = function parseArgs (args) {
  if (typeof document === 'undefined' ||
      typeof HTMLElement === 'undefined') {
    return {
      gl: args[0],
      options: args[1] || {}
    }
  }

  var element = document.body
  var options = args[1] || {}

  if (typeof args[0] === 'string') {
    element = document.querySelector(args[0]) || document.body
  } else if (typeof args[0] === 'object') {
    if (args[0] instanceof HTMLElement) {
      element = args[0]
    } else if (args[0] instanceof WebGLRenderingContext) {
      return {
        gl: args[0],
        options: options
      }
    } else {
      options = args[0]
    }
  }

  if (element.nodeName && element.nodeName.toUpperCase() === 'CANVAS') {
    return getContext(element, options)
  } else {
    return createCanvas(element, options)
  }
}

},{"./check":4}],16:[function(require,module,exports){
var GL_TRIANGLES = 4

module.exports = function wrapDrawState (gl) {
  var primitive = [ GL_TRIANGLES ]
  var count = [ 0 ]
  var offset = [ 0 ]
  var instances = [ 0 ]

  return {
    primitive: primitive,
    count: count,
    offset: offset,
    instances: instances
  }
}

},{}],17:[function(require,module,exports){
var VARIABLE_COUNTER = 0

function DynamicVariable (isFunc, data) {
  this.id = (VARIABLE_COUNTER++)
  this.func = isFunc
  this.data = data
}

function defineDynamic (data, path) {
  switch (typeof data) {
    case 'boolean':
    case 'number':
    case 'string':
      return new DynamicVariable(false, data)
    case 'function':
      return new DynamicVariable(true, data)
    default:
      return defineDynamic
  }
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) ||
         x instanceof DynamicVariable
}

function unbox (x, path) {
  if (x instanceof DynamicVariable) {
    return x
  } else if (typeof x === 'function' &&
             x !== defineDynamic) {
    return new DynamicVariable(true, x)
  }
  return new DynamicVariable(false, path)
}

module.exports = {
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox
}

},{}],18:[function(require,module,exports){
var check = require('./check')
var isTypedArray = require('./is-typed-array')
var primTypes = require('./constants/primitives.json')

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_UNSIGNED_BYTE = 5121
var GL_UNSIGNED_SHORT = 5123
var GL_UNSIGNED_INT = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

module.exports = function wrapElementsState (gl, extensionState, bufferState) {
  var extensions = extensionState.extensions

  var elements = [ null ]

  function REGLElementBuffer () {
    this.buffer = null
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  function parseOptions (elements, options) {
    var result = {
      type: 'elements'
    }
    var ext32bit = extensions.oes_element_index_uint
    elements.primType = GL_TRIANGLES
    elements.vertCount = 0
    elements.type = 0

    var data = null

    // Check option type
    if (!options) {
      return result
    }
    if (typeof options === 'number') {
      result.length = options
    } else {
      check.type(options, 'object', 'argument to element buffer must be object')
      data = options.data || options
    }

    if (Array.isArray(data)) {
      if (options.length === 0) {
        data = null
      } else if (Array.isArray(data[0])) {
        var dim = data[0].length
        if (dim === 1) elements.primType = GL_POINTS
        if (dim === 2) elements.primType = GL_LINES
        if (dim === 3) elements.primType = GL_TRIANGLES
        var i
        var count = 0
        for (i = 0; i < data.length; ++i) {
          count += data[i].length
        }
        var flattened = ext32bit
          ? new Uint32Array(count)
          : new Uint16Array(count)
        var ptr = 0
        for (i = 0; i < data.length; ++i) {
          var x = data[i]
          for (var j = 0; j < x.length; ++j) {
            flattened[ptr++] = x[j]
          }
        }
        data = flattened
      } else if (ext32bit) {
        data = new Uint32Array(data)
      } else {
        data = new Uint16Array(data)
      }
    }

    if (isTypedArray(data)) {
      if ((data instanceof Uint8Array) ||
          (data instanceof Uint8ClampedArray)) {
        elements.type = GL_UNSIGNED_BYTE
      } else if (data instanceof Uint16Array) {
        elements.type = GL_UNSIGNED_SHORT
      } else if (data instanceof Uint32Array) {
        check(ext32bit, '32-bit element buffers not supported')
        elements.type = GL_UNSIGNED_INT
      } else {
        check.raise('invalid typed array for element buffer')
      }
      elements.vertCount = data.length
      result.data = data
    } else {
      check(!data, 'invalid element buffer data type')
    }

    if (typeof options === 'object') {
      if ('primitive' in options) {
        var primitive = options.primitive
        check.param(primitive, primTypes)
        elements.primType = primTypes[primitive]
      }

      if ('usage' in options) {
        result.usage = options.usage
      }

      if ('count' in options) {
        elements.vertCount = options.vertCount | 0
      }
    }

    return result
  }

  Object.assign(REGLElementBuffer.prototype, {
    bind: function () {
      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER, this.buffer._buffer.buffer)
    },

    destroy: function () {
      if (this.buffer) {
        this.buffer.destroy()
        this.buffer = null
      }
    }
  })

  function createElements (options) {
    var elements = new REGLElementBuffer()

    // Create buffer
    elements.buffer = bufferState.create(
      parseOptions(elements, options),
      GL_ELEMENT_ARRAY_BUFFER)

    function updateElements (options) {
      elements.buffer(parseOptions(elements, options))
      return updateElements
    }

    updateElements._reglType = 'elements'
    updateElements._elements = elements
    updateElements.destroy = function () { elements.destroy() }

    return updateElements
  }

  return {
    create: createElements,
    elements: elements,
    getElements: function (elements) {
      if (elements && elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    }
  }
}

},{"./check":4,"./constants/primitives.json":13,"./is-typed-array":21}],19:[function(require,module,exports){
module.exports = function createExtensionCache (gl) {
  var extensions = {}

  function refreshExtensions () {
    [
      'oes_texture_float',
      'oes_texture_float_linear',
      'oes_texture_half_float',
      'oes_texture_half_float_linear',
      'oes_standard_derivatives',
      'oes_element_index_uint',
      'oes_fbo_render_mipmap',

      'webgl_depth_texture',
      'webgl_draw_buffers',
      'webgl_color_buffer_float',

      'ext_texture_filter_anisotropic',
      'ext_frag_depth',
      'ext_blend_minmax',
      'ext_shader_texture_lod',
      'ext_color_buffer_half_float',
      'ext_srgb',

      'angle_instanced_arrays',

      'webgl_compressed_texture_s3tc',
      'webgl_compressed_texture_atc',
      'webgl_compressed_texture_pvrtc',
      'webgl_compressed_texture_etc1'
    ].forEach(function (ext) {
      try {
        extensions[ext] = gl.getExtension(ext)
      } catch (e) {}
    })
  }

  refreshExtensions()

  return {
    extensions: extensions,
    refresh: refreshExtensions
  }
}

},{}],20:[function(require,module,exports){
// Framebuffer object state management

module.exports = function wrapFBOState (
  gl,
  textureCache) {
  function createFBO (options) {
  }

  function clearCache () {
  }

  function refreshCache () {
  }

  return {
    create: createFBO,
    clear: clearCache,
    refresh: refreshCache,
    getFBO: function (wrapper) {
      return null
    }
  }
}

},{}],21:[function(require,module,exports){
var dtypes = require('./constants/arraytypes.json')
module.exports = function (x) {
  return Object.prototype.toString.call(x) in dtypes
}

},{"./constants/arraytypes.json":8}],22:[function(require,module,exports){
var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

module.exports = function (gl, extensions) {
  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions.extensions),

    // TODO compressed texture formats

    // TODO max aniso samples

    // point and line size ranges
    pointSize: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidth: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    viewport: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    combinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    cubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    renderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    textureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    textureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    attributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    vertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    vertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    varyingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    fragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION)
  }
}

},{}],23:[function(require,module,exports){
/* globals document, Image, XMLHttpRequest */

module.exports = loadTexture

function getExtension (url) {
  var parts = /\.(\w+)(\?.*)?$/.exec(url)
  if (parts && parts[1]) {
    return parts[1].toLowerCase()
  }
}

function isVideoExtension (url) {
  return [
    'avi',
    'asf',
    'gifv',
    'mov',
    'qt',
    'yuv',
    'mpg',
    'mpeg',
    'm2v',
    'mp4',
    'm4p',
    'm4v',
    'ogg',
    'ogv',
    'vob',
    'webm',
    'wmv'
  ].indexOf(url) >= 0
}

function isCompressedExtension (url) {
  return [
    // 'dds'
  ].indexOf(url) >= 0
}

function loadVideo (url) {
  var video = document.createElement('video')
  video.autoplay = true
  video.loop = true
  video.src = url
  return video
}

function loadCompressedTexture (url) {
  var xhr = new XMLHttpRequest()
  xhr.responseType = 'arraybuffer'
  xhr.open('GET', url, true)
  xhr.send()
  return xhr
}

function loadImage (url) {
  var image = new Image()
  image.src = url
  return image
}

// Currently this stuff only works in a DOM environment
function loadTexture (url) {
  if (typeof document !== 'undefined') {
    var ext = getExtension(url)
    if (isVideoExtension(ext)) {
      return loadVideo(url)
    }
    if (isCompressedExtension(ext)) {
      return loadCompressedTexture(url)
    }
    return loadImage(url)
  }
  return null
}

},{}],24:[function(require,module,exports){
/* globals requestAnimationFrame, cancelAnimationFrame */
if (typeof requestAnimationFrame === 'function' &&
    typeof cancelAnimationFrame === 'function') {
  module.exports = {
    next: function (x) { return requestAnimationFrame(x) },
    cancel: function (x) { return cancelAnimationFrame(x) }
  }
} else {
  module.exports = {
    next: function (cb) {
      setTimeout(cb, 30)
    },
    cancel: clearTimeout
  }
}

},{}],25:[function(require,module,exports){
var check = require('./check')
var isTypedArray = require('./is-typed-array')

var GL_RGBA = 6408
var GL_UNSIGNED_BYTE = 5121
var GL_PACK_ALIGNMENT = 0x0D05

module.exports = function wrapReadPixels (gl, glState) {
  function readPixels (input) {
    var options = input || {}
    if (isTypedArray(input)) {
      options = {
        data: options
      }
    } else if (arguments.length === 2) {
      options = {
        width: arguments[0] | 0,
        height: arguments[1] | 0
      }
    } else if (typeof input !== 'object') {
      options = {}
    }

    // Update WebGL state
    glState.poll()

    // Read viewport state
    var viewportState = glState.viewport
    var x = options.x || 0
    var y = options.y || 0
    var width = options.width || viewportState.width
    var height = options.height || viewportState.height

    // Compute size
    var size = width * height * 4

    // Allocate data
    var data = options.data || new Uint8Array(size)

    // Type check
    check.isTypedArray(data)
    check(data.byteLength >= size, 'data buffer too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data)

    return data
  }

  return readPixels
}

},{"./check":4,"./is-typed-array":21}],26:[function(require,module,exports){
var check = require('./check')

var DEFAULT_FRAG_SHADER = 'void main(){gl_FragColor=vec4(0,0,0,0);}'
var DEFAULT_VERT_SHADER = 'void main(){gl_Position=vec4(0,0,0,0);}'

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

function ActiveInfo (name, location, info) {
  this.name = name
  this.location = location
  this.info = info
}

module.exports = function wrapShaderState (
  gl,
  extensions,
  attributeState,
  uniformState,
  compileShaderDraw) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var shaders = {}

  var fragShaders = [DEFAULT_FRAG_SHADER]
  var vertShaders = [DEFAULT_VERT_SHADER]

  function getShader (type, source) {
    var cache = shaders[type]
    var shader = cache[source]

    if (!shader) {
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var errLog = gl.getShaderInfoLog(shader)
        check.raise('Error compiling shader:\n' + errLog)
      }
      cache[source] = shader
    }

    return shader
  }

  function refreshShaders () {
    shaders[GL_FRAGMENT_SHADER] = {}
    shaders[GL_VERTEX_SHADER] = {}
  }

  function clearShaders () {
    Object.keys(shaders).forEach(function (type) {
      Object.keys(shaders[type]).forEach(function (shader) {
        gl.deleteShader(shaders[type][shader])
      })
    })
    shaders[GL_FRAGMENT_SHADER] = {}
    shaders[GL_VERTEX_SHADER] = {}
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  function REGLProgram (fragSrc, vertSrc) {
    this.fragSrc = fragSrc
    this.vertSrc = vertSrc
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.draw = function () {}
    this.batchCache = {}
  }

  Object.assign(REGLProgram.prototype, {
    link: function () {
      var i, info

      // -------------------------------
      // compile & link
      // -------------------------------
      var fragShader = getShader(gl.FRAGMENT_SHADER, this.fragSrc)
      var vertShader = getShader(gl.VERTEX_SHADER, this.vertSrc)

      var program = this.program = gl.createProgram()
      gl.attachShader(program, fragShader)
      gl.attachShader(program, vertShader)
      gl.linkProgram(program)
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var errLog = gl.getProgramInfoLog(program)
        check.raise('Error linking program:\n' + errLog)
      }

      // -------------------------------
      // grab uniforms
      // -------------------------------
      var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS)
      var uniforms = this.uniforms = []
      for (i = 0; i < numUniforms; ++i) {
        info = gl.getActiveUniform(program, i)
        if (info) {
          if (info.size > 1) {
            for (var j = 0; j < info.size; ++j) {
              var name = info.name.replace('[0]', '[' + j + ']')
              uniforms.push(new ActiveInfo(
                name,
                gl.getUniformLocation(program, name),
                info))
              uniformState.def(name)
            }
          } else {
            uniforms.push(new ActiveInfo(
              info.name,
              gl.getUniformLocation(program, info.name),
              info))
            uniformState.def(info.name)
          }
        }
      }

      // -------------------------------
      // grab attributes
      // -------------------------------
      var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES)
      var attributes = this.attributes = []
      for (i = 0; i < numAttributes; ++i) {
        info = gl.getActiveAttrib(program, i)
        if (info) {
          attributes.push(new ActiveInfo(
            info.name,
            gl.getAttribLocation(program, info.name),
            info))
          attributeState.def(info.name)
        }
      }

      // -------------------------------
      // clear cached rendering methods
      // -------------------------------
      this.draw = compileShaderDraw(this)
      this.batchCache = {}
    },

    destroy: function () {
      gl.deleteProgram(this.program)
    }
  })

  function getProgram (vertSource, fragSource) {
    var cache = programCache[fragSource]
    if (!cache) {
      cache = programCache[vertSource] = {}
    }
    var program = cache[vertSource]
    if (!program) {
      program = new REGLProgram(fragSource, vertSource)
      program.link()
      cache[vertSource] = program
      programList.push(program)
    }
    return program
  }

  function clearPrograms () {
    programList.forEach(function (program) {
      program.destroy()
    })
    programList.length = 0
    programCache = {}
  }

  function refreshPrograms () {
    programList.forEach(function (program) {
      program.link()
    })
  }

  // ===================================================
  // program state
  // ===================================================
  var programState = [null]

  // ===================================================
  // context management
  // ===================================================
  function clear () {
    clearShaders()
    clearPrograms()
  }

  function refresh () {
    refreshShaders()
    refreshPrograms()
  }

  // We call clear once to initialize all data structures
  clear()

  return {
    create: getProgram,
    clear: clear,
    refresh: refresh,
    programs: programState,
    fragShaders: fragShaders,
    vertShaders: vertShaders
  }
}

},{"./check":4}],27:[function(require,module,exports){
// A stack for managing the state of a scalar/vector parameter

module.exports = function createStack (init, onChange) {
  var n = init.length
  var stack = init.slice()
  var dirty = true

  function poll () {
    var ptr = stack.length - n
    if (dirty) {
      switch (n) {
        case 1:
          onChange(stack[ptr])
          break
        case 2:
          onChange(stack[ptr], stack[ptr + 1])
          break
        case 3:
          onChange(stack[ptr], stack[ptr + 1], stack[ptr + 2])
          break
        case 4:
          onChange(stack[ptr], stack[ptr + 1], stack[ptr + 2], stack[ptr + 3])
          break
        case 5:
          onChange(stack[ptr], stack[ptr + 1], stack[ptr + 2], stack[ptr + 3], stack[ptr + 4])
          break
        case 6:
          onChange(stack[ptr], stack[ptr + 1], stack[ptr + 2], stack[ptr + 3], stack[ptr + 4], stack[ptr + 5])
          break
        default:
          onChange.apply(null, stack.slice(ptr, stack.length))
      }
      dirty = false
    }
  }

  return {
    push: function () {
      for (var i = 0; i < n; ++i) {
        stack.push(arguments[i])
      }
      dirty = true
    },

    pop: function () {
      stack.length -= n
      dirty = true
    },

    poll: poll,

    setDirty: function () {
      dirty = true
    }
  }
}

},{}],28:[function(require,module,exports){
var createStack = require('./stack')
var createEnvironment = require('./codegen')

// WebGL constants
var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0
var GL_FUNC_ADD = 0x8006
var GL_ZERO = 0
var GL_ONE = 1
var GL_FRONT = 1028
var GL_BACK = 1029
var GL_LESS = 513
var GL_CCW = 2305
var GL_ALWAYS = 519
var GL_KEEP = 7680

module.exports = function wrapContextState (gl, shaderState) {
  function capStack (cap, dflt) {
    var result = createStack([!!dflt], function (flag) {
      if (flag) {
        gl.enable(cap)
      } else {
        gl.disable(cap)
      }
    })
    result.flag = cap
    return result
  }

  var viewportState = {
    width: 0,
    height: 0
  }

  // Caps, flags and other random WebGL context state
  var contextState = {
    // Dithering
    'dither': capStack(GL_DITHER),

    // Blending
    'blend.enable': capStack(GL_BLEND),
    'blend.color': createStack([0, 0, 0, 0], function (r, g, b, a) {
      gl.blendColor(r, g, b, a)
    }),
    'blend.equation': createStack([GL_FUNC_ADD, GL_FUNC_ADD], function (rgb, a) {
      gl.blendEquationSeparate(rgb, a)
    }),
    'blend.func': createStack([
      GL_ONE, GL_ZERO, GL_ONE, GL_ZERO
    ], function (srcRGB, dstRGB, srcAlpha, dstAlpha) {
      gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha)
    }),

    // Depth
    'depth.enable': capStack(GL_DEPTH_TEST, true),
    'depth.func': createStack([GL_LESS], function (func) {
      gl.depthFunc(func)
    }),
    'depth.range': createStack([0, 1], function (near, far) {
      gl.depthRange(near, far)
    }),
    'depth.mask': createStack([true], function (m) {
      gl.depthMask(m)
    }),

    // Face culling
    'cull.enable': capStack(GL_CULL_FACE),
    'cull.face': createStack([GL_BACK], function (mode) {
      gl.cullFace(mode)
    }),

    // Front face orientation
    'frontFace': createStack([GL_CCW], function (mode) {
      gl.frontFace(mode)
    }),

    // Write masks
    'colorMask': createStack([true, true, true, true], function (r, g, b, a) {
      gl.colorMask(r, g, b, a)
    }),

    // Line width
    'lineWidth': createStack([1], function (w) {
      gl.lineWidth(w)
    }),

    // Polygon offset
    'polygonOffset.enable': capStack(GL_POLYGON_OFFSET_FILL),
    'polygonOffset.offset': createStack([0, 0], function (factor, units) {
      gl.polygonOffset(factor, units)
    }),

    // Sample coverage
    'sample.alpha': capStack(GL_SAMPLE_ALPHA_TO_COVERAGE),
    'sample.enable': capStack(GL_SAMPLE_COVERAGE),
    'sample.coverage': createStack([1, false], function (value, invert) {
      gl.sampleCoverage(value, invert)
    }),

    // Stencil
    'stencil.enable': capStack(GL_STENCIL_TEST),
    'stencil.mask': createStack([-1], function (mask) {
      gl.stencilMask(mask)
    }),
    'stencil.func': createStack([
      GL_ALWAYS, 0, -1
    ], function (func, ref, mask) {
      gl.stencilFunc(func, ref, mask)
    }),
    'stencil.opFront': createStack([
      GL_KEEP, GL_KEEP, GL_KEEP
    ], function (fail, zfail, pass) {
      gl.stencilOpSeparate(GL_FRONT, fail, zfail, pass)
    }),
    'stencil.opBack': createStack([
      GL_KEEP, GL_KEEP, GL_KEEP
    ], function (fail, zfail, pass) {
      gl.stencilOpSeparate(GL_BACK, fail, zfail, pass)
    }),

    // Scissor
    'scissor.enable': capStack(GL_SCISSOR_TEST),
    'scissor.box': createStack([0, 0, -1, -1], function (x, y, w, h) {
      var w_ = w
      if (w < 0) {
        w_ = gl.drawingBufferWidth - x
      }
      var h_ = h
      if (h < 0) {
        h_ = gl.drawingBufferHeight - y
      }
      gl.scissor(x, y, w_, h_)
    }),

    // Viewport
    'viewport': createStack([0, 0, -1, -1], function (x, y, w, h) {
      var w_ = w
      if (w < 0) {
        w_ = gl.drawingBufferWidth - x
      }
      var h_ = h
      if (h < 0) {
        h_ = gl.drawingBufferHeight - y
      }
      gl.viewport(x, y, w_, h_)
      viewportState.width = w_
      viewportState.height = h_
    })
  }

  var env = createEnvironment()
  var poll = env.proc('poll')
  var refresh = env.proc('refresh')
  Object.keys(contextState).forEach(function (prop) {
    var STACK = env.link(contextState[prop])
    poll(STACK, '.poll();')
    refresh(STACK, '.setDirty();')
  })
  var procs = env.compile()

  return {
    contextState: contextState,
    viewport: viewportState,
    poll: procs.poll,
    refresh: procs.refresh,

    notifyViewportChanged: function () {
      contextState.viewport.setDirty()
      contextState['scissor.box'].setDirty()
    }
  }
}

},{"./codegen":6,"./stack":27}],29:[function(require,module,exports){
var check = require('./check')
var isTypedArray = require('./is-typed-array')
var loadTexture = require('./load-texture')

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515

var GL_RGBA = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE = 0x1401
var GL_UNSIGNED_SHORT = 0x1403
var GL_UNSIGNED_INT = 0x1405
var GL_FLOAT = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0 = 0x84C0

var wrapModes = {
  'repeat': GL_REPEAT,
  'clamp': GL_CLAMP_TO_EDGE,
  'mirror': GL_MIRRORED_REPEAT
}

var magFilters = {
  'nearest': GL_NEAREST,
  'linear': GL_LINEAR
}

var minFilters = Object.assign({
  'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST,
  'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST,
  'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR,
  'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR,
  'mipmap': GL_LINEAR_MIPMAP_LINEAR
}, magFilters)

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isNDArrayLike (obj) {
  return (
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }

  var width = arr.length
  if (width === 0 || !Array.isArray(arr[0])) {
    return false
  }

  var height = arr[0].length
  for (var i = 1; i < width; ++i) {
    if (!Array.isArray(arr[i]) || arr[i].length !== height) {
      return false
    }
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === '[object HTMLCanvasElement]'
}

function isContext2D (object) {
  return classString(object) === '[object CanvasRenderingContext2D]'
}

function isImageElement (object) {
  return classString(object) === '[object HTMLImageElement]'
}

function isVideoElement (object) {
  return classString(object) === '[object HTMLVideoElement]'
}

function isPendingXHR (object) {
  return classString(object) === '[object XMLHttpRequest]'
}

function isPixelData (object) {
  return (
    typeof object === 'string' ||
    isTypedArray(object) ||
    isNumericArray(object) ||
    isNDArrayLike(object) ||
    isCanvasElement(object) ||
    isContext2D(object) ||
    isImageElement(object) ||
    isVideoElement(object) ||
    isRectArray(object))
}

// This converts an array of numbers into 16 bit half precision floats
function convertToHalfFloat (array) {
  var floats = new Float32Array(array)
  var uints = new Uint32Array(floats.buffer)
  var ushorts = new Uint16Array(array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      var x = uints[i]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

// Transpose an array of pixels
function transposePixels (data, nx, ny, nc, sx, sy, sc, off) {
  var result = new data.constructor(nx * ny * nc)
  var ptr = 0
  for (var i = 0; i < ny; ++i) {
    for (var j = 0; j < nx; ++j) {
      for (var k = 0; k < nc; ++k) {
        result[ptr++] = data[sy * i + sx * j + sc * k + off]
      }
    }
  }
  return result
}

module.exports = function createTextureSet (gl, extensionState, limits, reglPoll) {
  var extensions = extensionState.extensions

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float = GL_FLOAT
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['half float'] = GL_HALF_FLOAT_OES
  }

  if (extensions.webgl_depth_texture) {
    Object.assign(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    Object.assign(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT,
      'uint32': GL_UNSIGNED_INT,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    Object.assign(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    Object.assign(compressedTextureFormats, {
      'rgb arc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    Object.assign(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  Object.assign(textureFormats, compressedTextureFormats)

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  var compressedFormatEnums = Object.keys(compressedTextureFormats).map(
    function (key) {
      return compressedTextureFormats[key]
    })

  function parsePixelStorage (options, defaults, result) {
    if (defaults) {
      result.flipY = defaults.flipY
      result.premultiplyAlpha = defaults.premultiplyAlpha
      result.unpackAlignment = defaults.unpackAlignment
      result.colorSpace = defaults.colorSpace
    }

    if ('premultiplyAlpha' in options) {
      check.type(options.premultiplyAlpha, 'boolean', 'invalid premultiplyAlpha')
      result.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check.type(options.flipY, 'boolean', 'invalid texture flip')
      result.flipY = options.flipY
    }

    if ('alignment' in options) {
      check.oneOf(
        options.alignment,
        [1, 2, 4, 8],
        'invalid texture unpack alignment')
      result.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check.parameter(options.colorSpace, colorSpace, 'invalid colorSpace')
      result.colorSpace = colorSpace[options.colorSpace]
    }

    return result
  }

  function parseTexParams (options, defaults) {
    var result = {
      width: 0,
      height: 0,
      channels: 0,
      format: 0,
      type: 0,
      wrapS: GL_CLAMP_TO_EDGE,
      wrapT: GL_CLAMP_TO_EDGE,
      minFilter: GL_NEAREST,
      magFilter: GL_NEAREST,
      genMipmaps: false,
      anisoSamples: 1,
      flipY: false,
      premultiplyAlpha: false,
      unpackAlignment: 1,
      colorSpace: GL_BROWSER_DEFAULT_WEBGL,
      poll: false,
      needsListeners: false
    }

    if (defaults) {
      Object.assign(result, defaults)
      parsePixelStorage(options, defaults, result)
    } else {
      parsePixelStorage(options, null, result)
    }

    if ('shape' in options) {
      check(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      result.width = options.shape[0] | 0
      result.height = options.shape[1] | 0
      if (options.shape.length === 3) {
        result.channels = options.shape[2] | 0
      }
    } else {
      if ('radius' in options) {
        result.width = result.height = options.radius | 0
      }
      if ('width' in options) {
        result.width = options.width | 0
      }
      if ('height' in options) {
        result.height = options.height | 0
      }
      if ('channels' in options) {
        result.channels = options.channels | 0
      }
    }

    if ('min' in options) {
      check.parameter(options.min, minFilters)
      result.minFilter = minFilters[options.min]
    }

    if ('mag' in options) {
      check.parameter(options.mag, magFilters)
      result.magFilter = magFilters[options.mag]
    }

    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check.parameter(wrap, wrapModes)
        result.wrapS = result.wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check.parameter(wrap[0], wrapModes)
        check.parameter(wrap[1], wrapModes)
        result.wrapS = wrapModes[wrap[0]]
        result.wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        check.parameter(options.wrapS, wrapModes)
        result.wrapS = wrapModes[options.wrapS]
      }
      if ('wrapT' in options) {
        check.parameter(options.wrapT, wrapModes)
        result.wrapT = wrapModes[options.wrapT]
      }
    }

    if ('aniso' in options) {
      check.type(
        options.aniso,
        'number',
        'number of aniso samples must be a number')
      result.aniso = +options.aniso
    }

    if ('mipmap' in options) {
      result.genMipmaps = !!options.mipmap
    } else if ([
      GL_NEAREST_MIPMAP_NEAREST,
      GL_NEAREST_MIPMAP_LINEAR,
      GL_LINEAR_MIPMAP_NEAREST,
      GL_LINEAR_MIPMAP_LINEAR
    ].indexOf(result.minFilter) >= 0) {
      result.genMipmaps = true
    }

    if ('format' in options) {
      check.parameter(options.format, textureFormats, 'invalid texture format')
      result.format = textureFormats[options.format]
      if (options.format in textureTypes) {
        result.type = textureTypes[options.format]
      }
    }

    if ('type' in options) {
      check.parameter(options.type, textureTypes, 'invalid texture type')
      result.type = textureTypes[options.type]
    }

    return result
  }

  function parseMipImage (image, texParams) {
    var defaults = texParams

    if (image) {
      if (Array.isArray(image.mipmap)) {
        defaults = parseTexParams(image, texParams)
        return {
          mipmap: image.mipmap.map(function (level, i) {
            return parsePixelData(
              level,
              texParams.width >> i,
              texParams.height >> i,
              i)
          })
        }
      } else {
        return {
          pixels: parsePixelData(image, texParams.width, texParams.height, 0)
        }
      }
    } else {
      return {}
    }

    function parsePixelData (pixelData, width, height, miplevel) {
      var result = parsePixelStorage(pixelData, defaults, {
        width: 0,
        height: 0,
        channels: defaults.channels,
        format: defaults.format,
        internalformat: 0,
        type: defaults.type,
        copy: false,
        x: 0,
        y: 0,
        image: null,
        canvas: null,
        video: null,
        data: null,
        array: null,
        needsConvert: false,
        needsTranspose: false,
        needsListeners: false,
        strideX: 0,
        strideY: 0,
        strideC: 0,
        offset: 0,
        flipY: defaults.flipY,
        premultiplyAlpha: defaults.premultiplyAlpha,
        unpackAlignment: defaults.unpackAlignment,
        colorSpace: defaults.colorSpace,
        poll: false
      })

      if (!pixelData) {
        return result
      }

      check.type(pixelData, 'object', 'invalid pixel data')

      function setObjectProps () {
        if ('shape' in pixelData) {
          var shape = pixelData.shape
          check(
            Array.isArray(shape) && shape.length >= 2,
            'image shape must be an array')
          result.width = shape[0] | 0
          result.height = shape[1] | 0
          if (shape.length === 3) {
            result.channels = shape[2] | 0
          }
        } else {
          if ('width' in pixelData) {
            result.width = pixelData.width
          } else {
            result.width = width
          }
          if ('height' in pixelData) {
            result.height = pixelData.height
          } else {
            result.height = height
          }
          if ('channels' in pixelData) {
            result.channels = pixelData.channels
          }
        }

        if ('stride' in pixelData) {
          var stride = pixelData.stride
          check(Array.isArray(stride) && stride.length >= 2,
            'invalid stride vector')
          result.strideX = stride[0]
          result.strideY = stride[1]
          if (stride.length === 3) {
            result.strideC = stride[2]
          } else {
            result.strideC = 1
          }
          result.needsTranspose = true
        } else {
          result.strideC = 1
          result.strideX = result.strideC * result.channels
          result.strideY = result.strideX * result.width
        }

        if ('offset' in pixelData) {
          result.offset = pixelData.offset | 0
          result.needsTranspose = true
        }

        if ('format' in pixelData) {
          var format = pixelData.format
          check.parameter(format, textureFormats)
          result.format = textureFormats[format]
          if (format in textureTypes) {
            result.type = textureTypes[format]
          }
        }

        if ('type' in pixelData) {
          var type = pixelData.type
          check.parameter(type, textureTypes)
          result.type = textureTypes[type]
        } else if (result.data instanceof Float32Array) {
          result.type = GL_FLOAT
        }
      }

      function setDefaultProps () {
        result.type = GL_UNSIGNED_BYTE
        result.format = GL_RGBA
        result.channels = 4
      }

      var data = pixelData
      if (isPixelData(pixelData.data)) {
        data = pixelData.data
      }

      if (typeof data === 'string') {
        data = loadTexture(data)
      }

      if (isTypedArray(data)) {
        result.data = data
        setObjectProps()
      } else if (isNumericArray(data)) {
        result.array = data
        result.needsConvert = true
        setObjectProps()
      } else if (isNDArrayLike(data)) {
        if (Array.isArray(data.data)) {
          result.array = data.data
          result.needsConvert = true
        } else {
          result.data = data
        }

        setObjectProps()

        var shape = data.shape
        result.width = shape[0]
        result.height = shape[1]
        if (shape.length === 3) {
          result.channels = shape[2]
        } else {
          result.channels = 1
        }

        var stride = data.stride
        result.strideX = data.stride[0]
        result.strideY = data.stride[1]
        if (stride.length === 3) {
          result.strideC = data.stride[2]
        } else {
          result.strideC = 1
        }

        result.offset = data.offset

        result.needsTranspose = true
      } else if (isCanvasElement(data) || isContext2D(data)) {
        if (isCanvasElement(data)) {
          result.canvas = data
        } else {
          result.canvas = data.canvas
        }
        result.width = result.width || result.canvas.width
        result.height = result.height || result.canvas.height
        setDefaultProps()
      } else if (isImageElement(data)) {
        result.image = data
        result.width = result.width || data.naturalWidth
        result.height = result.height || data.naturalHeight
        if (!image.complete) {
          result.needsListeners = true
        }
        setDefaultProps()
        if ('poll' in pixelData) {
          result.poll = !!pixelData.poll
        }
      } else if (isVideoElement(data)) {
        result.video = data
        result.width = result.width || data.width
        result.height = result.height || data.height
        result.poll = true
        setDefaultProps()
        if ('poll' in pixelData) {
          result.poll = !!pixelData.poll
        }
      } else if (isPendingXHR(data)) {
        // TODO: handle pending xhr request
      } else if (isRectArray(data)) {
        var w = data.length
        var h = data[0].length
        var c = 1
        var pixels, i, j, k, p
        if (Array.isArray(data[0][0])) {
          c = data[0][0].length
          check(c >= 0 && c <= 4, 'invalid number of channels for image data')
          pixels = Array(w * h * c)
          p = 0
          for (i = 0; i < w; ++i) {
            for (j = 0; j < h; ++j) {
              for (k = 0; k < c; ++k) {
                pixels[p++] = data[i][j][k]
              }
            }
          }
        } else {
          pixels = Array(w * h)
          p = 0
          for (i = 0; i < w; ++i) {
            for (j = 0; j < h; ++j) {
              pixels[p++] = data[i][j]
            }
          }
        }
        result.width = w
        result.height = h
        result.channels = c
        result.array = pixels
        result.needsConvert = true
      } else if (pixelData.copy) {
        result.copy = true
        result.x = pixelData.x | 0
        result.y = pixelData.y | 0
        result.width = pixelData.width | 0
        result.height = pixelData.height | 0
        setDefaultProps()
      }

      // Fix up missing type info for typed arrays
      if (!result.type && result.data) {
        if (result.format === GL_DEPTH_COMPONENT) {
          if (result.data instanceof Uint16Array) {
            result.type = GL_UNSIGNED_SHORT
          } else if (result.data instanceof Uint32Array) {
            result.type = GL_UNSIGNED_INT
          }
        } else if (result.data instanceof Float32Array) {
          result.type = GL_FLOAT
        }
      }

      // reconcile with texParams
      function reconcile (param) {
        if (result[param]) {
          texParams[param] = texParams[param] || result[param]
          check(result[param] === texParams[param], 'incompatible image param: ' + param)
        } else {
          result[param] = texParams[param]
        }
      }
      reconcile('type')
      reconcile('format')
      reconcile('channels')

      texParams.poll = texParams.poll || result.poll
      texParams.needsListeners = texParams.needsListeners || result.needsListeners
      texParams.width = texParams.width || (result.width << miplevel)
      texParams.height = texParams.height || (result.height << miplevel)

      return result
    }
  }

  function fillMissingTexParams (params) {
    // Infer default format
    if (!params.format) {
      params.channels = params.channels || 4
      switch (params.channels) {
        case 1:
          params.format = GL_LUMINANCE
          break
        case 2:
          params.format = GL_LUMINANCE_ALPHA
          break
        case 3:
          params.format = GL_RGB
          break
        default:
          params.format = GL_RGBA
          break
      }
    }

    var format = params.format
    if (format === GL_DEPTH_COMPONENT || format === GL_DEPTH_STENCIL) {
      check(
        extensions.webgl_depth_texture,
        'depth/stencil texture not supported')
      if (format === GL_DEPTH_COMPONENT) {
        check(
          params.type === GL_UNSIGNED_SHORT || GL_UNSIGNED_INT,
          'depth texture type must be uint16 or uint32')
      }
      if (format === GL_DEPTH_STENCIL) {
        check(
          params.type === GL_UNSIGNED_INT_24_8_WEBGL,
          'depth stencil texture format must match type')
      }
    }

    // Save format to internal format
    params.internalformat = format

    // Set color format
    params.format = colorFormats[format]
    if (!params.channels) {
      switch (params.format) {
        case GL_LUMINANCE:
        case GL_ALPHA:
        case GL_DEPTH_COMPONENT:
          params.channels = 1
          break

        case GL_DEPTH_STENCIL:
        case GL_LUMINANCE_ALPHA:
          params.channels = 2
          break

        case GL_RGB:
          params.channels = 3
          break

        default:
          params.channels = 4
      }
    }

    // Check that texture type is supported
    params.type = params.type || GL_UNSIGNED_BYTE
    if (params.type === GL_FLOAT) {
      check(
        extensions.oes_texture_float,
        'float texture not supported')
    } else if (params.type === GL_HALF_FLOAT_OES) {
      check(
        extensions.oes_texture_half_float,
        'half float texture not supported')
    }

    // Check float_linear and half_float_linear extensions
    if ((params.type === GL_FLOAT && !extensions.oes_texture_float_linear) ||
        (params.type === GL_HALF_FLOAT_OES &&
          !extensions.oes_texture_half_float_linear)) {
      params.magFilter = GL_NEAREST
      if (params.minFilter === GL_LINEAR) {
        params.minFilter = GL_NEAREST
      } else if (params.minFilter === GL_LINEAR_MIPMAP_LINEAR ||
                 params.minFilter === GL_LINEAR_MIPMAP_NEAREST ||
                 params.minFilter === GL_NEAREST_MIPMAP_LINEAR) {
        params.minFilter = GL_NEAREST_MIPMAP_NEAREST
      }
    }

    // Set default values for width and height
    params.width = params.width || 0
    params.height = params.height || 0

    // Set compressed flag
    params.compressed =
      compressedFormatEnums.indexOf(params.internalformat) >= 0

    if (params.genMipmaps) {
      check(params.width === params.height && isPow2(params.width),
        'must be a square power of 2 to support mipmaps')
      check(!params.compressed,
        'mipmap generation not supported for compressed textures')
    }
  }

  function fillMissingImageParams (image, texParams) {
    if (image.mipmap) {
      for (var i = 0; i < image.mipmap.length; ++i) {
        fillMissingPixelParams(
          image.mipmap[i],
          texParams.width >>> i,
          texParams.height >>> i)
      }
    } else if (image.pixels) {
      fillMissingPixelParams(image.pixels, texParams.width, texParams.height)
    }

    function fillMissingPixelParams (pixels, w, h) {
      function checkProp (prop, expected) {
        if (pixels[prop]) {
          check(pixels[prop] === expected, 'invalid ' + prop)
        }
        pixels[prop] = expected
      }

      checkProp('width', w)
      checkProp('height', h)
      checkProp('channels', texParams.channels)
      checkProp('format', texParams.internalformat)
      checkProp('type', texParams.type)

      pixels.format = texParams.format
      pixels.internalformat = texParams.internalformat

      if (pixels.needsConvert) {
        switch (pixels.type) {
          case GL_UNSIGNED_BYTE:
            pixels.data = new Uint8Array(pixels.array)
            break
          case GL_UNSIGNED_SHORT:
            pixels.data = new Uint16Array(pixels.array)
            break
          case GL_UNSIGNED_INT:
            pixels.data = new Uint32Array(pixels.array)
            break
          case GL_FLOAT:
            pixels.data = new Float32Array(pixels.array)
            break
          case GL_HALF_FLOAT_OES:
            pixels.data = convertToHalfFloat(pixels.array)
            break

          case GL_UNSIGNED_SHORT_5_6_5:
          case GL_UNSIGNED_SHORT_5_5_5_1:
          case GL_UNSIGNED_SHORT_4_4_4_4:
          case GL_UNSIGNED_INT_24_8_WEBGL:
            check.raise('unsupported format for automatic conversion')
            break

          default:
            check.raise('unsupported type conversion')
        }
        pixels.needsConvert = false
        pixels.array = null
      }

      if (pixels.needsTranspose) {
        pixels.data = transposePixels(
          pixels.data,
          pixels.width,
          pixels.height,
          pixels.channels,
          pixels.strideX,
          pixels.strideY,
          pixels.strideC,
          pixels.offset)
      }

      if (pixels.data) {
        switch (pixels.type) {
          case GL_UNSIGNED_BYTE:
            check(pixels.data instanceof Uint8Array ||
                  pixels.data instanceof Uint8ClampedArray,
                  'incompatible pixel type')
            break
          case GL_UNSIGNED_SHORT_5_6_5:
          case GL_UNSIGNED_SHORT_5_5_5_1:
          case GL_UNSIGNED_SHORT_4_4_4_4:
          case GL_UNSIGNED_SHORT:
          case GL_HALF_FLOAT_OES:
            check(pixels.data instanceof Uint16Array,
                  'incompatible pixel type')
            break
          case GL_UNSIGNED_INT:
            check(pixels.data instanceof Uint32Array,
                  'incompatible pixel type')
            break

          case GL_FLOAT:
            check(pixels.data instanceof Float32Array,
                  'incompatible pixel type')
            break

          default:
            check.raise('bad or missing pixel type')
        }
      }
    }
  }

  function parseTexture2D (object) {
    // first pass: initially parse all data
    var params = parseTexParams(object)
    var image = parseMipImage(object, params)

    // second pass: fill in defaults based on inferred parameters
    fillMissingTexParams(params)
    fillMissingImageParams(image, params)

    return {
      params: params,
      image: image
    }
  }

  function parseCube (object) {
    var faces
    if (Array.isArray(object)) {
      faces = object
    } else if ('faces' in object) {
      faces = object.faces
    } else {
      faces = [{}, {}, {}, {}, {}, {}]
    }

    check(Array.isArray(faces) && faces.length === 6,
      'invalid faces for cubemap')

    var params = parseTexParams(object)
    var parsedFaces = faces.map(function (face) {
      return parseMipImage(face, params)
    })

    fillMissingTexParams(params)
    for (var i = 0; i < 6; ++i) {
      fillMissingImageParams(parsedFaces[i], params)
    }

    return {
      params: params,
      faces: parsedFaces
    }
  }

  var activeTexture = 0
  var textureCount = 0
  var textureSet = {}
  var pollSet = []
  var numTexUnits = limits.textureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target, texture) {
    this.id = textureCount++
    this.target = target
    this.texture = texture

    this.pollId = -1

    this.unit = -1
    this.bindCount = 0

    // cancels all pending callbacks
    this.cancelPending = null

    // parsed user inputs
    this.data = null
  }

  function setTexPixels (target, image, lod) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, image.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, image.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, image.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, image.unpackAlignment)

    var element = image.image || image.video || image.canvas
    var internalformat = image.internalformat
    var format = image.format
    var type = image.type
    var width = image.width
    var height = image.height
    if (isCanvasElement(element) ||
      (isImageElement(element) && element.complete) ||
      (isVideoElement(element) && element.readyState > 2)) {
      gl.texImage2D(
        target,
        lod,
        format,
        format,
        type,
        element)
    } else if (image.compressed) {
      gl.compressedTexImage2D(
        target,
        lod,
        internalformat,
        width,
        height,
        0,
        image.data)
    } else if (image.copy) {
      reglPoll()
      gl.copyTexImage2D(
        target,
        lod,
        format,
        image.x,
        image.y,
        width,
        height,
        0)
    } else if (image.data) {
      gl.texImage2D(
        target,
        lod,
        format,
        width,
        height,
        0,
        format,
        type,
        image.data)
    } else {
      gl.texImage2D(
        target,
        lod,
        format,
        width || 1,
        height || 1,
        0,
        format,
        type,
        null)
    }
  }

  function setTexImage (target, image) {
    var mipmap = image.mipmap
    if (Array.isArray(mipmap)) {
      for (var i = 0; i < mipmap.length; ++i) {
        setTexPixels(target, mipmap[i], i)
      }
    } else {
      setTexPixels(target, image.pixels, 0)
    }
  }

  function clearPoll (texture) {
    var id = texture.pollId
    if (id >= 0) {
      var other = pollSet[id] = pollSet[pollSet.length - 1]
      other.id = id
      pollSet.pop()
      texture.pollId = -1
    }
  }

  Object.assign(REGLTexture.prototype, {

    bind: function () {
      this.bindCount += 1
      var unit = this.unit
      if (unit < 0) {
        // FIXME: should we use an LRU to allocate textures here?
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (!other || other.bindCount <= 0) {
            if (other) {
              other.unit = -1
            }
            textureUnits[i] = this
            unit = i
            break
          }
        }
        this.unit = unit
        gl.activeTexture(GL_TEXTURE0 + unit)
        gl.bindTexture(this.target, this.texture)
        activeTexture = unit
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    refresh: function () {
      var target = this.target
      var unit = this.unit
      if (unit >= 0) {
        gl.activeTexture(GL_TEXTURE0 + unit)
        activeTexture = unit
      } else {
        gl.bindTexture(target, this.texture)
      }

      var data = this.data

      if (target === GL_TEXTURE_2D) {
        setTexImage(GL_TEXTURE_2D, data.image)
      } else {
        for (var i = 0; i < 6; ++i) {
          setTexImage(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, data.faces[i])
        }
      }

      // Set tex params
      var params = data.params

      // Generate mipmaps
      if (params.genMipmaps) {
        gl.generateMipmap(target)
      }

      gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, params.minFilter)
      gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, params.magFilter)
      gl.texParameteri(target, GL_TEXTURE_WRAP_S, params.wrapS)
      gl.texParameteri(target, GL_TEXTURE_WRAP_T, params.wrapT)
      if (extensions.ext_texture_filter_anisotropic) {
        gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, params.anisoSamples)
      }

      // Restore binding state
      if (unit < 0) {
        var active = textureUnits[activeTexture]
        if (active) {
          // restore binding state
          gl.bindTexture(active.target, active.texture)
        } else {
          // otherwise become new active
          this.unit = activeTexture
        }
      }
    },

    destroy: function () {
      check(this.texture, 'must not double free texture')
      if (this.unit >= 0) {
        gl.activeTexture(GL_TEXTURE0 + this.unit)
        activeTexture = this.unit
        gl.bindTexture(this.target, null)
        textureUnits[this.unit] = null
      }
      if (this.cancelPending) {
        this.cancelPending()
        this.cancelPending = null
      }
      clearPoll(this)
      gl.deleteTexture(this.texture)
      this.texture = null
      this.unit = -1
      this.bindCount = 0
      delete textureSet[this.id]
    }
  })

  function hookListeners (texture) {
    var data = texture.data
    var images = data.faces || [ data.image ]
    var pixels = []

    images.forEach(function (image) {
      if (image.pixels) {
        pixels.push(image.pixels)
      } else if (image.mipmap) {
        pixels.push.apply(pixels, image.mipmap)
      }
    })

    function refresh () {
      if (!data.width || !data.height) {
        // try to recompute size
        pixels.forEach(function (pixelData) {
          if (pixelData.image) {
            data.width = data.width || pixelData.image.naturalWidth
            data.height = data.height || pixelData.image.naturalWidth
          } else if (pixelData.video) {
            data.width = data.width || pixelData.video.width
            data.height = data.height || pixelData.video.height
          }
        })
      }
      texture.refresh()
    }

    pixels.forEach(function (pixelData) {
      if (pixelData.image && !pixelData.image.complete) {
        pixelData.image.addEventListener('load', refresh)
      } else if (pixelData.video && pixelData.readyState < 1) {
        pixelData.video.addEventListener('progress', refresh)
      }
    })

    function detachListeners () {
      pixels.forEach(function (pixelData) {
        if (pixelData.image) {
          pixelData.image.removeEventListener('load', refresh)
        } else if (pixelData.video) {
          pixelData.video.removeEventListener('progress', refresh)
        }
      })
    }

    return detachListeners
  }

  function createTexture (options, target) {
    var texture = new REGLTexture(target, gl.createTexture())
    textureSet[texture.id] = texture

    var parse = target === GL_TEXTURE_2D
      ? parseTexture2D
      : parseCube

    function reglTexture (options) {
      if (texture.cancelPending) {
        texture.cancelPending()
        texture.cancelPending = null
      }

      clearPoll(texture)

      var input = options || {}
      if (typeof input !== 'object') {
        input = {
          data: input
        }
      }
      var args = parse(input)
      var params = args.params
      texture.data = args

      if (params.needsListeners) {
        texture.cancelPending = hookListeners(texture)
      }

      if (params.poll) {
        texture.pollId = pollSet.length
        pollSet.push(texture)
      }

      texture.refresh()
    }

    reglTexture(options)

    reglTexture._reglType = 'texture'
    reglTexture._texture = texture
    reglTexture.destroy = function () {
      texture.destroy()
    }

    return reglTexture
  }

  function refreshTextures () {
    Object.keys(textureSet).forEach(function (texId) {
      textureSet[texId].refresh()
    })
    for (var i = 0; i < numTexUnits; ++i) {
      textureUnits[i] = null
    }
    activeTexture = 0
    gl.activeTexture(GL_TEXTURE0)
  }

  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0 + i)
      gl.bindTexture(GL_TEXTURE_2D, null)
      textureUnits[i] = null
    }
    gl.activeTexture(GL_TEXTURE0)
    activeTexture = 0
    Object.keys(textureSet).forEach(function (texId) {
      textureSet[texId].destroy()
    })
  }

  // Update any textures
  function pollTextures () {
    for (var i = 0; i < pollSet.length; ++i) {
      pollSet[i].refresh()
    }
  }

  return {
    create: createTexture,
    refresh: refreshTextures,
    clear: destroyTextures,
    poll: pollTextures,
    getTexture: function (wrapper) {
      return null
    }
  }
}

},{"./check":4,"./is-typed-array":21,"./load-texture":23}],30:[function(require,module,exports){
module.exports = function wrapUniformState () {
  var uniformState = {}

  function defUniform (name) {
    if (name in uniformState) {
      return
    }
    uniformState[name] = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ]
  }

  return {
    uniforms: uniformState,
    def: defUniform
  }
}

},{}],31:[function(require,module,exports){
var check = require('./lib/check')
var getContext = require('./lib/context')
var wrapExtensions = require('./lib/extension')
var wrapLimits = require('./lib/limits')
var wrapBuffers = require('./lib/buffer')
var wrapElements = require('./lib/elements')
var wrapTextures = require('./lib/texture')
var wrapFBOs = require('./lib/fbo')
var wrapUniforms = require('./lib/uniform')
var wrapAttributes = require('./lib/attribute')
var wrapShaders = require('./lib/shader')
var wrapDraw = require('./lib/draw')
var wrapContext = require('./lib/state')
var createCompiler = require('./lib/compile')
var wrapRead = require('./lib/read')
var dynamic = require('./lib/dynamic')
var raf = require('./lib/raf')
var clock = require('./lib/clock')

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962
var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

module.exports = function wrapREGL () {
  var args = getContext(Array.prototype.slice.call(arguments))
  var gl = args.gl
  var options = args.options

  var extensionState = wrapExtensions(gl)
  var limits = wrapLimits(gl, extensionState)
  var bufferState = wrapBuffers(gl)
  var elementState = wrapElements(gl, extensionState, bufferState)
  var uniformState = wrapUniforms()
  var attributeState = wrapAttributes(gl, extensionState, bufferState)
  var textureState = wrapTextures(gl, extensionState, limits, poll)
  var fboState = wrapFBOs(gl, extensionState, textureState)
  var shaderState = wrapShaders(
    gl,
    extensionState,
    attributeState,
    uniformState,
    function (program) {
      return compiler.draw(program)
    })
  var drawState = wrapDraw(gl, extensionState, bufferState)
  var glState = wrapContext(gl, shaderState)
  var frameState = {
    count: 0,
    start: clock(),
    dt: 0,
    t: clock(),
    renderTime: 0,
    width: gl.drawingBufferWidth,
    height: gl.drawingBufferHeight
  }
  var readPixels = wrapRead(gl, glState)

  var compiler = createCompiler(
    gl,
    extensionState,
    bufferState,
    elementState,
    textureState,
    fboState,
    glState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    frameState)

  var canvas = gl.canvas

  // raf stuff
  var rafCallbacks = []
  var activeRAF = 0
  function handleRAF () {
    activeRAF = raf.next(handleRAF)
    frameState.count += 1

    if (frameState.width !== gl.drawingBufferWidth ||
        frameState.height !== gl.drawingBufferHeight) {
      frameState.width = gl.drawingBufferWidth
      frameState.height = gl.drawingBufferHeight
      glState.notifyViewportChanged()
    }

    var now = clock()
    frameState.dt = now - frameState.t
    frameState.t = now

    textureState.poll()

    for (var i = 0; i < rafCallbacks.length; ++i) {
      var cb = rafCallbacks[i]
      cb(frameState.count, frameState.t, frameState.dt)
    }
    frameState.renderTime = clock() - now
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      handleRAF()
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = 0
    }
  }

  function handleContextLoss (event) {
    stopRAF()
    event.preventDefault()
    if (options.onContextLost) {
      options.onContextLost()
    }
  }

  function handleContextRestored (event) {
    gl.getError()
    extensionState.refresh()
    bufferState.refresh()
    textureState.refresh()
    fboState.refresh()
    shaderState.refresh()
    glState.refresh()
    if (options.onContextRestored) {
      options.onContextRestored()
    }
    handleRAF()
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  // Resource destructuion
  function destroy () {
    stopRAF()

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    fboState.clear()
    textureState.clear()
    bufferState.clear()

    if (options.onDestroy) {
      options.onDestroy()
    }
  }

  // Compiles a set of procedures for an object
  function compileProcedure (options) {
    check(!!options, 'invalid args to regl({...})')
    check.type(options, 'object', 'invalid args to regl({...})')

    var hasDynamic = false

    function flattenNestedOptions (options) {
      var result = Object.assign({}, options)
      delete result.uniforms
      delete result.attributes

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      return result
    }

    // First we separate the options into static and dynamic components
    function separateDynamic (object) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          hasDynamic = true
          dynamicItems[option] = dynamic.unbox(value, option)
        } else {
          staticItems[option] = value
        }
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    var uniforms = separateDynamic(options.uniforms || {})
    var attributes = separateDynamic(options.attributes || {})
    var opts = separateDynamic(flattenNestedOptions(options))

    var compiled = compiler.command(
      opts.static, uniforms.static, attributes.static,
      opts.dynamic, uniforms.dynamic, attributes.dynamic,
      hasDynamic)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      if (typeof args === 'number') {
        return batch(args | 0, reserve(args | 0))
      } else if (Array.isArray(args)) {
        return batch(args.length, args)
      } else if (typeof args === 'function') {
        return scope(null, args)
      } else if (typeof body === 'function') {
        return scope(args, body)
      }
      return draw(args)
    }

    return REGLCommand
  }

  function poll () {
    glState.poll()
  }

  // Clears the currently bound frame buffer
  function clear (options) {
    var clearFlags = 0

    // Update context state
    glState.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }

    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }

    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  // Registers another requestAnimationFrame callback
  function frame (cb) {
    rafCallbacks.push(cb)

    function cancel () {
      var index = rafCallbacks.find(function (item) {
        return item === cb
      })
      if (index < 0) {
        return
      }
      rafCallbacks.splice(index, 1)
      if (rafCallbacks.length <= 0) {
        stopRAF()
      }
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  return Object.assign(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Dynamic variable binding
    prop: dynamic.define,

    // Object constructors
    elements: function (options) {
      return elementState.create(options)
    },
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER)
    },
    texture: function (options) {
      return textureState.create(options, GL_TEXTURE_2D)
    },
    cube: function (options) {
      return textureState.create(options, GL_TEXTURE_CUBE_MAP)
    },
    // fbo: create(fboState),

    // Frame rendering
    frame: frame,
    stats: frameState,

    // System limits
    limits: limits,

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy
  })
}

},{"./lib/attribute":2,"./lib/buffer":3,"./lib/check":4,"./lib/clock":5,"./lib/compile":7,"./lib/context":15,"./lib/draw":16,"./lib/dynamic":17,"./lib/elements":18,"./lib/extension":19,"./lib/fbo":20,"./lib/limits":22,"./lib/raf":24,"./lib/read":25,"./lib/shader":26,"./lib/state":28,"./lib/texture":29,"./lib/uniform":30}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlL2VsZW1lbnRzLmpzIiwibGliL2F0dHJpYnV0ZS5qcyIsImxpYi9idWZmZXIuanMiLCJsaWIvY2hlY2suanMiLCJsaWIvY2xvY2suanMiLCJsaWIvY29kZWdlbi5qcyIsImxpYi9jb21waWxlLmpzIiwibGliL2NvbnN0YW50cy9hcnJheXR5cGVzLmpzb24iLCJsaWIvY29uc3RhbnRzL2JsZW5kZXF1YXRpb25zLmpzb24iLCJsaWIvY29uc3RhbnRzL2JsZW5kZnVuY3MuanNvbiIsImxpYi9jb25zdGFudHMvY29tcGFyZWZ1bmNzLmpzb24iLCJsaWIvY29uc3RhbnRzL2R0eXBlcy5qc29uIiwibGliL2NvbnN0YW50cy9wcmltaXRpdmVzLmpzb24iLCJsaWIvY29uc3RhbnRzL3N0ZW5jaWwtb3BzLmpzb24iLCJsaWIvY29udGV4dC5qcyIsImxpYi9kcmF3LmpzIiwibGliL2R5bmFtaWMuanMiLCJsaWIvZWxlbWVudHMuanMiLCJsaWIvZXh0ZW5zaW9uLmpzIiwibGliL2Ziby5qcyIsImxpYi9pcy10eXBlZC1hcnJheS5qcyIsImxpYi9saW1pdHMuanMiLCJsaWIvbG9hZC10ZXh0dXJlLmpzIiwibGliL3JhZi5qcyIsImxpYi9yZWFkLmpzIiwibGliL3NoYWRlci5qcyIsImxpYi9zdGFjay5qcyIsImxpYi9zdGF0ZS5qcyIsImxpYi90ZXh0dXJlLmpzIiwibGliL3VuaWZvcm0uanMiLCJyZWdsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3IrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgcmVnbCA9IHJlcXVpcmUoJy4uL3JlZ2wnKSgpXG5cbnJlZ2wuY2xlYXIoe1xuICBjb2xvcjogWzAsIDAsIDAsIDFdLFxuICBkZXB0aDogMVxufSlcblxucmVnbCh7XG4gIGZyYWc6IFtcbiAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAndW5pZm9ybSB2ZWM0IGNvbG9yOycsXG4gICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICcgIGdsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgJ30nXG4gIF0uam9pbignXFxuJyksXG5cbiAgdmVydDogW1xuICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxuICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAnICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpOycsXG4gICAgJ30nXG4gIF0uam9pbignXFxuJyksXG5cbiAgYXR0cmlidXRlczoge1xuICAgIHBvc2l0aW9uOiByZWdsLmJ1ZmZlcigobmV3IEFycmF5KDUpKS5maWxsKCkubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICB2YXIgdGhldGEgPSAyLjAgKiBNYXRoLlBJICogaSAvIDVcbiAgICAgIHJldHVybiBbIE1hdGguc2luKHRoZXRhKSwgTWF0aC5jb3ModGhldGEpIF1cbiAgICB9KSlcbiAgfSxcblxuICB1bmlmb3Jtczoge1xuICAgIGNvbG9yOiBbMSwgMCwgMCwgMV1cbiAgfSxcblxuICBlbGVtZW50czogcmVnbC5lbGVtZW50cyhbXG4gICAgWzAsIDFdLFxuICAgIFswLCAyXSxcbiAgICBbMCwgM10sXG4gICAgWzAsIDRdLFxuICAgIFsxLCAyXSxcbiAgICBbMSwgM10sXG4gICAgWzEsIDRdLFxuICAgIFsyLCAzXSxcbiAgICBbMiwgNF0sXG4gICAgWzMsIDRdXG4gIF0pLFxuXG4gIGxpbmVXaWR0aDogM1xufSkoKVxuIiwidmFyIGdsVHlwZXMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9kdHlwZXMuanNvbicpXG5cbnZhciBHTF9GTE9BVCA9IDUxMjZcblxuZnVuY3Rpb24gQXR0cmlidXRlUmVjb3JkICgpIHtcbiAgdGhpcy5wb2ludGVyID0gZmFsc2VcblxuICB0aGlzLnggPSAwLjBcbiAgdGhpcy55ID0gMC4wXG4gIHRoaXMueiA9IDAuMFxuICB0aGlzLncgPSAwLjBcblxuICB0aGlzLmJ1ZmZlciA9IG51bGxcbiAgdGhpcy5zaXplID0gMFxuICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZVxuICB0aGlzLnR5cGUgPSBHTF9GTE9BVFxuICB0aGlzLm9mZnNldCA9IDBcbiAgdGhpcy5zdHJpZGUgPSAwXG4gIHRoaXMuZGl2aXNvciA9IDBcbn1cblxuT2JqZWN0LmFzc2lnbihBdHRyaWJ1dGVSZWNvcmQucHJvdG90eXBlLCB7XG4gIGVxdWFsczogZnVuY3Rpb24gKG90aGVyLCBzaXplKSB7XG4gICAgaWYgKCF0aGlzLnBvaW50ZXIpIHtcbiAgICAgIHJldHVybiAhb3RoZXIucG9pbnRlciAmJlxuICAgICAgICB0aGlzLnggPT09IG90aGVyLnggJiZcbiAgICAgICAgdGhpcy55ID09PSBvdGhlci55ICYmXG4gICAgICAgIHRoaXMueiA9PT0gb3RoZXIueiAmJlxuICAgICAgICB0aGlzLncgPT09IG90aGVyLndcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG90aGVyLnBvaW50ZXIgJiZcbiAgICAgICAgdGhpcy5idWZmZXIgPT09IG90aGVyLmJ1ZmZlciAmJlxuICAgICAgICB0aGlzLnNpemUgPT09IHNpemUgJiZcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkID09PSBvdGhlci5ub3JtYWxpemVkICYmXG4gICAgICAgIHRoaXMudHlwZSA9PT0gb3RoZXIudHlwZSAmJlxuICAgICAgICB0aGlzLm9mZnNldCA9PT0gb3RoZXIub2Zmc2V0ICYmXG4gICAgICAgIHRoaXMuc3RyaWRlID09PSBvdGhlci5zdHJpZGUgJiZcbiAgICAgICAgdGhpcy5kaXZpc29yID09PSBvdGhlci5kaXZpc29yXG4gICAgfVxuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKG90aGVyLCBzaXplKSB7XG4gICAgdmFyIHBvaW50ZXIgPSB0aGlzLnBvaW50ZXIgPSBvdGhlci5wb2ludGVyXG4gICAgaWYgKHBvaW50ZXIpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gb3RoZXIuYnVmZmVyXG4gICAgICB0aGlzLnNpemUgPSBzaXplXG4gICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBvdGhlci5ub3JtYWxpemVkXG4gICAgICB0aGlzLnR5cGUgPSBvdGhlci50eXBlXG4gICAgICB0aGlzLm9mZnNldCA9IG90aGVyLm9mZnNldFxuICAgICAgdGhpcy5zdHJpZGUgPSBvdGhlci5zdHJpZGVcbiAgICAgIHRoaXMuZGl2aXNvciA9IG90aGVyLmRpdmlzb3JcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gb3RoZXIueFxuICAgICAgdGhpcy55ID0gb3RoZXIueVxuICAgICAgdGhpcy56ID0gb3RoZXIuelxuICAgICAgdGhpcy53ID0gb3RoZXIud1xuICAgIH1cbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3cmFwQXR0cmlidXRlU3RhdGUgKGdsLCBleHRlbnNpb25TdGF0ZSwgYnVmZmVyU3RhdGUpIHtcbiAgdmFyIGV4dGVuc2lvbnMgPSBleHRlbnNpb25TdGF0ZS5leHRlbnNpb25zXG5cbiAgdmFyIGF0dHJpYnV0ZVN0YXRlID0ge31cblxuICB2YXIgTlVNX0FUVFJJQlVURVMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTKVxuICB2YXIgYXR0cmlidXRlQmluZGluZ3MgPSBuZXcgQXJyYXkoTlVNX0FUVFJJQlVURVMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTlVNX0FUVFJJQlVURVM7ICsraSkge1xuICAgIGF0dHJpYnV0ZUJpbmRpbmdzW2ldID0gbmV3IEF0dHJpYnV0ZVJlY29yZCgpXG4gIH1cblxuICBmdW5jdGlvbiBBdHRyaWJ1dGVTdGFjayAoKSB7XG4gICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoMTYpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICByZWNvcmRzW2ldID0gbmV3IEF0dHJpYnV0ZVJlY29yZCgpXG4gICAgfVxuICAgIHRoaXMucmVjb3JkcyA9IHJlY29yZHNcbiAgICB0aGlzLnRvcCA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGVTdGFjayAoc3RhY2spIHtcbiAgICB2YXIgcmVjb3JkcyA9IHN0YWNrLnJlY29yZHNcbiAgICB2YXIgdG9wID0gc3RhY2sudG9wXG5cbiAgICB3aGlsZSAocmVjb3Jkcy5sZW5ndGggLSAxIDw9IHRvcCkge1xuICAgICAgcmVjb3Jkcy5wdXNoKG5ldyBBdHRyaWJ1dGVSZWNvcmQoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb3Jkc1srK3N0YWNrLnRvcF1cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oQXR0cmlidXRlU3RhY2sucHJvdG90eXBlLCB7XG4gICAgcHVzaFZlYzogZnVuY3Rpb24gKHgsIHksIHosIHcpIHtcbiAgICAgIHZhciBoZWFkID0gcHVzaEF0dHJpYnV0ZVN0YWNrKHRoaXMpXG4gICAgICBoZWFkLnBvaW50ZXIgPSBmYWxzZVxuICAgICAgaGVhZC54ID0geFxuICAgICAgaGVhZC55ID0geVxuICAgICAgaGVhZC56ID0gelxuICAgICAgaGVhZC53ID0gd1xuICAgIH0sXG5cbiAgICBwdXNoUHRyOiBmdW5jdGlvbiAoXG4gICAgICBidWZmZXIsXG4gICAgICBzaXplLFxuICAgICAgb2Zmc2V0LFxuICAgICAgc3RyaWRlLFxuICAgICAgZGl2aXNvcixcbiAgICAgIG5vcm1hbGl6ZWQsXG4gICAgICB0eXBlKSB7XG4gICAgICB2YXIgaGVhZCA9IHB1c2hBdHRyaWJ1dGVTdGFjayh0aGlzKVxuICAgICAgaGVhZC5wb2ludGVyID0gdHJ1ZVxuICAgICAgaGVhZC5idWZmZXIgPSBidWZmZXJcbiAgICAgIGhlYWQuc2l6ZSA9IHNpemVcbiAgICAgIGhlYWQub2Zmc2V0ID0gb2Zmc2V0XG4gICAgICBoZWFkLnN0cmlkZSA9IHN0cmlkZVxuICAgICAgaGVhZC5kaXZpc29yID0gZGl2aXNvclxuICAgICAgaGVhZC5ub3JtYWxpemVkID0gbm9ybWFsaXplZFxuICAgICAgaGVhZC50eXBlID0gdHlwZVxuICAgIH0sXG5cbiAgICBwdXNoRHluOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLnB1c2hWZWMoZGF0YSwgMCwgMCwgMClcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICB0aGlzLnB1c2hWZWMoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoZGF0YSlcbiAgICAgICAgdmFyIHNpemUgPSAwXG4gICAgICAgIHZhciBzdHJpZGUgPSAwXG4gICAgICAgIHZhciBvZmZzZXQgPSAwXG4gICAgICAgIHZhciBkaXZpc29yID0gMFxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGZhbHNlXG4gICAgICAgIHZhciB0eXBlID0gR0xfRkxPQVRcbiAgICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoZGF0YS5idWZmZXIpXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZSB8fCAwXG4gICAgICAgICAgc3RyaWRlID0gZGF0YS5zdHJpZGUgfHwgMFxuICAgICAgICAgIG9mZnNldCA9IGRhdGEub2Zmc2V0IHx8IDBcbiAgICAgICAgICBkaXZpc29yID0gZGF0YS5kaXZpc29yIHx8IDBcbiAgICAgICAgICBub3JtYWxpemVkID0gZGF0YS5ub3JtYWxpemVkIHx8IGZhbHNlXG4gICAgICAgICAgdHlwZSA9IGJ1ZmZlci5kdHlwZVxuICAgICAgICAgIGlmICgndHlwZScgaW4gZGF0YSkge1xuICAgICAgICAgICAgdHlwZSA9IGdsVHlwZXNbZGF0YS50eXBlXVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gYnVmZmVyLmR0eXBlXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoUHRyKGJ1ZmZlciwgc2l6ZSwgb2Zmc2V0LCBzdHJpZGUsIGRpdmlzb3IsIG5vcm1hbGl6ZWQsIHR5cGUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50b3AgLT0gMVxuICAgIH1cbiAgfSlcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQklORCBBTiBBVFRSSUJVVEVcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGJpbmRBdHRyaWJ1dGUgKGluZGV4LCBjdXJyZW50LCBuZXh0LCBzaXplKSB7XG4gICAgc2l6ZSA9IG5leHQuc2l6ZSB8fCBzaXplXG4gICAgaWYgKGN1cnJlbnQuZXF1YWxzKG5leHQsIHNpemUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFuZXh0LnBvaW50ZXIpIHtcbiAgICAgIGlmIChjdXJyZW50LnBvaW50ZXIpIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KVxuICAgICAgfVxuICAgICAgZ2wudmVydGV4QXR0cmliNGYoaW5kZXgsIG5leHQueCwgbmV4dC55LCBuZXh0LnosIG5leHQudylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjdXJyZW50LnBvaW50ZXIpIHtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpXG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5idWZmZXIgIT09IG5leHQuYnVmZmVyKSB7XG4gICAgICAgIG5leHQuYnVmZmVyLmJpbmQoKVxuICAgICAgfVxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNpemUsXG4gICAgICAgIG5leHQudHlwZSxcbiAgICAgICAgbmV4dC5ub3JtYWxpemVkLFxuICAgICAgICBuZXh0LnN0cmlkZSxcbiAgICAgICAgbmV4dC5vZmZzZXQpXG4gICAgICB2YXIgZXh0SW5zdGFuY2luZyA9IGV4dGVuc2lvbnMuYW5nbGVfaW5zdGFuY2VkX2FycmF5c1xuICAgICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgICAgZXh0SW5zdGFuY2luZy52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaW5kZXgsIG5leHQuZGl2aXNvcilcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudC5zZXQobmV4dCwgc2l6ZSlcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBERUZJTkUgQSBORVcgQVRUUklCVVRFXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBkZWZBdHRyaWJ1dGUgKG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiBhdHRyaWJ1dGVTdGF0ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGF0dHJpYnV0ZVN0YXRlW25hbWVdID0gbmV3IEF0dHJpYnV0ZVN0YWNrKClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmluZGluZ3M6IGF0dHJpYnV0ZUJpbmRpbmdzLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZVN0YXRlLFxuICAgIGJpbmQ6IGJpbmRBdHRyaWJ1dGUsXG4gICAgZGVmOiBkZWZBdHRyaWJ1dGVcbiAgfVxufVxuIiwiLy8gQXJyYXkgYW5kIGVsZW1lbnQgYnVmZmVyIGNyZWF0aW9uXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJylcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzLXR5cGVkLWFycmF5JylcbnZhciBhcnJheVR5cGVzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvYXJyYXl0eXBlcy5qc29uJylcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUgPSA1MTIxXG52YXIgR0xfU1RBVElDX0RSQVcgPSAzNTA0NFxudmFyIEdMX0ZMT0FUID0gNTEyNlxuXG52YXIgdXNhZ2VUeXBlcyA9IHtcbiAgJ3N0YXRpYyc6IDM1MDQ0LFxuICAnZHluYW1pYyc6IDM1MDQ4LFxuICAnc3RyZWFtJzogMzUwNDBcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoZGF0YSwgZGltZW5zaW9uKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEubGVuZ3RoICogZGltZW5zaW9uKVxuICB2YXIgcHRyID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdiA9IGRhdGFbaV1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICByZXN1bHRbcHRyKytdID0gdltqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd3JhcEJ1ZmZlclN0YXRlIChnbCkge1xuICB2YXIgYnVmZmVyQ291bnQgPSAwXG4gIHZhciBidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xCdWZmZXIgKGJ1ZmZlciwgdHlwZSkge1xuICAgIHRoaXMuaWQgPSBidWZmZXJDb3VudCsrXG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXJcbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgdGhpcy51c2FnZSA9IEdMX1NUQVRJQ19EUkFXXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gMFxuICAgIHRoaXMuZGltZW5zaW9uID0gMVxuICAgIHRoaXMuZGF0YSA9IG51bGxcbiAgICB0aGlzLmR0eXBlID0gR0xfVU5TSUdORURfQllURVxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihSRUdMQnVmZmVyLnByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmJ1ZmZlcilcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHwgaXNUeXBlZEFycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgZGF0YTogb3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIGxlbmd0aDogb3B0aW9ucyB8IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgIH1cblxuICAgICAgY2hlY2sudHlwZShcbiAgICAgICAgb3B0aW9ucywgJ29iamVjdCcsXG4gICAgICAgICdidWZmZXIgYXJndW1lbnRzIG11c3QgYmUgYW4gb2JqZWN0LCBhIG51bWJlciBvciBhbiBhcnJheScpXG5cbiAgICAgIGlmICgndXNhZ2UnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVzYWdlID0gb3B0aW9ucy51c2FnZVxuICAgICAgICBjaGVjay5wYXJhbWV0ZXIodXNhZ2UsIHVzYWdlVHlwZXMsICdidWZmZXIgdXNhZ2UnKVxuICAgICAgICB0aGlzLnVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXVxuICAgICAgfVxuXG4gICAgICB2YXIgZGltZW5zaW9uID0gKG9wdGlvbnMuZGltZW5zaW9uIHwgMCkgfHwgMVxuICAgICAgaWYgKCdkYXRhJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhXG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfCAwXG4gICAgICAgICAgdGhpcy5kdHlwZSA9IEdMX1VOU0lHTkVEX0JZVEVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCAmJiBBcnJheS5pc0FycmF5KGRhdGFbMF0pKSB7XG4gICAgICAgICAgICAgIGRpbWVuc2lvbiA9IGRhdGFbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgIGRhdGEgPSBmbGF0dGVuKGRhdGEsIGRpbWVuc2lvbilcbiAgICAgICAgICAgICAgdGhpcy5kdHlwZSA9IEdMX0ZMT0FUXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKVxuICAgICAgICAgICAgICB0aGlzLmR0eXBlID0gR0xfRkxPQVRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2suaXNUeXBlZEFycmF5KGRhdGEsICdpbnZhbGlkIGRhdGEgdHlwZSBidWZmZXIgZGF0YScpXG4gICAgICAgICAgICB0aGlzLmR0eXBlID0gYXJyYXlUeXBlc1tPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSldXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YVxuICAgICAgfSBlbHNlIGlmICgnbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gb3B0aW9ucy5sZW5ndGhcbiAgICAgICAgY2hlY2subm5pKGJ5dGVMZW5ndGgsICdidWZmZXIgbGVuZ3RoIG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyJylcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbFxuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8IDBcbiAgICAgICAgdGhpcy5kdHlwZSA9IEdMX1VOU0lHTkVEX0JZVEVcbiAgICAgIH1cblxuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIGdsLmJ1ZmZlckRhdGEodGhpcy50eXBlLCB0aGlzLmRhdGEgfHwgdGhpcy5ieXRlTGVuZ3RoLCB0aGlzLnVzYWdlKVxuICAgIH0sXG5cbiAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWdsLmlzQnVmZmVyKHRoaXMuYnVmZmVyKSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZSh7fSlcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2sodGhpcy5idWZmZXIsICdidWZmZXIgbXVzdCBub3QgYmUgZGVsZXRlZCBhbHJlYWR5JylcbiAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcilcbiAgICAgIHRoaXMuYnVmZmVyID0gbnVsbFxuICAgICAgZGVsZXRlIGJ1ZmZlclNldFt0aGlzLmlkXVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKG9wdGlvbnMsIHR5cGUpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBoYW5kbGUgPSBnbC5jcmVhdGVCdWZmZXIoKVxuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBSRUdMQnVmZmVyKGhhbmRsZSwgdHlwZSlcbiAgICBidWZmZXIudXBkYXRlKG9wdGlvbnMpXG4gICAgYnVmZmVyU2V0W2J1ZmZlci5pZF0gPSBidWZmZXJcblxuICAgIGZ1bmN0aW9uIHJlZ2xCdWZmZXIgKG9wdGlvbnMpIHtcbiAgICAgIGJ1ZmZlci51cGRhdGUob3B0aW9ucyB8fCB7fSlcbiAgICAgIHJldHVybiByZWdsQnVmZmVyXG4gICAgfVxuXG4gICAgcmVnbEJ1ZmZlci5fcmVnbFR5cGUgPSAnYnVmZmVyJ1xuICAgIHJlZ2xCdWZmZXIuX2J1ZmZlciA9IGJ1ZmZlclxuICAgIHJlZ2xCdWZmZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgYnVmZmVyLmRlc3Ryb3koKSB9XG5cbiAgICByZXR1cm4gcmVnbEJ1ZmZlclxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGNyZWF0ZUJ1ZmZlcixcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBPYmplY3Qua2V5cyhidWZmZXJTZXQpLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcklkKSB7XG4gICAgICAgIGJ1ZmZlclNldFtidWZmZXJJZF0uZGVzdHJveSgpXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICBPYmplY3Qua2V5cyhidWZmZXJTZXQpLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcklkKSB7XG4gICAgICAgIGJ1ZmZlclNldFtidWZmZXJJZF0ucmVmcmVzaCgpXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBnZXRCdWZmZXI6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciAmJiB3cmFwcGVyLl9idWZmZXIgaW5zdGFuY2VvZiBSRUdMQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLl9idWZmZXJcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59XG4iLCIvLyBFcnJvciBjaGVja2luZyBhbmQgcGFyYW1ldGVyIHZhbGlkYXRpb25cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzLXR5cGVkLWFycmF5JylcblxuZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKVxuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbn1cblxuZnVuY3Rpb24gY2hlY2sgKHByZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFwcmVkKSB7XG4gICAgcmFpc2UobWVzc2FnZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNvbG9uIChtZXNzYWdlKSB7XG4gIGlmIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuICc6ICcgKyBtZXNzYWdlXG4gIH1cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyYW1ldGVyIChwYXJhbSwgcG9zc2liaWxpdGllcywgbWVzc2FnZSkge1xuICBjaGVjayhwYXJhbSBpbiBwb3NzaWJpbGl0aWVzLFxuICAgICd1bmtub3duIHBhcmFtZXRlciAoJyArIHBhcmFtICsgJyknICsgZW5jb2xvbihtZXNzYWdlKSArXG4gICAgJy4gcG9zc2libGUgdmFsdWVzOiAnICsgT2JqZWN0LmtleXMocG9zc2liaWxpdGllcykuam9pbigpKVxufVxuXG5mdW5jdGlvbiBjaGVja0lzVHlwZWRBcnJheSAoZGF0YSwgbWVzc2FnZSkge1xuICBjaGVjayhcbiAgICBpc1R5cGVkQXJyYXkoZGF0YSksXG4gICAgJ2ludmFsaWQgcGFyYW1ldGVyIHR5cGUnICsgZW5jb2xvbihtZXNzYWdlKSArXG4gICAgJy4gbXVzdCBiZSBhIHR5cGVkIGFycmF5Jylcbn1cblxuZnVuY3Rpb24gY2hlY2tUeXBlT2YgKHZhbHVlLCB0eXBlLCBtZXNzYWdlKSB7XG4gIGNoZWNrKHR5cGVvZiB2YWx1ZSA9PT0gdHlwZSxcbiAgICAnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAnLiBleHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgKHR5cGVvZiB2YWx1ZSkpXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9uTmVnYXRpdmVJbnQgKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGNoZWNrKFxuICAgICh2YWx1ZSA+PSAwKSAmJlxuICAgICgodmFsdWUgfCAwKSA9PT0gdmFsdWUpLFxuICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlLCAoJyArIHZhbHVlICsgJyknICsgZW5jb2xvbihtZXNzYWdlKSArXG4gICAgJy4gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxufVxuXG5mdW5jdGlvbiBjaGVja09uZU9mICh2YWx1ZSwgbGlzdCwgbWVzc2FnZSkge1xuICBjaGVjayhcbiAgICBsaXN0LmluZGV4T2YodmFsdWUpID49IDAsXG4gICAgJ2ludmFsaWQgdmFsdWUnICsgZW5jb2xvbihtZXNzYWdlKSArICcuIG11c3QgYmUgb25lIG9mOiAnICsgbGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKGNoZWNrLCB7XG4gIHJhaXNlOiByYWlzZSxcbiAgcGFyYW1ldGVyOiBjaGVja1BhcmFtZXRlcixcbiAgdHlwZTogY2hlY2tUeXBlT2YsXG4gIGlzVHlwZWRBcnJheTogY2hlY2tJc1R5cGVkQXJyYXksXG4gIG5uaTogY2hlY2tOb25OZWdhdGl2ZUludCxcbiAgb25lT2Y6IGNoZWNrT25lT2Zcbn0pXG4iLCIvKiBnbG9iYWxzIHBlcmZvcm1hbmNlICovXG5tb2R1bGUuZXhwb3J0cyA9XG4gICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdylcbiAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKSB9XG4gIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKyhuZXcgRGF0ZSgpKSB9XG4iLCJmdW5jdGlvbiBzbGljZSAoeCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoeClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFbnZpcm9ubWVudCAoKSB7XG4gIC8vIFVuaXF1ZSB2YXJpYWJsZSBpZCBjb3VudGVyXG4gIHZhciB2YXJDb3VudGVyID0gMFxuXG4gIC8vIExpbmtlZCB2YWx1ZXMgYXJlIHBhc3NlZCBmcm9tIHRoaXMgc2NvcGUgaW50byB0aGUgZ2VuZXJhdGVkIGNvZGUgYmxvY2tcbiAgLy8gQ2FsbGluZyBsaW5rKCkgcGFzc2VzIGEgdmFsdWUgaW50byB0aGUgZ2VuZXJhdGVkIHNjb3BlIGFuZCByZXR1cm5zXG4gIC8vIHRoZSB2YXJpYWJsZSBuYW1lIHdoaWNoIGl0IGlzIGJvdW5kIHRvXG4gIHZhciBsaW5rZWROYW1lcyA9IFtdXG4gIHZhciBsaW5rZWRWYWx1ZXMgPSBbXVxuICBmdW5jdGlvbiBsaW5rICh2YWx1ZSkge1xuICAgIHZhciBuYW1lID0gJ2cnICsgKHZhckNvdW50ZXIrKylcbiAgICBsaW5rZWROYW1lcy5wdXNoKG5hbWUpXG4gICAgbGlua2VkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIGNvZGUgYmxvY2tcbiAgZnVuY3Rpb24gYmxvY2sgKCkge1xuICAgIHZhciBjb2RlID0gW11cbiAgICBmdW5jdGlvbiBwdXNoICgpIHtcbiAgICAgIGNvZGUucHVzaC5hcHBseShjb2RlLCBzbGljZShhcmd1bWVudHMpKVxuICAgIH1cblxuICAgIHZhciB2YXJzID0gW11cbiAgICBmdW5jdGlvbiBkZWYgKCkge1xuICAgICAgdmFyIG5hbWUgPSAndicgKyAodmFyQ291bnRlcisrKVxuICAgICAgdmFycy5wdXNoKG5hbWUpXG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb2RlLnB1c2gobmFtZSwgJz0nKVxuICAgICAgICBjb2RlLnB1c2guYXBwbHkoY29kZSwgc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgY29kZS5wdXNoKCc7JylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwdXNoLCB7XG4gICAgICBkZWY6IGRlZixcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgKHZhcnMubGVuZ3RoID4gMCA/ICd2YXIgJyArIHZhcnMgKyAnOycgOiAnJyksXG4gICAgICAgICAgY29kZS5qb2luKCcnKVxuICAgICAgICBdLmpvaW4oJycpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHByb2NlZHVyZSBsaXN0XG4gIHZhciBwcm9jZWR1cmVzID0ge31cbiAgZnVuY3Rpb24gcHJvYyAobmFtZSkge1xuICAgIHZhciBhcmdzID0gW11cbiAgICBmdW5jdGlvbiBhcmcgKCkge1xuICAgICAgdmFyIG5hbWUgPSAnYScgKyAodmFyQ291bnRlcisrKVxuICAgICAgYXJncy5wdXNoKG5hbWUpXG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cblxuICAgIHZhciBib2R5ID0gYmxvY2soKVxuICAgIHZhciBib2R5VG9TdHJpbmcgPSBib2R5LnRvU3RyaW5nXG5cbiAgICB2YXIgcmVzdWx0ID0gcHJvY2VkdXJlc1tuYW1lXSA9IE9iamVjdC5hc3NpZ24oYm9keSwge1xuICAgICAgYXJnOiBhcmcsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICdmdW5jdGlvbignLCBhcmdzLmpvaW4oKSwgJyl7JyxcbiAgICAgICAgICBib2R5VG9TdHJpbmcoKSxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCcnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBjb21waWxlcyBhbmQgcmV0dXJucyBhbGwgYmxvY2tzXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKCkge1xuICAgIHZhciBjb2RlID0gWydcInVzZSBzdHJpY3RcIjtyZXR1cm4geyddXG4gICAgT2JqZWN0LmtleXMocHJvY2VkdXJlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgY29kZS5wdXNoKCdcIicsIG5hbWUsICdcIjonLCBwcm9jZWR1cmVzW25hbWVdLnRvU3RyaW5nKCksICcsJylcbiAgICB9KVxuICAgIGNvZGUucHVzaCgnfScpXG4gICAgdmFyIHByb2MgPSBGdW5jdGlvbi5hcHBseShudWxsLCBsaW5rZWROYW1lcy5jb25jYXQoW2NvZGUuam9pbignJyldKSlcbiAgICByZXR1cm4gcHJvYy5hcHBseShudWxsLCBsaW5rZWRWYWx1ZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbms6IGxpbmssXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIHByb2M6IHByb2MsXG4gICAgY29tcGlsZTogY29tcGlsZVxuICB9XG59XG4iLCJ2YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJylcbnZhciBjcmVhdGVFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vY29kZWdlbicpXG5cbnZhciBwcmltVHlwZXMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9wcmltaXRpdmVzLmpzb24nKVxudmFyIGdsVHlwZXMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9kdHlwZXMuanNvbicpXG52YXIgY29tcGFyZUZ1bmNzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvY29tcGFyZWZ1bmNzLmpzb24nKVxudmFyIGJsZW5kRnVuY3MgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9ibGVuZGZ1bmNzLmpzb24nKVxudmFyIGJsZW5kRXF1YXRpb25zX2Jhc2UgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9ibGVuZGVxdWF0aW9ucy5qc29uJylcbnZhciBzdGVuY2lsT3BzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvc3RlbmNpbC1vcHMuanNvbicpXG5cbnZhciBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiA9IDM0OTYzXG5cbnZhciBHTF9GTE9BVCA9IDUxMjZcbnZhciBHTF9GTE9BVF9WRUMyID0gMzU2NjRcbnZhciBHTF9GTE9BVF9WRUMzID0gMzU2NjVcbnZhciBHTF9GTE9BVF9WRUM0ID0gMzU2NjZcbnZhciBHTF9JTlQgPSA1MTI0XG52YXIgR0xfSU5UX1ZFQzIgPSAzNTY2N1xudmFyIEdMX0lOVF9WRUMzID0gMzU2NjhcbnZhciBHTF9JTlRfVkVDNCA9IDM1NjY5XG52YXIgR0xfQk9PTCA9IDM1NjcwXG52YXIgR0xfQk9PTF9WRUMyID0gMzU2NzFcbnZhciBHTF9CT09MX1ZFQzMgPSAzNTY3MlxudmFyIEdMX0JPT0xfVkVDNCA9IDM1NjczXG52YXIgR0xfRkxPQVRfTUFUMiA9IDM1Njc0XG52YXIgR0xfRkxPQVRfTUFUMyA9IDM1Njc1XG52YXIgR0xfRkxPQVRfTUFUNCA9IDM1Njc2XG52YXIgR0xfU0FNUExFUl8yRCA9IDM1Njc4XG52YXIgR0xfU0FNUExFUl9DVUJFID0gMzU2ODBcblxudmFyIEdMX1RSSUFOR0xFUyA9IDRcblxudmFyIEdMX0NVTExfRkFDRSA9IDB4MEI0NFxudmFyIEdMX0JMRU5EID0gMHgwQkUyXG52YXIgR0xfRElUSEVSID0gMHgwQkQwXG52YXIgR0xfU1RFTkNJTF9URVNUID0gMHgwQjkwXG52YXIgR0xfREVQVEhfVEVTVCA9IDB4MEI3MVxudmFyIEdMX1NDSVNTT1JfVEVTVCA9IDB4MEMxMVxudmFyIEdMX1BPTFlHT05fT0ZGU0VUX0ZJTEwgPSAweDgwMzdcbnZhciBHTF9TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UgPSAweDgwOUVcbnZhciBHTF9TQU1QTEVfQ09WRVJBR0UgPSAweDgwQTBcblxudmFyIEdMX0ZST05UID0gMTAyOFxudmFyIEdMX0JBQ0sgPSAxMDI5XG5cbnZhciBHTF9DVyA9IDB4MDkwMFxudmFyIEdMX0NDVyA9IDB4MDkwMVxuXG52YXIgR0xfTUlOX0VYVCA9IDB4ODAwN1xudmFyIEdMX01BWF9FWFQgPSAweDgwMDhcblxuZnVuY3Rpb24gdHlwZUxlbmd0aCAoeCkge1xuICBzd2l0Y2ggKHgpIHtcbiAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICBjYXNlIEdMX0JPT0xfVkVDMjpcbiAgICAgIHJldHVybiAyXG4gICAgY2FzZSBHTF9GTE9BVF9WRUMzOlxuICAgIGNhc2UgR0xfSU5UX1ZFQzM6XG4gICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICByZXR1cm4gM1xuICAgIGNhc2UgR0xfRkxPQVRfVkVDNDpcbiAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxuICAgICAgcmV0dXJuIDRcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDFcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRVbmlmb3JtU3RyaW5nIChnbCwgdHlwZSwgbG9jYXRpb24sIHZhbHVlKSB7XG4gIHZhciBpbmZpeFxuICB2YXIgc2VwYXJhdG9yID0gJywnXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR0xfRkxPQVQ6XG4gICAgICBpbmZpeCA9ICcxZidcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxuICAgICAgaW5maXggPSAnMmZ2J1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEdMX0ZMT0FUX1ZFQzM6XG4gICAgICBpbmZpeCA9ICczZnYnXG4gICAgICBicmVha1xuICAgIGNhc2UgR0xfRkxPQVRfVkVDNDpcbiAgICAgIGluZml4ID0gJzRmdidcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBHTF9CT09MOlxuICAgIGNhc2UgR0xfSU5UOlxuICAgICAgaW5maXggPSAnMWknXG4gICAgICBicmVha1xuICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxuICAgIGNhc2UgR0xfSU5UX1ZFQzI6XG4gICAgICBpbmZpeCA9ICcyaXYnXG4gICAgICBicmVha1xuICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxuICAgIGNhc2UgR0xfSU5UX1ZFQzM6XG4gICAgICBpbmZpeCA9ICczaXYnXG4gICAgICBicmVha1xuICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxuICAgIGNhc2UgR0xfSU5UX1ZFQzQ6XG4gICAgICBpbmZpeCA9ICc0aXYnXG4gICAgICBicmVha1xuICAgIGNhc2UgR0xfRkxPQVRfTUFUMjpcbiAgICAgIGluZml4ID0gJ01hdHJpeDJmdidcbiAgICAgIHNlcGFyYXRvciA9ICcsZmFsc2UsJ1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEdMX0ZMT0FUX01BVDM6XG4gICAgICBpbmZpeCA9ICdNYXRyaXgzZnYnXG4gICAgICBzZXBhcmF0b3IgPSAnLGZhbHNlLCdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBHTF9GTE9BVF9NQVQ0OlxuICAgICAgaW5maXggPSAnTWF0cml4NGZ2J1xuICAgICAgc2VwYXJhdG9yID0gJyxmYWxzZSwnXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBjaGVjay5yYWlzZSgndW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlJylcbiAgfVxuICByZXR1cm4gZ2wgKyAnLnVuaWZvcm0nICsgaW5maXggKyAnKCcgKyBsb2NhdGlvbiArIHNlcGFyYXRvciArIHZhbHVlICsgJyk7J1xufVxuXG5mdW5jdGlvbiBzdGFja1RvcCAoeCkge1xuICByZXR1cm4geCArICdbJyArIHggKyAnLmxlbmd0aC0xXSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWdsQ29tcGlsZXIgKFxuICBnbCxcbiAgZXh0ZW5zaW9uU3RhdGUsXG4gIGJ1ZmZlclN0YXRlLFxuICBlbGVtZW50U3RhdGUsXG4gIHRleHR1cmVTdGF0ZSxcbiAgZmJvU3RhdGUsXG4gIGdsU3RhdGUsXG4gIHVuaWZvcm1TdGF0ZSxcbiAgYXR0cmlidXRlU3RhdGUsXG4gIHNoYWRlclN0YXRlLFxuICBkcmF3U3RhdGUsXG4gIGZyYW1lU3RhdGUpIHtcbiAgdmFyIGV4dGVuc2lvbnMgPSBleHRlbnNpb25TdGF0ZS5leHRlbnNpb25zXG4gIHZhciBjb250ZXh0U3RhdGUgPSBnbFN0YXRlLmNvbnRleHRTdGF0ZVxuXG4gIHZhciBibGVuZEVxdWF0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmxlbmRFcXVhdGlvbnNfYmFzZSlcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X2JsZW5kX21pbm1heCkge1xuICAgIGJsZW5kRXF1YXRpb25zLm1pbiA9IEdMX01JTl9FWFRcbiAgICBibGVuZEVxdWF0aW9ucy5tYXggPSBHTF9NQVhfRVhUXG4gIH1cblxuICB2YXIgZHJhd0NhbGxDb3VudGVyID0gMFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU0hBREVSIFNJTkdMRSBEUkFXIE9QRVJBVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXJEcmF3IChwcm9ncmFtKSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZUVudmlyb25tZW50KClcbiAgICB2YXIgbGluayA9IGVudi5saW5rXG4gICAgdmFyIGRyYXcgPSBlbnYucHJvYygnZHJhdycpXG4gICAgdmFyIGRlZiA9IGRyYXcuZGVmXG5cbiAgICB2YXIgR0wgPSBsaW5rKGdsKVxuICAgIHZhciBQUk9HUkFNID0gbGluayhwcm9ncmFtLnByb2dyYW0pXG4gICAgdmFyIEJJTkRfQVRUUklCVVRFID0gbGluayhhdHRyaWJ1dGVTdGF0ZS5iaW5kKVxuICAgIHZhciBEUkFXX1NUQVRFID0ge1xuICAgICAgY291bnQ6IGxpbmsoZHJhd1N0YXRlLmNvdW50KSxcbiAgICAgIG9mZnNldDogbGluayhkcmF3U3RhdGUub2Zmc2V0KSxcbiAgICAgIGluc3RhbmNlczogbGluayhkcmF3U3RhdGUuaW5zdGFuY2VzKSxcbiAgICAgIHByaW1pdGl2ZTogbGluayhkcmF3U3RhdGUucHJpbWl0aXZlKVxuICAgIH1cbiAgICB2YXIgRUxFTUVOVF9TVEFURSA9IGxpbmsoZWxlbWVudFN0YXRlLmVsZW1lbnRzKVxuICAgIHZhciBURVhUVVJFX1VOSUZPUk1TID0gW11cblxuICAgIC8vIGJpbmQgdGhlIHByb2dyYW1cbiAgICBkcmF3KEdMLCAnLnVzZVByb2dyYW0oJywgUFJPR1JBTSwgJyk7JylcblxuICAgIC8vIHNldCB1cCBhdHRyaWJ1dGUgc3RhdGVcbiAgICBwcm9ncmFtLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgU1RBQ0sgPSBsaW5rKGF0dHJpYnV0ZVN0YXRlLmF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKVxuICAgICAgZHJhdyhCSU5EX0FUVFJJQlVURSwgJygnLFxuICAgICAgICBhdHRyaWJ1dGUubG9jYXRpb24sICcsJyxcbiAgICAgICAgbGluayhhdHRyaWJ1dGVTdGF0ZS5iaW5kaW5nc1thdHRyaWJ1dGUubG9jYXRpb25dKSwgJywnLFxuICAgICAgICBTVEFDSywgJy5yZWNvcmRzWycsIFNUQUNLLCAnLnRvcF0nLCAnLCcsXG4gICAgICAgIHR5cGVMZW5ndGgoYXR0cmlidXRlLmluZm8udHlwZSksICcpOycpXG4gICAgfSlcblxuICAgIC8vIHNldCB1cCB1bmlmb3Jtc1xuICAgIHByb2dyYW0udW5pZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAodW5pZm9ybSkge1xuICAgICAgdmFyIExPQ0FUSU9OID0gbGluayh1bmlmb3JtLmxvY2F0aW9uKVxuICAgICAgdmFyIFNUQUNLID0gbGluayh1bmlmb3JtU3RhdGUudW5pZm9ybXNbdW5pZm9ybS5uYW1lXSlcbiAgICAgIHZhciBUT1AgPSBTVEFDSyArICdbJyArIFNUQUNLICsgJy5sZW5ndGgtMV0nXG4gICAgICBpZiAodW5pZm9ybS5pbmZvLnR5cGUgPT09IEdMX1NBTVBMRVJfMkQgfHxcbiAgICAgICAgICB1bmlmb3JtLmluZm8udHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFKSB7XG4gICAgICAgIHZhciBURVhfVkFMVUUgPSBkZWYoVE9QICsgJy5fdGV4dHVyZScpXG4gICAgICAgIFRFWFRVUkVfVU5JRk9STVMucHVzaChURVhfVkFMVUUpXG4gICAgICAgIGRyYXcoc2V0VW5pZm9ybVN0cmluZyhHTCwgR0xfSU5ULCBMT0NBVElPTiwgVEVYX1ZBTFVFICsgJy5iaW5kKCknKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXcoc2V0VW5pZm9ybVN0cmluZyhHTCwgdW5pZm9ybS5pbmZvLnR5cGUsIExPQ0FUSU9OLCBUT1ApKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyB1bmJpbmQgdGV4dHVyZXMgaW1tZWRpYXRlbHlcbiAgICBURVhUVVJFX1VOSUZPUk1TLmZvckVhY2goZnVuY3Rpb24gKFRFWF9WQUxVRSkge1xuICAgICAgZHJhdyhURVhfVkFMVUUsICcudW5iaW5kKCk7JylcbiAgICB9KVxuXG4gICAgLy8gRXhlY3V0ZSBkcmF3IGNvbW1hbmRcbiAgICB2YXIgQ1VSX1BSSU1JVElWRSA9IGRlZihzdGFja1RvcChEUkFXX1NUQVRFLnByaW1pdGl2ZSkpXG4gICAgdmFyIENVUl9DT1VOVCA9IGRlZihzdGFja1RvcChEUkFXX1NUQVRFLmNvdW50KSlcbiAgICB2YXIgQ1VSX09GRlNFVCA9IGRlZihzdGFja1RvcChEUkFXX1NUQVRFLm9mZnNldCkpXG4gICAgdmFyIENVUl9FTEVNRU5UUyA9IGRlZihzdGFja1RvcChFTEVNRU5UX1NUQVRFKSlcblxuICAgIC8vIE9ubHkgZXhlY3V0ZSBkcmF3IGNvbW1hbmQgaWYgbnVtYmVyIGVsZW1lbnRzIGlzID4gMFxuICAgIGRyYXcoJ2lmKCcsIENVUl9DT1VOVCwgJyl7JylcblxuICAgIHZhciBpbnN0YW5jaW5nID0gZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzXG4gICAgaWYgKGluc3RhbmNpbmcpIHtcbiAgICAgIHZhciBDVVJfSU5TVEFOQ0VTID0gZGVmKHN0YWNrVG9wKERSQVdfU1RBVEUuaW5zdGFuY2VzKSlcbiAgICAgIHZhciBJTlNUQU5DRV9FWFQgPSBsaW5rKGluc3RhbmNpbmcpXG4gICAgICBkcmF3KFxuICAgICAgICAnaWYoJywgQ1VSX0VMRU1FTlRTLCAnKXsnLFxuICAgICAgICBDVVJfRUxFTUVOVFMsICcuYmluZCgpOycsXG4gICAgICAgICdpZignLCBDVVJfSU5TVEFOQ0VTLCAnPjApeycsXG4gICAgICAgIElOU1RBTkNFX0VYVCwgJy5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSgnLFxuICAgICAgICBDVVJfUFJJTUlUSVZFLCAnLCcsXG4gICAgICAgIENVUl9DT1VOVCwgJywnLFxuICAgICAgICBDVVJfRUxFTUVOVFMsICcudHlwZSwnLFxuICAgICAgICBDVVJfT0ZGU0VULCAnLCcsXG4gICAgICAgIENVUl9JTlNUQU5DRVMsICcpO31lbHNleycsXG4gICAgICAgIEdMLCAnLmRyYXdFbGVtZW50cygnLFxuICAgICAgICBDVVJfUFJJTUlUSVZFLCAnLCcsXG4gICAgICAgIENVUl9DT1VOVCwgJywnLFxuICAgICAgICBDVVJfRUxFTUVOVFMsICcudHlwZSwnLFxuICAgICAgICBDVVJfT0ZGU0VULCAnKTt9JyxcbiAgICAgICAgJ31lbHNlIGlmKCcsIENVUl9JTlNUQU5DRVMsICc+MCl7JyxcbiAgICAgICAgSU5TVEFOQ0VfRVhULCAnLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSgnLFxuICAgICAgICBDVVJfUFJJTUlUSVZFLCAnLCcsXG4gICAgICAgIENVUl9PRkZTRVQsICcsJyxcbiAgICAgICAgQ1VSX0NPVU5ULCAnLCcsXG4gICAgICAgIENVUl9JTlNUQU5DRVMsICcpO31lbHNleycsXG4gICAgICAgIEdMLCAnLmRyYXdBcnJheXMoJyxcbiAgICAgICAgQ1VSX1BSSU1JVElWRSwgJywnLFxuICAgICAgICBDVVJfT0ZGU0VULCAnLCcsXG4gICAgICAgIENVUl9DT1VOVCwgJyk7fX0nKVxuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3KFxuICAgICAgICAnaWYoJywgQ1VSX0VMRU1FTlRTLCAnKXsnLFxuICAgICAgICBHTCwgJy5kcmF3RWxlbWVudHMoJyxcbiAgICAgICAgQ1VSX1BSSU1JVElWRSwgJywnLFxuICAgICAgICBDVVJfQ09VTlQsICcsJyxcbiAgICAgICAgQ1VSX0VMRU1FTlRTLCAnLnR5cGUsJyxcbiAgICAgICAgQ1VSX09GRlNFVCwgJyk7fScsXG4gICAgICAgICd9ZWxzZXsnLFxuICAgICAgICBHTCwgJy5kcmF3QXJyYXlzKCcsXG4gICAgICAgIENVUl9QUklNSVRJVkUsICcsJyxcbiAgICAgICAgQ1VSX09GRlNFVCwgJywnLFxuICAgICAgICBDVVJfQ09VTlQsICcpO30nKVxuICAgIH1cblxuICAgIHJldHVybiBlbnYuY29tcGlsZSgpLmRyYXdcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQkFUQ0ggRFJBVyBPUEVSQVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBjb21waWxlQmF0Y2ggKFxuICAgIHByb2dyYW0sIG9wdGlvbnMsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzLCBzdGF0aWNPcHRpb25zKSB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGNvZGUgZ2VuZXJhdGlvbiBoZWxwZXJzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBlbnYgPSBjcmVhdGVFbnZpcm9ubWVudCgpXG4gICAgdmFyIGxpbmsgPSBlbnYubGlua1xuICAgIHZhciBiYXRjaCA9IGVudi5wcm9jKCdiYXRjaCcpXG4gICAgdmFyIGV4aXQgPSBlbnYuYmxvY2soKVxuICAgIHZhciBkZWYgPSBiYXRjaC5kZWZcbiAgICB2YXIgYXJnID0gYmF0Y2guYXJnXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gcmVnbCBzdGF0ZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgR0wgPSBsaW5rKGdsKVxuICAgIHZhciBQUk9HUkFNID0gbGluayhwcm9ncmFtLnByb2dyYW0pXG4gICAgdmFyIEJJTkRfQVRUUklCVVRFID0gbGluayhhdHRyaWJ1dGVTdGF0ZS5iaW5kKVxuICAgIHZhciBGUkFNRV9TVEFURSA9IGxpbmsoZnJhbWVTdGF0ZSlcbiAgICB2YXIgRFJBV19TVEFURSA9IHtcbiAgICAgIGNvdW50OiBsaW5rKGRyYXdTdGF0ZS5jb3VudCksXG4gICAgICBvZmZzZXQ6IGxpbmsoZHJhd1N0YXRlLm9mZnNldCksXG4gICAgICBpbnN0YW5jZXM6IGxpbmsoZHJhd1N0YXRlLmluc3RhbmNlcyksXG4gICAgICBwcmltaXRpdmU6IGxpbmsoZHJhd1N0YXRlLnByaW1pdGl2ZSlcbiAgICB9XG4gICAgdmFyIEVMRU1FTlRTID0gbGluayhlbGVtZW50U3RhdGUuZWxlbWVudHMpXG4gICAgdmFyIENVUl9DT1VOVCA9IGRlZihzdGFja1RvcChEUkFXX1NUQVRFLmNvdW50KSlcbiAgICB2YXIgQ1VSX09GRlNFVCA9IGRlZihzdGFja1RvcChEUkFXX1NUQVRFLm9mZnNldCkpXG4gICAgdmFyIENVUl9QUklNSVRJVkUgPSBkZWYoc3RhY2tUb3AoRFJBV19TVEFURS5wcmltaXRpdmUpKVxuICAgIHZhciBDVVJfRUxFTUVOVFMgPSBkZWYoc3RhY2tUb3AoRUxFTUVOVFMpKVxuICAgIHZhciBDVVJfSU5TVEFOQ0VTXG4gICAgdmFyIElOU1RBTkNFX0VYVFxuICAgIHZhciBpbnN0YW5jaW5nID0gZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzXG4gICAgaWYgKGluc3RhbmNpbmcpIHtcbiAgICAgIENVUl9JTlNUQU5DRVMgPSBkZWYoc3RhY2tUb3AoRFJBV19TVEFURS5pbnN0YW5jZXMpKVxuICAgICAgSU5TVEFOQ0VfRVhUID0gbGluayhpbnN0YW5jaW5nKVxuICAgIH1cbiAgICB2YXIgaGFzRHluYW1pY0VsZW1lbnRzID0gJ2VsZW1lbnRzJyBpbiBvcHRpb25zXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gYmF0Y2gvYXJndW1lbnQgdmFyc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgTlVNX0FSR1MgPSBhcmcoKVxuICAgIHZhciBBUkdTID0gYXJnKClcbiAgICB2YXIgQVJHID0gZGVmKClcbiAgICB2YXIgQkFUQ0hfSUQgPSBkZWYoKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGxvYWQgYSBkeW5hbWljIHZhcmlhYmxlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBkeW5hbWljVmFycyA9IHt9XG4gICAgZnVuY3Rpb24gZHluICh4KSB7XG4gICAgICB2YXIgaWQgPSB4LmlkXG4gICAgICB2YXIgcmVzdWx0ID0gZHluYW1pY1ZhcnNbaWRdXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIGlmICh4LmZ1bmMpIHtcbiAgICAgICAgcmVzdWx0ID0gYmF0Y2guZGVmKFxuICAgICAgICAgIGxpbmsoeC5kYXRhKSwgJygnLCBBUkcsICcsJywgQkFUQ0hfSUQsICcsJywgRlJBTUVfU1RBVEUsICcpJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGJhdGNoLmRlZihBUkcsICcuJywgeC5kYXRhKVxuICAgICAgfVxuICAgICAgZHluYW1pY1ZhcnNbaWRdID0gcmVzdWx0XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHJldHJpZXZlcyB0aGUgZmlyc3QgbmFtZS1tYXRjaGluZyByZWNvcmQgZnJvbSBhbiBBY3RpdmVJbmZvIGxpc3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gZmluZEluZm8gKGxpc3QsIG5hbWUpIHtcbiAgICAgIHJldHVybiBsaXN0LmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZSA9PT0gbmFtZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gYmluZCBzaGFkZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYmF0Y2goR0wsICcudXNlUHJvZ3JhbSgnLCBQUk9HUkFNLCAnKTsnKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldCBzdGF0aWMgdW5pZm9ybXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJvZ3JhbS51bmlmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uICh1bmlmb3JtKSB7XG4gICAgICBpZiAodW5pZm9ybS5uYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIExPQ0FUSU9OID0gbGluayh1bmlmb3JtLmxvY2F0aW9uKVxuICAgICAgdmFyIFNUQUNLID0gbGluayh1bmlmb3JtU3RhdGUudW5pZm9ybXNbdW5pZm9ybS5uYW1lXSlcbiAgICAgIHZhciBUT1AgPSBTVEFDSyArICdbJyArIFNUQUNLICsgJy5sZW5ndGgtMV0nXG4gICAgICBpZiAodW5pZm9ybS5pbmZvLnR5cGUgPT09IEdMX1NBTVBMRVJfMkQgfHxcbiAgICAgICAgICB1bmlmb3JtLmluZm8udHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFKSB7XG4gICAgICAgIHZhciBURVhfVkFMVUUgPSBkZWYoVE9QICsgJy5fdGV4dHVyZScpXG4gICAgICAgIGJhdGNoKHNldFVuaWZvcm1TdHJpbmcoR0wsIEdMX0lOVCwgTE9DQVRJT04sIFRFWF9WQUxVRSArICcuYmluZCgpJykpXG4gICAgICAgIGV4aXQoVEVYX1ZBTFVFLCAnLnVuYmluZCgpOycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaChzZXRVbmlmb3JtU3RyaW5nKEdMLCB1bmlmb3JtLmluZm8udHlwZSwgTE9DQVRJT04sIFRPUCkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZXQgc3RhdGljIGF0dHJpYnV0ZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJvZ3JhbS5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMubmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIFNUQUNLID0gbGluayhhdHRyaWJ1dGVTdGF0ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSlcbiAgICAgIGJhdGNoKEJJTkRfQVRUUklCVVRFLCAnKCcsXG4gICAgICAgIGF0dHJpYnV0ZS5sb2NhdGlvbiwgJywnLFxuICAgICAgICBsaW5rKGF0dHJpYnV0ZVN0YXRlLmJpbmRpbmdzW2F0dHJpYnV0ZS5sb2NhdGlvbl0pLCAnLCcsXG4gICAgICAgIFNUQUNLLCAnLnJlY29yZHNbJywgU1RBQ0ssICcudG9wXScsICcsJyxcbiAgICAgICAgdHlwZUxlbmd0aChhdHRyaWJ1dGUuaW5mby50eXBlKSwgJyk7JylcbiAgICB9KVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldCBzdGF0aWMgZWxlbWVudCBidWZmZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKCFoYXNEeW5hbWljRWxlbWVudHMpIHtcbiAgICAgIGJhdGNoKFxuICAgICAgICAnaWYoJywgQ1VSX0VMRU1FTlRTLCAnKXsnLFxuICAgICAgICBHTCwgJy5iaW5kQnVmZmVyKCcsIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCAnLCcsIENVUl9FTEVNRU5UUywgJy5idWZmZXIuX2J1ZmZlci5idWZmZXIpOycsXG4gICAgICAgICd9ZWxzZXsnLFxuICAgICAgICBHTCwgJy5iaW5kQnVmZmVyKCcsIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCAnLG51bGwpOycsXG4gICAgICAgICd9JylcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbG9vcCBvdmVyIGFsbCBhcmd1bWVudHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYmF0Y2goXG4gICAgICAnZm9yKCcsIEJBVENIX0lELCAnPTA7JywgQkFUQ0hfSUQsICc8JywgTlVNX0FSR1MsICc7KysnLCBCQVRDSF9JRCwgJyl7JyxcbiAgICAgIEFSRywgJz0nLCBBUkdTLCAnWycsIEJBVENIX0lELCAnXTsnKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldCBkeW5hbWljIGZsYWdzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgdmFyIFZBTFVFID0gZHluKG9wdGlvbnNbb3B0aW9uXSlcblxuICAgICAgZnVuY3Rpb24gc2V0Q2FwIChmbGFnKSB7XG4gICAgICAgIGJhdGNoKFxuICAgICAgICAgICdpZignLCBWQUxVRSwgJyl7JyxcbiAgICAgICAgICBHTCwgJy5lbmFibGUoJywgZmxhZywgJyk7fWVsc2V7JyxcbiAgICAgICAgICBHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpO30nKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICAvLyBDYXBzXG4gICAgICAgIGNhc2UgJ2N1bGwuZW5hYmxlJzpcbiAgICAgICAgICBzZXRDYXAoR0xfQ1VMTF9GQUNFKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2JsZW5kLmVuYWJsZSc6XG4gICAgICAgICAgc2V0Q2FwKEdMX0JMRU5EKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2RpdGhlcic6XG4gICAgICAgICAgc2V0Q2FwKEdMX0RJVEhFUilcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdzdGVuY2lsLmVuYWJsZSc6XG4gICAgICAgICAgc2V0Q2FwKEdMX1NURU5DSUxfVEVTVClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdkZXB0aC5lbmFibGUnOlxuICAgICAgICAgIHNldENhcChHTF9ERVBUSF9URVNUKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NjaXNzb3IuZW5hYmxlJzpcbiAgICAgICAgICBzZXRDYXAoR0xfU0NJU1NPUl9URVNUKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3BvbHlnb25PZmZzZXQuZW5hYmxlJzpcbiAgICAgICAgICBzZXRDYXAoR0xfUE9MWUdPTl9PRkZTRVRfRklMTClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdzYW1wbGUuYWxwaGEnOlxuICAgICAgICAgIHNldENhcChHTF9TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc2FtcGxlLmVuYWJsZSc6XG4gICAgICAgICAgc2V0Q2FwKEdMX1NBTVBMRV9DT1ZFUkFHRSlcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2RlcHRoLm1hc2snOlxuICAgICAgICAgIGJhdGNoKEdMLCAnLmRlcHRoTWFzaygnLCBWQUxVRSwgJyk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2RlcHRoLmZ1bmMnOlxuICAgICAgICAgIHZhciBERVBUSF9GVU5DUyA9IGxpbmsoY29tcGFyZUZ1bmNzKVxuICAgICAgICAgIGJhdGNoKEdMLCAnLmRlcHRoRnVuYygnLCBERVBUSF9GVU5DUywgJ1snLCBWQUxVRSwgJ10pOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdkZXB0aC5yYW5nZSc6XG4gICAgICAgICAgYmF0Y2goR0wsICcuZGVwdGhSYW5nZSgnLCBWQUxVRSwgJ1swXSwnLCBWQUxVRSwgJ1sxXSk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2JsZW5kLmNvbG9yJzpcbiAgICAgICAgICBiYXRjaChHTCwgJy5ibGVuZENvbG9yKCcsXG4gICAgICAgICAgICBWQUxVRSwgJ1swXSwnLFxuICAgICAgICAgICAgVkFMVUUsICdbMV0sJyxcbiAgICAgICAgICAgIFZBTFVFLCAnWzJdLCcsXG4gICAgICAgICAgICBWQUxVRSwgJ1szXSk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2JsZW5kLmVxdWF0aW9uJzpcbiAgICAgICAgICB2YXIgQkxFTkRfRVFVQVRJT05TID0gbGluayhibGVuZEVxdWF0aW9ucylcbiAgICAgICAgICBiYXRjaChcbiAgICAgICAgICAgICdpZih0eXBlb2YgJywgVkFMVUUsICc9PT1cInN0cmluZ1wiKXsnLFxuICAgICAgICAgICAgR0wsICcuYmxlbmRFcXVhdGlvbignLCBCTEVORF9FUVVBVElPTlMsICdbJywgVkFMVUUsICddKTsnLFxuICAgICAgICAgICAgJ31lbHNleycsXG4gICAgICAgICAgICBHTCwgJy5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoJyxcbiAgICAgICAgICAgIEJMRU5EX0VRVUFUSU9OUywgJ1snLCBWQUxVRSwgJy5yZ2JdLCcsXG4gICAgICAgICAgICBCTEVORF9FUVVBVElPTlMsICdbJywgVkFMVUUsICcuYWxwaGFdKTsnLFxuICAgICAgICAgICAgJ30nKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnYmxlbmQuZnVuYyc6XG4gICAgICAgICAgdmFyIEJMRU5EX0ZVTkNTID0gbGluayhibGVuZEZ1bmNzKVxuICAgICAgICAgIGJhdGNoKFxuICAgICAgICAgICAgR0wsICcuYmxlbmRGdW5jU2VwYXJhdGUoJyxcbiAgICAgICAgICAgIEJMRU5EX0ZVTkNTLFxuICAgICAgICAgICAgJ1tcInNyY1JHQlwiIGluICcsIFZBTFVFLCAnPycsIFZBTFVFLCAnLnNyY1JHQjonLCBWQUxVRSwgJy5zcmNdLCcsXG4gICAgICAgICAgICBCTEVORF9GVU5DUyxcbiAgICAgICAgICAgICdbXCJkc3RSR0JcIiBpbiAnLCBWQUxVRSwgJz8nLCBWQUxVRSwgJy5kc3RSR0I6JywgVkFMVUUsICcuZHN0XSwnLFxuICAgICAgICAgICAgQkxFTkRfRlVOQ1MsXG4gICAgICAgICAgICAnW1wic3JjQWxwaGFcIiBpbiAnLCBWQUxVRSwgJz8nLCBWQUxVRSwgJy5zcmNBbHBoYTonLCBWQUxVRSwgJy5zcmNdLCcsXG4gICAgICAgICAgICBCTEVORF9GVU5DUyxcbiAgICAgICAgICAgICdbXCJkc3RBbHBoYVwiIGluICcsIFZBTFVFLCAnPycsIFZBTFVFLCAnLmRzdEFscGhhOicsIFZBTFVFLCAnLmRzdF0pOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdzdGVuY2lsLm1hc2snOlxuICAgICAgICAgIGJhdGNoKEdMLCAnLnN0ZW5jaWxNYXNrKCcsIFZBTFVFLCAnKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnc3RlbmNpbC5mdW5jJzpcbiAgICAgICAgICB2YXIgU1RFTkNJTF9GVU5DUyA9IGxpbmsoY29tcGFyZUZ1bmNzKVxuICAgICAgICAgIGJhdGNoKEdMLCAnLnN0ZW5jaWxGdW5jKCcsXG4gICAgICAgICAgICBTVEVOQ0lMX0ZVTkNTLCAnWycsIFZBTFVFLCAnLmNtcHx8XCJhbHdheXNcIl0sJyxcbiAgICAgICAgICAgIFZBTFVFLCAnLnJlZnwwLCcsXG4gICAgICAgICAgICAnXCJtYXNrXCIgaW4gJywgVkFMVUUsICc/JywgVkFMVUUsICcubWFzazotMSk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3N0ZW5jaWwub3BGcm9udCc6XG4gICAgICAgIGNhc2UgJ3N0ZW5jaWwub3BCYWNrJzpcbiAgICAgICAgICB2YXIgU1RFTkNJTF9PUFMgPSBsaW5rKHN0ZW5jaWxPcHMpXG4gICAgICAgICAgYmF0Y2goR0wsICcuc3RlbmNpbE9wU2VwYXJhdGUoJyxcbiAgICAgICAgICAgIG9wdGlvbiA9PT0gJ3N0ZW5jaWwub3BGcm9udCcgPyBHTF9GUk9OVCA6IEdMX0JBQ0ssICcsJyxcbiAgICAgICAgICAgIFNURU5DSUxfT1BTLCAnWycsIFZBTFVFLCAnLmZhaWx8fFwia2VlcFwiXSwnLFxuICAgICAgICAgICAgU1RFTkNJTF9PUFMsICdbJywgVkFMVUUsICcuemZhaWx8fFwia2VlcFwiXSwnLFxuICAgICAgICAgICAgU1RFTkNJTF9PUFMsICdbJywgVkFMVUUsICcucGFzc3x8XCJrZWVwXCJdKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAncG9seWdvbk9mZnNldC5vZmZzZXQnOlxuICAgICAgICAgIGJhdGNoKEdMLCAnLnBvbHlnb25PZmZzZXQoJyxcbiAgICAgICAgICAgIFZBTFVFLCAnLmZhY3Rvcnx8MCwnLFxuICAgICAgICAgICAgVkFMVUUsICcudW5pdHN8fDApOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdjdWxsLmZhY2UnOlxuICAgICAgICAgIGJhdGNoKEdMLCAnLmN1bGxGYWNlKCcsXG4gICAgICAgICAgICBWQUxVRSwgJz09PVwiZnJvbnRcIj8nLCBHTF9GUk9OVCwgJzonLCBHTF9CQUNLLCAnKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnbGluZVdpZHRoJzpcbiAgICAgICAgICBiYXRjaChHTCwgJy5saW5lV2lkdGgoJywgVkFMVUUsICcpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdmcm9udEZhY2UnOlxuICAgICAgICAgIGJhdGNoKEdMLCAnLmZyb250RmFjZSgnLFxuICAgICAgICAgICAgVkFMVUUsICc9PT1cImN3XCI/JywgR0xfQ1csICc6JywgR0xfQ0NXLCAnKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnY29sb3JNYXNrJzpcbiAgICAgICAgICBiYXRjaChHTCwgJy5jb2xvck1hc2soJyxcbiAgICAgICAgICAgIFZBTFVFLCAnWzBdLCcsXG4gICAgICAgICAgICBWQUxVRSwgJ1sxXSwnLFxuICAgICAgICAgICAgVkFMVUUsICdbMl0sJyxcbiAgICAgICAgICAgIFZBTFVFLCAnWzNdKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnc2FtcGxlLmNvdmVyYWdlJzpcbiAgICAgICAgICBiYXRjaChHTCwgJy5zYW1wbGVDb3ZlcmFnZSgnLFxuICAgICAgICAgICAgVkFMVUUsICcudmFsdWUsJyxcbiAgICAgICAgICAgIFZBTFVFLCAnLmludmVydCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3NjaXNzb3IuYm94JzpcbiAgICAgICAgICB2YXIgU0NJU1NPUl9YID0gYmF0Y2guZGVmKFZBTFVFICsgJy54fHwwJylcbiAgICAgICAgICB2YXIgU0NJU1NPUl9ZID0gYmF0Y2guZGVmKFZBTFVFICsgJy55fHwwJylcbiAgICAgICAgICBiYXRjaChHTCwgJy5zY2lzc29yKCcsXG4gICAgICAgICAgICBTQ0lTU09SX1gsICcsJyxcbiAgICAgICAgICAgIFNDSVNTT1JfWSwgJywnLFxuICAgICAgICAgICAgJ1wid1wiIGluICcsIFZBTFVFLCAnPycsIFZBTFVFLCAnLnc6JywgR0wsICcuZHJhd2luZ0J1ZmZlcldpZHRoLScsIFNDSVNTT1JfWCwgJywnLFxuICAgICAgICAgICAgJ1wiaFwiIGluICcsIFZBTFVFLCAnPycsIFZBTFVFLCAnLmg6JywgR0wsICcuZHJhd2luZ0J1ZmZlckhlaWdodC0nLCBTQ0lTU09SX1ksICcpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICd2aWV3cG9ydCc6XG4gICAgICAgICAgdmFyIFZJRVdQT1JUX1ggPSBiYXRjaC5kZWYoVkFMVUUgKyAnLnh8fDAnKVxuICAgICAgICAgIHZhciBWSUVXUE9SVF9ZID0gYmF0Y2guZGVmKFZBTFVFICsgJy55fHwwJylcbiAgICAgICAgICBiYXRjaChHTCwgJy52aWV3cG9ydCgnLFxuICAgICAgICAgICAgVklFV1BPUlRfWCwgJywnLFxuICAgICAgICAgICAgVklFV1BPUlRfWSwgJywnLFxuICAgICAgICAgICAgJ1wid1wiIGluICcsIFZBTFVFLCAnPycsIFZBTFVFLCAnLnc6JywgR0wsICcuZHJhd2luZ0J1ZmZlcldpZHRoLScsIFZJRVdQT1JUX1gsICcsJyxcbiAgICAgICAgICAgICdcImhcIiBpbiAnLCBWQUxVRSwgJz8nLCBWQUxVRSwgJy5oOicsIEdMLCAnLmRyYXdpbmdCdWZmZXJIZWlnaHQtJywgVklFV1BPUlRfWSwgJyk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3ByaW1pdGl2ZXMnOlxuICAgICAgICBjYXNlICdvZmZzZXQnOlxuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgIGNhc2UgJ2VsZW1lbnRzJzpcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2hlY2sucmFpc2UoJ3Vuc3VwcG9ydGVkIG9wdGlvbiBmb3IgYmF0Y2gnLCBvcHRpb24pXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZXQgZHluYW1pYyB1bmlmb3Jtc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgcHJvZ3JhbVVuaWZvcm1zID0gcHJvZ3JhbS51bmlmb3Jtc1xuICAgIHZhciBEWU5BTUlDX1RFWFRVUkVTID0gW11cbiAgICBPYmplY3Qua2V5cyh1bmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAodW5pZm9ybSkge1xuICAgICAgdmFyIGRhdGEgPSBmaW5kSW5mbyhwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm0pXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgVFlQRSA9IGRhdGEuaW5mby50eXBlXG4gICAgICB2YXIgTE9DQVRJT04gPSBsaW5rKGRhdGEubG9jYXRpb24pXG4gICAgICB2YXIgVkFMVUUgPSBkeW4odW5pZm9ybXNbdW5pZm9ybV0pXG4gICAgICBpZiAodW5pZm9ybS5pbmZvLnR5cGUgPT09IEdMX1NBTVBMRVJfMkQgfHxcbiAgICAgICAgICB1bmlmb3JtLmluZm8udHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFKSB7XG4gICAgICAgIHZhciBURVhfVkFMVUUgPSBkZWYoVkFMVUUgKyAnLl90ZXh0dXJlJylcbiAgICAgICAgRFlOQU1JQ19URVhUVVJFUy5wdXNoKFRFWF9WQUxVRSlcbiAgICAgICAgYmF0Y2goc2V0VW5pZm9ybVN0cmluZyhHTCwgR0xfSU5ULCBMT0NBVElPTiwgVEVYX1ZBTFVFICsgJy5iaW5kKCknKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoKHNldFVuaWZvcm1TdHJpbmcoR0wsIFRZUEUsIExPQ0FUSU9OLCBWQUxVRSkpXG4gICAgICB9XG4gICAgfSlcbiAgICBEWU5BTUlDX1RFWFRVUkVTLmZvckVhY2goZnVuY3Rpb24gKFZBTFVFKSB7XG4gICAgICBiYXRjaChWQUxVRSwgJy51bmJpbmQoKTsnKVxuICAgIH0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc2V0IGR5bmFtaWMgYXR0cmlidXRlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXNcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBkYXRhID0gZmluZEluZm8ocHJvZ3JhbUF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSlcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGJhdGNoKEJJTkRfQVRUUklCVVRFLCAnKCcsXG4gICAgICAgIGRhdGEubG9jYXRpb24sICcsJyxcbiAgICAgICAgbGluayhhdHRyaWJ1dGUuYmluZGluZ3NbZGF0YS5sb2NhdGlvbl0pLCAnLCcsXG4gICAgICAgIGR5bihhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pLCAnLCcsXG4gICAgICAgIHR5cGVMZW5ndGgoZGF0YS5pbmZvLnR5cGUpLCAnKTsnKVxuICAgIH0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc2V0IGR5bmFtaWMgYXR0cmlidXRlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGlmIChvcHRpb25zLmNvdW50KSB7XG4gICAgICBiYXRjaChDVVJfQ09VTlQsICc9JywgZHluKG9wdGlvbnMuY291bnQpLCAnOycpXG4gICAgfSBlbHNlIGlmICghdXNlRWxlbWVudE9wdGlvbignY291bnQnKSkge1xuICAgICAgYmF0Y2goJ2lmKCcsIENVUl9DT1VOVCwgJyl7JylcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICBiYXRjaChDVVJfT0ZGU0VULCAnPScsIGR5bihvcHRpb25zLm9mZnNldCksICc7JylcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJpbWl0aXZlKSB7XG4gICAgICB2YXIgUFJJTV9UWVBFUyA9IGxpbmsocHJpbVR5cGVzKVxuICAgICAgYmF0Y2goQ1VSX1BSSU1JVElWRSwgJz0nLCBQUklNX1RZUEVTLCAnWycsIGR5bihvcHRpb25zLnByaW1pdGl2ZSksICddOycpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlRWxlbWVudE9wdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGhhc0R5bmFtaWNFbGVtZW50cyAmJiAhKHggaW4gb3B0aW9ucyB8fCB4IGluIHN0YXRpY09wdGlvbnMpXG4gICAgfVxuICAgIGlmIChoYXNEeW5hbWljRWxlbWVudHMpIHtcbiAgICAgIHZhciBkeW5FbGVtZW50cyA9IGR5bihvcHRpb25zLmVsZW1lbnRzKVxuICAgICAgYmF0Y2goQ1VSX0VMRU1FTlRTLCAnPScsXG4gICAgICAgIGR5bkVsZW1lbnRzLCAnPycsIGR5bkVsZW1lbnRzLCAnLl9lbGVtZW50czpudWxsOycpXG4gICAgfVxuICAgIGlmICh1c2VFbGVtZW50T3B0aW9uKCdvZmZzZXQnKSkge1xuICAgICAgYmF0Y2goQ1VSX09GRlNFVCwgJz0wOycpXG4gICAgfVxuXG4gICAgLy8gRW1pdCBkcmF3IGNvbW1hbmRcbiAgICBiYXRjaCgnaWYoJywgQ1VSX0VMRU1FTlRTLCAnKXsnKVxuICAgIGlmICh1c2VFbGVtZW50T3B0aW9uKCdjb3VudCcpKSB7XG4gICAgICBiYXRjaChDVVJfQ09VTlQsICc9JywgQ1VSX0VMRU1FTlRTLCAnLnZlcnRDb3VudDsnLFxuICAgICAgICAnaWYoJywgQ1VSX0NPVU5ULCAnPjApeycpXG4gICAgfVxuICAgIGlmICh1c2VFbGVtZW50T3B0aW9uKCdwcmltaXRpdmUnKSkge1xuICAgICAgYmF0Y2goQ1VSX1BSSU1JVElWRSwgJz0nLCBDVVJfRUxFTUVOVFMsICcucHJpbVR5cGU7JylcbiAgICB9XG4gICAgaWYgKGhhc0R5bmFtaWNFbGVtZW50cykge1xuICAgICAgYmF0Y2goXG4gICAgICAgIEdMLFxuICAgICAgICAnLmJpbmRCdWZmZXIoJyxcbiAgICAgICAgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIsICcsJyxcbiAgICAgICAgQ1VSX0VMRU1FTlRTLCAnLmJ1ZmZlci5fYnVmZmVyLmJ1ZmZlcik7JylcbiAgICB9XG4gICAgaWYgKGluc3RhbmNpbmcpIHtcbiAgICAgIGlmIChvcHRpb25zLmluc3RhbmNlcykge1xuICAgICAgICBiYXRjaChDVVJfSU5TVEFOQ0VTLCAnPScsIGR5bihvcHRpb25zLmluc3RhbmNlcyksICc7JylcbiAgICAgIH1cbiAgICAgIGJhdGNoKFxuICAgICAgICAnaWYoJywgQ1VSX0lOU1RBTkNFUywgJz4wKXsnLFxuICAgICAgICBJTlNUQU5DRV9FWFQsICcuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoJyxcbiAgICAgICAgQ1VSX1BSSU1JVElWRSwgJywnLFxuICAgICAgICBDVVJfQ09VTlQsICcsJyxcbiAgICAgICAgQ1VSX0VMRU1FTlRTLCAnLnR5cGUsJyxcbiAgICAgICAgQ1VSX09GRlNFVCwgJywnLFxuICAgICAgICBDVVJfSU5TVEFOQ0VTLCAnKTt9ZWxzZXsnKVxuICAgIH1cbiAgICBiYXRjaChcbiAgICAgIEdMLCAnLmRyYXdFbGVtZW50cygnLFxuICAgICAgQ1VSX1BSSU1JVElWRSwgJywnLFxuICAgICAgQ1VSX0NPVU5ULCAnLCcsXG4gICAgICBDVVJfRUxFTUVOVFMsICcudHlwZSwnLFxuICAgICAgQ1VSX09GRlNFVCwgJyk7JylcbiAgICBpZiAoaW5zdGFuY2luZykge1xuICAgICAgYmF0Y2goJ30nKVxuICAgIH1cbiAgICBpZiAodXNlRWxlbWVudE9wdGlvbignY291bnQnKSkge1xuICAgICAgYmF0Y2goJ30nKVxuICAgIH1cbiAgICBiYXRjaCgnfWVsc2V7JylcbiAgICBpZiAoIXVzZUVsZW1lbnRPcHRpb24oJ2NvdW50JykpIHtcbiAgICAgIGlmICh1c2VFbGVtZW50T3B0aW9uKCdwcmltaXRpdmUnKSkge1xuICAgICAgICBiYXRjaChDVVJfUFJJTUlUSVZFLCAnPScsIEdMX1RSSUFOR0xFUywgJzsnKVxuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNpbmcpIHtcbiAgICAgICAgYmF0Y2goXG4gICAgICAgICAgJ2lmKCcsIENVUl9JTlNUQU5DRVMsICc+MCl7JyxcbiAgICAgICAgICBJTlNUQU5DRV9FWFQsICcuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCcsXG4gICAgICAgICAgQ1VSX1BSSU1JVElWRSwgJywnLFxuICAgICAgICAgIENVUl9PRkZTRVQsICcsJyxcbiAgICAgICAgICBDVVJfQ09VTlQsICcsJyxcbiAgICAgICAgICBDVVJfSU5TVEFOQ0VTLCAnKTt9ZWxzZXsnKVxuICAgICAgfVxuICAgICAgYmF0Y2goXG4gICAgICAgIEdMLCAnLmRyYXdBcnJheXMoJyxcbiAgICAgICAgQ1VSX1BSSU1JVElWRSwgJywnLFxuICAgICAgICBDVVJfT0ZGU0VULCAnLCcsXG4gICAgICAgIENVUl9DT1VOVCwgJyk7fScpXG4gICAgICBpZiAoaW5zdGFuY2luZykge1xuICAgICAgICBiYXRjaCgnfScpXG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoKCd9fScsIGV4aXQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY29tcGlsZSBhbmQgcmV0dXJuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJldHVybiBlbnYuY29tcGlsZSgpLmJhdGNoXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIE1BSU4gRFJBVyBDT01NQU5EXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gY29tcGlsZUNvbW1hbmQgKFxuICAgIHN0YXRpY09wdGlvbnMsIHN0YXRpY1VuaWZvcm1zLCBzdGF0aWNBdHRyaWJ1dGVzLFxuICAgIGR5bmFtaWNPcHRpb25zLCBkeW5hbWljVW5pZm9ybXMsIGR5bmFtaWNBdHRyaWJ1dGVzLFxuICAgIGhhc0R5bmFtaWMpIHtcbiAgICAvLyBDcmVhdGUgY29kZSBnZW5lcmF0aW9uIGVudmlyb25tZW50XG4gICAgdmFyIGVudiA9IGNyZWF0ZUVudmlyb25tZW50KClcbiAgICB2YXIgbGluayA9IGVudi5saW5rXG4gICAgdmFyIGJsb2NrID0gZW52LmJsb2NrXG4gICAgdmFyIHByb2MgPSBlbnYucHJvY1xuXG4gICAgdmFyIGNhbGxJZCA9IGRyYXdDYWxsQ291bnRlcisrXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQ29tbW9uIHN0YXRlIHZhcmlhYmxlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgR0xfUE9MTCA9IGxpbmsoZ2xTdGF0ZS5wb2xsKVxuICAgIHZhciBGUkFHX1NIQURFUl9TVEFURSA9IGxpbmsoc2hhZGVyU3RhdGUuZnJhZ1NoYWRlcnMpXG4gICAgdmFyIFZFUlRfU0hBREVSX1NUQVRFID0gbGluayhzaGFkZXJTdGF0ZS52ZXJ0U2hhZGVycylcbiAgICB2YXIgUFJPR1JBTV9TVEFURSA9IGxpbmsoc2hhZGVyU3RhdGUucHJvZ3JhbXMpXG4gICAgdmFyIERSQVdfU1RBVEUgPSB7XG4gICAgICBjb3VudDogbGluayhkcmF3U3RhdGUuY291bnQpLFxuICAgICAgb2Zmc2V0OiBsaW5rKGRyYXdTdGF0ZS5vZmZzZXQpLFxuICAgICAgaW5zdGFuY2VzOiBsaW5rKGRyYXdTdGF0ZS5pbnN0YW5jZXMpLFxuICAgICAgcHJpbWl0aXZlOiBsaW5rKGRyYXdTdGF0ZS5wcmltaXRpdmUpXG4gICAgfVxuICAgIHZhciBFTEVNRU5UX1NUQVRFID0gbGluayhlbGVtZW50U3RhdGUuZWxlbWVudHMpXG4gICAgdmFyIFBSSU1fVFlQRVMgPSBsaW5rKHByaW1UeXBlcylcbiAgICB2YXIgQ09NUEFSRV9GVU5DUyA9IGxpbmsoY29tcGFyZUZ1bmNzKVxuICAgIHZhciBTVEVOQ0lMX09QUyA9IGxpbmsoc3RlbmNpbE9wcylcblxuICAgIHZhciBDT05URVhUX1NUQVRFID0ge31cbiAgICBmdW5jdGlvbiBsaW5rQ29udGV4dCAoeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IENPTlRFWFRfU1RBVEVbeF1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgcmVzdWx0ID0gQ09OVEVYVF9TVEFURVt4XSA9IGxpbmsoY29udGV4dFN0YXRlW3hdKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBTVEFUSUMgU1RBVEVcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQ29kZSBibG9ja3MgZm9yIHRoZSBzdGF0aWMgc2VjdGlvbnNcbiAgICB2YXIgZW50cnkgPSBibG9jaygpXG4gICAgdmFyIGV4aXQgPSBibG9jaygpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdXBkYXRlIGRlZmF1bHQgY29udGV4dCBzdGF0ZSB2YXJpYWJsZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RhdGljT3B0aW9uIChwYXJhbSwgdmFsdWUpIHtcbiAgICAgIHZhciBTVEFURV9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgZW50cnkoU1RBVEVfU1RBQ0ssICcucHVzaCgnLCB2YWx1ZSwgJyk7JylcbiAgICAgIGV4aXQoU1RBVEVfU1RBQ0ssICcucG9wKCk7JylcbiAgICB9XG5cbiAgICB2YXIgaGFzU2hhZGVyID0gZmFsc2VcbiAgICBPYmplY3Qua2V5cyhzdGF0aWNPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljT3B0aW9uc1twYXJhbV1cbiAgICAgIHN3aXRjaCAocGFyYW0pIHtcbiAgICAgICAgY2FzZSAnZnJhZyc6XG4gICAgICAgICAgaGFzU2hhZGVyID0gdHJ1ZVxuICAgICAgICAgIGVudHJ5KEZSQUdfU0hBREVSX1NUQVRFLCAnLnB1c2goJywgbGluayh2YWx1ZSksICcpOycpXG4gICAgICAgICAgZXhpdChGUkFHX1NIQURFUl9TVEFURSwgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAndmVydCc6XG4gICAgICAgICAgaGFzU2hhZGVyID0gdHJ1ZVxuICAgICAgICAgIGVudHJ5KFZFUlRfU0hBREVSX1NUQVRFLCAnLnB1c2goJywgbGluayh2YWx1ZSksICcpOycpXG4gICAgICAgICAgZXhpdChWRVJUX1NIQURFUl9TVEFURSwgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgLy8gVXBkYXRlIGRyYXcgc3RhdGVcbiAgICAgICAgY2FzZSAnY291bnQnOlxuICAgICAgICBjYXNlICdvZmZzZXQnOlxuICAgICAgICBjYXNlICdpbnN0YW5jZXMnOlxuICAgICAgICAgIGNoZWNrLm5uaSh2YWx1ZSwgcGFyYW0pXG4gICAgICAgICAgZW50cnkoRFJBV19TVEFURVtwYXJhbV0sICcucHVzaCgnLCB2YWx1ZSwgJyk7JylcbiAgICAgICAgICBleGl0KERSQVdfU1RBVEVbcGFyYW1dLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICAvLyBVcGRhdGUgcHJpbWl0aXZlIHR5cGVcbiAgICAgICAgY2FzZSAncHJpbWl0aXZlJzpcbiAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIodmFsdWUsIHByaW1UeXBlcywgJ25vdCBhIHZhbGlkIGRyYXdpbmcgcHJpbWl0aXZlJylcbiAgICAgICAgICB2YXIgcHJpbVR5cGUgPSBwcmltVHlwZXNbdmFsdWVdXG4gICAgICAgICAgZW50cnkoRFJBV19TVEFURS5wcmltaXRpdmUsICcucHVzaCgnLCBwcmltVHlwZSwgJyk7JylcbiAgICAgICAgICBleGl0KERSQVdfU1RBVEUucHJpbWl0aXZlLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICAvLyBVcGRhdGUgZWxlbWVudCBidWZmZXJcbiAgICAgICAgY2FzZSAnZWxlbWVudHMnOlxuICAgICAgICAgIHZhciBlbGVtZW50cyA9IGVsZW1lbnRTdGF0ZS5nZXRFbGVtZW50cyh2YWx1ZSlcbiAgICAgICAgICB2YXIgaGFzUHJpbWl0aXZlID0gISgncHJpbWl0aXZlJyBpbiBzdGF0aWNPcHRpb25zKVxuICAgICAgICAgIHZhciBoYXNDb3VudCA9ICEoJ2NvdW50JyBpbiBzdGF0aWNPcHRpb25zKVxuICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgdmFyIEVMRU1FTlRTID0gbGluayhlbGVtZW50cylcbiAgICAgICAgICAgIGVudHJ5KEVMRU1FTlRfU1RBVEUsICcucHVzaCgnLCBFTEVNRU5UUywgJyk7JylcbiAgICAgICAgICAgIGlmIChoYXNQcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgZW50cnkoRFJBV19TVEFURS5wcmltaXRpdmUsICcucHVzaCgnLCBFTEVNRU5UUywgJy5wcmltVHlwZSk7JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDb3VudCkge1xuICAgICAgICAgICAgICBlbnRyeShEUkFXX1NUQVRFLmNvdW50LCAnLnB1c2goJywgRUxFTUVOVFMsICcudmVydENvdW50KTsnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyeShFTEVNRU5UX1NUQVRFLCAnLnB1c2gobnVsbCk7JylcbiAgICAgICAgICAgIGlmIChoYXNQcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgZW50cnkoRFJBV19TVEFURS5wcmltaXRpdmUsICcucHVzaCgnLCBHTF9UUklBTkdMRVMsICcpOycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ291bnQpIHtcbiAgICAgICAgICAgICAgZW50cnkoRFJBV19TVEFURS5jb3VudCwgJy5wdXNoKDApOycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNQcmltaXRpdmUpIHtcbiAgICAgICAgICAgIGV4aXQoRFJBV19TVEFURS5wcmltaXRpdmUsICcucG9wKCk7JylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc0NvdW50KSB7XG4gICAgICAgICAgICBleGl0KERSQVdfU1RBVEUuY291bnQsICcucG9wKCk7JylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoJ29mZnNldCcgaW4gc3RhdGljT3B0aW9ucykpIHtcbiAgICAgICAgICAgIGVudHJ5KERSQVdfU1RBVEUub2Zmc2V0LCAnLnB1c2goMCk7JylcbiAgICAgICAgICAgIGV4aXQoRFJBV19TVEFURS5vZmZzZXQsICcucG9wKCk7JylcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhpdChFTEVNRU5UX1NUQVRFLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdjdWxsLmVuYWJsZSc6XG4gICAgICAgIGNhc2UgJ2JsZW5kLmVuYWJsZSc6XG4gICAgICAgIGNhc2UgJ2RpdGhlcic6XG4gICAgICAgIGNhc2UgJ3N0ZW5jaWwuZW5hYmxlJzpcbiAgICAgICAgY2FzZSAnZGVwdGguZW5hYmxlJzpcbiAgICAgICAgY2FzZSAnc2Npc3Nvci5lbmFibGUnOlxuICAgICAgICBjYXNlICdwb2x5Z29uT2Zmc2V0LmVuYWJsZSc6XG4gICAgICAgIGNhc2UgJ3NhbXBsZS5hbHBoYSc6XG4gICAgICAgIGNhc2UgJ3NhbXBsZS5lbmFibGUnOlxuICAgICAgICBjYXNlICdkZXB0aC5tYXNrJzpcbiAgICAgICAgICBjaGVjay50eXBlKHZhbHVlLCAnYm9vbGVhbicsIHBhcmFtKVxuICAgICAgICAgIGhhbmRsZVN0YXRpY09wdGlvbihwYXJhbSwgdmFsdWUpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdkZXB0aC5mdW5jJzpcbiAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIodmFsdWUsIGNvbXBhcmVGdW5jcywgcGFyYW0pXG4gICAgICAgICAgaGFuZGxlU3RhdGljT3B0aW9uKHBhcmFtLCBjb21wYXJlRnVuY3NbdmFsdWVdKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnZGVwdGgucmFuZ2UnOlxuICAgICAgICAgIGNoZWNrKFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgdmFsdWVbMF0gPD0gdmFsdWVbMV0sXG4gICAgICAgICAgICAnZGVwdGggcmFuZ2UgaXMgMmQgYXJyYXknKVxuICAgICAgICAgIHZhciBERVBUSF9SQU5HRV9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGVudHJ5KERFUFRIX1JBTkdFX1NUQUNLLCAnLnB1c2goJywgdmFsdWVbMF0sICcsJywgdmFsdWVbMV0sICcpOycpXG4gICAgICAgICAgZXhpdChERVBUSF9SQU5HRV9TVEFDSywgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnYmxlbmQuZnVuYyc6XG4gICAgICAgICAgdmFyIEJMRU5EX0ZVTkNfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBjaGVjay50eXBlKHZhbHVlLCAnb2JqZWN0JywgJ2JsZW5kIGZ1bmMgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgICAgICAgIHZhciBzcmNSR0IgPSAoJ3NyY1JHQicgaW4gdmFsdWUgPyB2YWx1ZS5zcmNSR0IgOiB2YWx1ZS5zcmMpXG4gICAgICAgICAgdmFyIHNyY0FscGhhID0gKCdzcmNBbHBoYScgaW4gdmFsdWUgPyB2YWx1ZS5zcmNBbHBoYSA6IHZhbHVlLnNyYylcbiAgICAgICAgICB2YXIgZHN0UkdCID0gKCdkc3RSR0InIGluIHZhbHVlID8gdmFsdWUuZHN0UkdCIDogdmFsdWUuZHN0KVxuICAgICAgICAgIHZhciBkc3RBbHBoYSA9ICgnZHN0QWxwaGEnIGluIHZhbHVlID8gdmFsdWUuZHN0QWxwaGEgOiB2YWx1ZS5kc3QpXG4gICAgICAgICAgY2hlY2sucGFyYW1ldGVyKHNyY1JHQiwgYmxlbmRGdW5jcylcbiAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIoc3JjQWxwaGEsIGJsZW5kRnVuY3MpXG4gICAgICAgICAgY2hlY2sucGFyYW1ldGVyKGRzdFJHQiwgYmxlbmRGdW5jcylcbiAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIoZHN0QWxwaGEsIGJsZW5kRnVuY3MpXG4gICAgICAgICAgZW50cnkoQkxFTkRfRlVOQ19TVEFDSywgJy5wdXNoKCcsXG4gICAgICAgICAgICBibGVuZEZ1bmNzW3NyY1JHQl0sICcsJyxcbiAgICAgICAgICAgIGJsZW5kRnVuY3NbZHN0UkdCXSwgJywnLFxuICAgICAgICAgICAgYmxlbmRGdW5jc1tzcmNBbHBoYV0sICcsJyxcbiAgICAgICAgICAgIGJsZW5kRnVuY3NbZHN0QWxwaGFdLCAnKTsnKVxuICAgICAgICAgIGV4aXQoQkxFTkRfRlVOQ19TVEFDSywgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnYmxlbmQuZXF1YXRpb24nOlxuICAgICAgICAgIHZhciBCTEVORF9FUVVBVElPTl9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIodmFsdWUsIGJsZW5kRXF1YXRpb25zLCAnaW52YWxpZCBibGVuZCBlcXVhdGlvbicpXG4gICAgICAgICAgICBlbnRyeShCTEVORF9FUVVBVElPTl9TVEFDSyxcbiAgICAgICAgICAgICAgJy5wdXNoKCcsXG4gICAgICAgICAgICAgIGJsZW5kRXF1YXRpb25zW3ZhbHVlXSwgJywnLFxuICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV0sICcpOycpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIHZhbHVlLnJnYiwgYmxlbmRFcXVhdGlvbnMsICdpbnZhbGlkIGJsZW5kIGVxdWF0aW9uIHJnYicpXG4gICAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIHZhbHVlLmFscGhhLCBibGVuZEVxdWF0aW9ucywgJ2ludmFsaWQgYmxlbmQgZXF1YXRpb24gYWxwaGEnKVxuICAgICAgICAgICAgZW50cnkoQkxFTkRfRVFVQVRJT05fU1RBQ0ssXG4gICAgICAgICAgICAgICcucHVzaCgnLFxuICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZS5yZ2JdLCAnLCcsXG4gICAgICAgICAgICAgIGJsZW5kRXF1YXRpb25zW3ZhbHVlLmFscGhhXSwgJyk7JylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2sucmFpc2UoJ2ludmFsaWQgYmxlbmQgZXF1YXRpb24nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleGl0KEJMRU5EX0VRVUFUSU9OX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdibGVuZC5jb2xvcic6XG4gICAgICAgICAgY2hlY2soXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgJ2JsZW5kIGNvbG9yIGlzIGEgNGQgYXJyYXknKVxuICAgICAgICAgIHZhciBCTEVORF9DT0xPUl9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGVudHJ5KEJMRU5EX0NPTE9SX1NUQUNLLFxuICAgICAgICAgICAgJy5wdXNoKCcsXG4gICAgICAgICAgICB2YWx1ZVswXSwgJywnLFxuICAgICAgICAgICAgdmFsdWVbMV0sICcsJyxcbiAgICAgICAgICAgIHZhbHVlWzJdLCAnLCcsXG4gICAgICAgICAgICB2YWx1ZVszXSwgJyk7JylcbiAgICAgICAgICBleGl0KEJMRU5EX0NPTE9SX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdzdGVuY2lsLm1hc2snOlxuICAgICAgICAgIGNoZWNrLnR5cGUodmFsdWUsICdudW1iZXInLCAnc3RlbmNpbCBtYXNrIG11c3QgYmUgYW4gaW50ZWdlcicpXG4gICAgICAgICAgdmFyIFNURU5DSUxfTUFTS19TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGVudHJ5KFNURU5DSUxfTUFTS19TVEFDSywgJy5wdXNoKCcsIHZhbHVlLCAnKTsnKVxuICAgICAgICAgIGV4aXQoU1RFTkNJTF9NQVNLX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdzdGVuY2lsLmZ1bmMnOlxuICAgICAgICAgIGNoZWNrLnR5cGUodmFsdWUsICdvYmplY3QnLCAnc3RlbmNpbCBmdW5jIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICAgICAgICB2YXIgY21wID0gdmFsdWUuY21wIHx8ICdrZWVwJ1xuICAgICAgICAgIHZhciByZWYgPSB2YWx1ZS5yZWYgfHwgMFxuICAgICAgICAgIHZhciBtYXNrID0gJ21hc2snIGluIHZhbHVlID8gdmFsdWUubWFzayA6IC0xXG4gICAgICAgICAgY2hlY2sucGFyYW1ldGVyKGNtcCwgY29tcGFyZUZ1bmNzLCAnaW52YWxpZCBzdGVuY2lsIGZ1bmMgY21wJylcbiAgICAgICAgICBjaGVjay50eXBlKHJlZiwgJ251bWJlcicsICdzdGVuY2lsIGZ1bmMgcmVmJylcbiAgICAgICAgICBjaGVjay50eXBlKG1hc2ssICdudW1iZXInLCAnc3RlbmNpbCBmdW5jIG1hc2snKVxuICAgICAgICAgIHZhciBTVEVOQ0lMX0ZVTkNfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBlbnRyeShTVEVOQ0lMX0ZVTkNfU1RBQ0ssICcucHVzaCgnLFxuICAgICAgICAgICAgY29tcGFyZUZ1bmNzW2NtcF0sICcsJyxcbiAgICAgICAgICAgIHJlZiwgJywnLFxuICAgICAgICAgICAgbWFzaywgJyk7JylcbiAgICAgICAgICBleGl0KFNURU5DSUxfRlVOQ19TVEFDSywgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnc3RlbmNpbC5vcEZyb250JzpcbiAgICAgICAgY2FzZSAnc3RlbmNpbC5vcEJhY2snOlxuICAgICAgICAgIGNoZWNrLnR5cGUodmFsdWUsICdvYmplY3QnLCBwYXJhbSlcbiAgICAgICAgICB2YXIgZmFpbCA9IHZhbHVlLmZhaWwgfHwgJ2tlZXAnXG4gICAgICAgICAgdmFyIHpmYWlsID0gdmFsdWUuemZhaWwgfHwgJ2tlZXAnXG4gICAgICAgICAgdmFyIHBhc3MgPSB2YWx1ZS5wYXNzIHx8ICdrZWVwJ1xuICAgICAgICAgIGNoZWNrLnBhcmFtZXRlcihmYWlsLCBzdGVuY2lsT3BzLCBwYXJhbSlcbiAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIoemZhaWwsIHN0ZW5jaWxPcHMsIHBhcmFtKVxuICAgICAgICAgIGNoZWNrLnBhcmFtZXRlcihwYXNzLCBzdGVuY2lsT3BzLCBwYXJhbSlcbiAgICAgICAgICB2YXIgU1RFTkNJTF9PUF9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGVudHJ5KFNURU5DSUxfT1BfU1RBQ0ssICcucHVzaCgnLFxuICAgICAgICAgICAgc3RlbmNpbE9wc1tmYWlsXSwgJywnLFxuICAgICAgICAgICAgc3RlbmNpbE9wc1t6ZmFpbF0sICcsJyxcbiAgICAgICAgICAgIHN0ZW5jaWxPcHNbcGFzc10sICcpOycpXG4gICAgICAgICAgZXhpdChTVEVOQ0lMX09QX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdwb2x5Z29uT2Zmc2V0Lm9mZnNldCc6XG4gICAgICAgICAgY2hlY2sudHlwZSh2YWx1ZSwgJ29iamVjdCcsIHBhcmFtKVxuICAgICAgICAgIHZhciBmYWN0b3IgPSB2YWx1ZS5mYWN0b3IgfHwgMFxuICAgICAgICAgIHZhciB1bml0cyA9IHZhbHVlLnVuaXRzIHx8IDBcbiAgICAgICAgICBjaGVjay50eXBlKGZhY3RvciwgJ251bWJlcicsICdvZmZzZXQuZmFjdG9yJylcbiAgICAgICAgICBjaGVjay50eXBlKHVuaXRzLCAnbnVtYmVyJywgJ29mZnNldC51bml0cycpXG4gICAgICAgICAgdmFyIFBPTFlHT05fT0ZGU0VUX1NUQUNLID0gbGlua0NvbnRleHQocGFyYW0pXG4gICAgICAgICAgZW50cnkoUE9MWUdPTl9PRkZTRVRfU1RBQ0ssICcucHVzaCgnLFxuICAgICAgICAgICAgZmFjdG9yLCAnLCcsIHVuaXRzLCAnKTsnKVxuICAgICAgICAgIGV4aXQoUE9MWUdPTl9PRkZTRVRfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2N1bGwuZmFjZSc6XG4gICAgICAgICAgdmFyIGZhY2UgPSAwXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnZnJvbnQnKSB7XG4gICAgICAgICAgICBmYWNlID0gR0xfRlJPTlRcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnYmFjaycpIHtcbiAgICAgICAgICAgIGZhY2UgPSBHTF9CQUNLXG4gICAgICAgICAgfVxuICAgICAgICAgIGNoZWNrKCEhZmFjZSwgJ2N1bGwuZmFjZScpXG4gICAgICAgICAgdmFyIENVTExfRkFDRV9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGVudHJ5KENVTExfRkFDRV9TVEFDSywgJy5wdXNoKCcsIGZhY2UsICcpOycpXG4gICAgICAgICAgZXhpdChDVUxMX0ZBQ0VfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2xpbmVXaWR0aCc6XG4gICAgICAgICAgY2hlY2sodmFsdWUgPiAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsIHBhcmFtKVxuICAgICAgICAgIGhhbmRsZVN0YXRpY09wdGlvbihwYXJhbSwgdmFsdWUpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdmcm9udEZhY2UnOlxuICAgICAgICAgIHZhciBvcmllbnRhdGlvbiA9IDBcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICdjdycpIHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gR0xfQ1dcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnY2N3Jykge1xuICAgICAgICAgICAgb3JpZW50YXRpb24gPSBHTF9DQ1dcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hlY2soISFvcmllbnRhdGlvbiwgJ2Zyb250RmFjZScpXG4gICAgICAgICAgdmFyIEZST05UX0ZBQ0VfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBlbnRyeShGUk9OVF9GQUNFX1NUQUNLLCAnLnB1c2goJywgb3JpZW50YXRpb24sICcpOycpXG4gICAgICAgICAgZXhpdChGUk9OVF9GQUNFX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdjb2xvck1hc2snOlxuICAgICAgICAgIGNoZWNrKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCwgJ2NvbG9yIG1hc2sgbXVzdCBiZSBsZW5ndGggNCBhcnJheScpXG4gICAgICAgICAgdmFyIENPTE9SX01BU0tfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBlbnRyeShDT0xPUl9NQVNLX1NUQUNLLCAnLnB1c2goJyxcbiAgICAgICAgICAgIHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gISF2IH0pLmpvaW4oKSxcbiAgICAgICAgICAgICcpOycpXG4gICAgICAgICAgZXhpdChDT0xPUl9NQVNLX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdzYW1wbGUuY292ZXJhZ2UnOlxuICAgICAgICAgIGNoZWNrLnR5cGUodmFsdWUsICdvYmplY3QnLCBwYXJhbSlcbiAgICAgICAgICB2YXIgc2FtcGxlVmFsdWUgPSAndmFsdWUnIGluIHZhbHVlID8gdmFsdWUudmFsdWUgOiAxXG4gICAgICAgICAgdmFyIHNhbXBsZUludmVydCA9ICEhdmFsdWUuaW52ZXJ0XG4gICAgICAgICAgY2hlY2soXG4gICAgICAgICAgICB0eXBlb2Ygc2FtcGxlVmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBzYW1wbGVWYWx1ZSA+PSAwICYmIHNhbXBsZVZhbHVlIDw9IDEsXG4gICAgICAgICAgICAnc2FtcGxlIHZhbHVlJylcbiAgICAgICAgICB2YXIgU0FNUExFX0NPVkVSQUdFX1NUQUNLID0gbGlua0NvbnRleHQocGFyYW0pXG4gICAgICAgICAgZW50cnkoU0FNUExFX0NPVkVSQUdFX1NUQUNLLCAnLnB1c2goJyxcbiAgICAgICAgICAgIHNhbXBsZVZhbHVlLCAnLCcsIHNhbXBsZUludmVydCwgJyk7JylcbiAgICAgICAgICBleGl0KFNBTVBMRV9DT1ZFUkFHRV9TVEFDSywgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAndmlld3BvcnQnOlxuICAgICAgICBjYXNlICdzY2lzc29yLmJveCc6XG4gICAgICAgICAgY2hlY2sodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSwgcGFyYW0gKyAnIGlzIGFuIG9iamVjdCcpXG4gICAgICAgICAgdmFyIFggPSB2YWx1ZS54IHx8IDBcbiAgICAgICAgICB2YXIgWSA9IHZhbHVlLnkgfHwgMFxuICAgICAgICAgIHZhciBXID0gLTFcbiAgICAgICAgICB2YXIgSCA9IC0xXG4gICAgICAgICAgY2hlY2sodHlwZW9mIFggPT09ICdudW1iZXInICYmIFggPj0gMCwgcGFyYW0gKyAnLnggbXVzdCBiZSBhIHBvc2l0aXZlIGludCcpXG4gICAgICAgICAgY2hlY2sodHlwZW9mIFkgPT09ICdudW1iZXInICYmIFkgPj0gMCwgcGFyYW0gKyAnLnkgbXVzdCBiZSBhIHBvc2l0aXZlIGludCcpXG4gICAgICAgICAgaWYgKCd3JyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgVyA9IHZhbHVlLndcbiAgICAgICAgICAgIGNoZWNrKHR5cGVvZiBXID09PSAnbnVtYmVyJyAmJiBXID49IDAsIHBhcmFtICsgJy53IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2gnIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBIID0gdmFsdWUuaFxuICAgICAgICAgICAgY2hlY2sodHlwZW9mIEggPT09ICdudW1iZXInICYmIEggPj0gMCwgcGFyYW0gKyAnLmggbXVzdCBiZSBhIHBvc2l0aXZlIGludCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBCT1hfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBlbnRyeShCT1hfU1RBQ0ssICcucHVzaCgnLCBYLCAnLCcsIFksICcsJywgVywgJywnLCBILCAnKTsnKVxuICAgICAgICAgIGV4aXQoQk9YX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRPRE8gU2hvdWxkIHRoaXMganVzdCBiZSBhIHdhcm5pbmcgaW5zdGVhZD9cbiAgICAgICAgICBjaGVjay5yYWlzZSgndW5zdXBwb3J0ZWQgcGFyYW1ldGVyICcgKyBwYXJhbSlcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdXBkYXRlIHNoYWRlciBwcm9ncmFtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlmIChoYXNTaGFkZXIpIHtcbiAgICAgIGlmIChzdGF0aWNPcHRpb25zLmZyYWcgJiYgc3RhdGljT3B0aW9ucy52ZXJ0KSB7XG4gICAgICAgIHZhciBmcmFnU3JjID0gc3RhdGljT3B0aW9ucy5mcmFnXG4gICAgICAgIHZhciB2ZXJ0U3JjID0gc3RhdGljT3B0aW9ucy52ZXJ0XG4gICAgICAgIGVudHJ5KFBST0dSQU1fU1RBVEUsICcucHVzaCgnLFxuICAgICAgICAgIGxpbmsoc2hhZGVyU3RhdGUuY3JlYXRlKHZlcnRTcmMsIGZyYWdTcmMpKSwgJyk7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBGUkFHX1NSQyA9IGVudHJ5LmRlZihcbiAgICAgICAgICBGUkFHX1NIQURFUl9TVEFURSwgJ1snLCBGUkFHX1NIQURFUl9TVEFURSwgJy5sZW5ndGgtMV0nKVxuICAgICAgICB2YXIgVkVSVF9TUkMgPSBlbnRyeS5kZWYoXG4gICAgICAgICAgVkVSVF9TSEFERVJfU1RBVEUsICdbJywgVkVSVF9TSEFERVJfU1RBVEUsICcubGVuZ3RoLTFdJylcbiAgICAgICAgdmFyIExJTktfUFJPRyA9IGxpbmsoc2hhZGVyU3RhdGUuY3JlYXRlKVxuICAgICAgICBlbnRyeShcbiAgICAgICAgICBQUk9HUkFNX1NUQVRFLCAnLnB1c2goJyxcbiAgICAgICAgICBMSU5LX1BST0csICcoJywgRlJBR19TUkMsICcsJywgVkVSVF9TUkMsICcpKTsnKVxuICAgICAgfVxuICAgICAgZXhpdChQUk9HUkFNX1NUQVRFLCAnLnBvcCgpOycpXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHVwZGF0ZSBzdGF0aWMgdW5pZm9ybXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgT2JqZWN0LmtleXMoc3RhdGljVW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKHVuaWZvcm0pIHtcbiAgICAgIHVuaWZvcm1TdGF0ZS5kZWYodW5pZm9ybSlcbiAgICAgIHZhciBTVEFDSyA9IGxpbmsodW5pZm9ybVN0YXRlLnVuaWZvcm1zW3VuaWZvcm1dKVxuICAgICAgdmFyIFZBTFVFXG4gICAgICB2YXIgdmFsdWUgPSBzdGF0aWNVbmlmb3Jtc1t1bmlmb3JtXVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS5fcmVnbFR5cGUpIHtcbiAgICAgICAgVkFMVUUgPSBsaW5rKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBWQUxVRSA9IGxpbmsodmFsdWUuc2xpY2UoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFZBTFVFID0gK3ZhbHVlXG4gICAgICB9XG4gICAgICBlbnRyeShTVEFDSywgJy5wdXNoKCcsIFZBTFVFLCAnKTsnKVxuICAgICAgZXhpdChTVEFDSywgJy5wb3AoKTsnKVxuICAgIH0pXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdXBkYXRlIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBPYmplY3Qua2V5cyhzdGF0aWNBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgIGF0dHJpYnV0ZVN0YXRlLmRlZihhdHRyaWJ1dGUpXG4gICAgICB2YXIgQVRUUklCVVRFID0gbGluayhhdHRyaWJ1dGVTdGF0ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pXG5cbiAgICAgIHZhciBkYXRhID0gc3RhdGljQXR0cmlidXRlc1thdHRyaWJ1dGVdXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVudHJ5KEFUVFJJQlVURSwgJy5wdXNoVmVjKCcsICtkYXRhLCAnLDAsMCwwKTsnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2soISFkYXRhLCAnaW52YWxpZCBhdHRyaWJ1dGU6ICcgKyBhdHRyaWJ1dGUpXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICBlbnRyeShcbiAgICAgICAgICAgIEFUVFJJQlVURSwgJy5wdXNoVmVjKCcsXG4gICAgICAgICAgICBbZGF0YVswXSB8fCAwLCBkYXRhWzFdIHx8IDAsIGRhdGFbMl0gfHwgMCwgZGF0YVszXSB8fCAwXSwgJyk7JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKGRhdGEpXG4gICAgICAgICAgdmFyIHNpemUgPSAwXG4gICAgICAgICAgdmFyIHN0cmlkZSA9IDBcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMFxuICAgICAgICAgIHZhciBkaXZpc29yID0gMFxuICAgICAgICAgIHZhciBub3JtYWxpemVkID0gZmFsc2VcbiAgICAgICAgICB2YXIgdHlwZSA9IEdMX0ZMT0FUXG5cbiAgICAgICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICAgICAgY2hlY2sudHlwZShkYXRhLCAnb2JqZWN0JywgJ2ludmFsaWQgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicpXG5cbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihkYXRhLmJ1ZmZlcilcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemUgfHwgMFxuICAgICAgICAgICAgc3RyaWRlID0gZGF0YS5zdHJpZGUgfHwgMFxuICAgICAgICAgICAgb2Zmc2V0ID0gZGF0YS5vZmZzZXQgfHwgMFxuICAgICAgICAgICAgZGl2aXNvciA9IGRhdGEuZGl2aXNvciB8fCAwXG4gICAgICAgICAgICBub3JtYWxpemVkID0gZGF0YS5ub3JtYWxpemVkIHx8IGZhbHNlXG5cbiAgICAgICAgICAgIGNoZWNrKCEhYnVmZmVyLCAnaW52YWxpZCBhdHRyaWJ1dGUgJyArIGF0dHJpYnV0ZSArICcuYnVmZmVyJylcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHVzZXIgZGVmaW5lZCB0eXBlIG92ZXJsb2FkaW5nXG4gICAgICAgICAgICB0eXBlID0gYnVmZmVyLmR0eXBlXG4gICAgICAgICAgICBpZiAoJ3R5cGUnIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgY2hlY2sucGFyYW1ldGVyKGRhdGEudHlwZSwgZ2xUeXBlcywgJ2F0dHJpYnV0ZSB0eXBlJylcbiAgICAgICAgICAgICAgdHlwZSA9IGdsVHlwZXNbZGF0YS50eXBlXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gYnVmZmVyLmR0eXBlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hlY2soISFidWZmZXIsICdpbnZhbGlkIGF0dHJpYnV0ZSAnICsgYXR0cmlidXRlICsgJy5idWZmZXInKVxuICAgICAgICAgIGNoZWNrLm5uaShzdHJpZGUsIGF0dHJpYnV0ZSArICcuc3RyaWRlJylcbiAgICAgICAgICBjaGVjay5ubmkob2Zmc2V0LCBhdHRyaWJ1dGUgKyAnLm9mZnNldCcpXG4gICAgICAgICAgY2hlY2subm5pKGRpdmlzb3IsIGF0dHJpYnV0ZSArICcuZGl2aXNvcicpXG4gICAgICAgICAgY2hlY2sudHlwZShub3JtYWxpemVkLCAnYm9vbGVhbicsIGF0dHJpYnV0ZSArICcubm9ybWFsaXplZCcpXG4gICAgICAgICAgY2hlY2sub25lT2Yoc2l6ZSwgWzAsIDEsIDIsIDMsIDRdLCBhdHRyaWJ1dGUgKyAnLnNpemUnKVxuXG4gICAgICAgICAgZW50cnkoXG4gICAgICAgICAgICBBVFRSSUJVVEUsICcucHVzaFB0cignLCBbXG4gICAgICAgICAgICAgIGxpbmsoYnVmZmVyKSwgc2l6ZSwgb2Zmc2V0LCBzdHJpZGUsXG4gICAgICAgICAgICAgIGRpdmlzb3IsIG5vcm1hbGl6ZWQsIHR5cGVcbiAgICAgICAgICAgIF0uam9pbigpLCAnKTsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGl0KEFUVFJJQlVURSwgJy5wb3AoKTsnKVxuICAgIH0pXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRFlOQU1JQyBTVEFURSAoZm9yIHNjb3BlIGFuZCBkcmF3KVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBHZW5lcmF0ZWQgY29kZSBibG9ja3MgZm9yIGR5bmFtaWMgc3RhdGUgZmxhZ3NcbiAgICB2YXIgZHluYW1pY0VudHJ5ID0gZW52LmJsb2NrKClcbiAgICB2YXIgZHluYW1pY0V4aXQgPSBlbnYuYmxvY2soKVxuXG4gICAgdmFyIEZSQU1FU1RBVEVcbiAgICB2YXIgRFlOQVJHU1xuICAgIGlmIChoYXNEeW5hbWljKSB7XG4gICAgICBGUkFNRVNUQVRFID0gbGluayhmcmFtZVN0YXRlKVxuICAgICAgRFlOQVJHUyA9IGVudHJ5LmRlZigpXG4gICAgfVxuXG4gICAgdmFyIGR5bmFtaWNWYXJzID0ge31cbiAgICBmdW5jdGlvbiBkeW4gKHgpIHtcbiAgICAgIHZhciBpZCA9IHguaWRcbiAgICAgIHZhciByZXN1bHQgPSBkeW5hbWljVmFyc1tpZF1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgaWYgKHguZnVuYykge1xuICAgICAgICByZXN1bHQgPSBkeW5hbWljRW50cnkuZGVmKFxuICAgICAgICAgIGxpbmsoeC5kYXRhKSwgJygnLCBEWU5BUkdTLCAnLDAsJywgRlJBTUVTVEFURSwgJyknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZHluYW1pY0VudHJ5LmRlZihEWU5BUkdTLCAnLicsIHguZGF0YSlcbiAgICAgIH1cbiAgICAgIGR5bmFtaWNWYXJzW2lkXSA9IHJlc3VsdFxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBkeW5hbWljIGNvbnRleHQgc3RhdGUgdmFyaWFibGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIE9iamVjdC5rZXlzKGR5bmFtaWNPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgLy8gTGluayBpbiBkeW5hbWljIHZhcmlhYmxlXG4gICAgICB2YXIgdmFyaWFibGUgPSBkeW4oZHluYW1pY09wdGlvbnNbcGFyYW1dKVxuXG4gICAgICBzd2l0Y2ggKHBhcmFtKSB7XG4gICAgICAgIGNhc2UgJ2N1bGwuZW5hYmxlJzpcbiAgICAgICAgY2FzZSAnYmxlbmQuZW5hYmxlJzpcbiAgICAgICAgY2FzZSAnZGl0aGVyJzpcbiAgICAgICAgY2FzZSAnc3RlbmNpbC5lbmFibGUnOlxuICAgICAgICBjYXNlICdkZXB0aC5lbmFibGUnOlxuICAgICAgICBjYXNlICdzY2lzc29yLmVuYWJsZSc6XG4gICAgICAgIGNhc2UgJ3BvbHlnb25PZmZzZXQuZW5hYmxlJzpcbiAgICAgICAgY2FzZSAnc2FtcGxlLmFscGhhJzpcbiAgICAgICAgY2FzZSAnc2FtcGxlLmVuYWJsZSc6XG4gICAgICAgIGNhc2UgJ2xpbmVXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2RlcHRoLm1hc2snOlxuICAgICAgICAgIHZhciBTVEFURV9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGR5bmFtaWNFbnRyeShTVEFURV9TVEFDSywgJy5wdXNoKCcsIHZhcmlhYmxlLCAnKTsnKVxuICAgICAgICAgIGR5bmFtaWNFeGl0KFNUQVRFX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICAvLyBEcmF3IGNhbGxzXG4gICAgICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgICAgY2FzZSAnb2Zmc2V0JzpcbiAgICAgICAgY2FzZSAnaW5zdGFuY2VzJzpcbiAgICAgICAgICB2YXIgRFJBV19TVEFDSyA9IERSQVdfU1RBVEVbcGFyYW1dXG4gICAgICAgICAgZHluYW1pY0VudHJ5KERSQVdfU1RBQ0ssICcucHVzaCgnLCB2YXJpYWJsZSwgJyk7JylcbiAgICAgICAgICBkeW5hbWljRXhpdChEUkFXX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdwcmltaXRpdmUnOlxuICAgICAgICAgIHZhciBQUklNX1NUQUNLID0gRFJBV19TVEFURS5wcmltaXRpdmVcbiAgICAgICAgICBkeW5hbWljRW50cnkoUFJJTV9TVEFDSywgJy5wdXNoKCcsIFBSSU1fVFlQRVMsICdbJywgdmFyaWFibGUsICddKTsnKVxuICAgICAgICAgIGR5bmFtaWNFeGl0KFBSSU1fU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2RlcHRoLmZ1bmMnOlxuICAgICAgICAgIHZhciBERVBUSF9GVU5DX1NUQUNLID0gbGlua0NvbnRleHQocGFyYW0pXG4gICAgICAgICAgZHluYW1pY0VudHJ5KERFUFRIX0ZVTkNfU1RBQ0ssICcucHVzaCgnLCBDT01QQVJFX0ZVTkNTLCAnWycsIHZhcmlhYmxlLCAnXSk7JylcbiAgICAgICAgICBkeW5hbWljRXhpdChERVBUSF9GVU5DX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdibGVuZC5mdW5jJzpcbiAgICAgICAgICB2YXIgQkxFTkRfRlVOQ19TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIHZhciBCTEVORF9GVU5DUyA9IGxpbmsoYmxlbmRGdW5jcylcbiAgICAgICAgICBkeW5hbWljRW50cnkoXG4gICAgICAgICAgICBCTEVORF9GVU5DX1NUQUNLLCAnLnB1c2goJyxcbiAgICAgICAgICAgIEJMRU5EX0ZVTkNTLFxuICAgICAgICAgICAgJ1tcInNyY1JHQlwiIGluICcsIHZhcmlhYmxlLCAnPycsIHZhcmlhYmxlLCAnLnNyY1JHQjonLCB2YXJpYWJsZSwgJy5zcmNdLCcsXG4gICAgICAgICAgICBCTEVORF9GVU5DUyxcbiAgICAgICAgICAgICdbXCJkc3RSR0JcIiBpbiAnLCB2YXJpYWJsZSwgJz8nLCB2YXJpYWJsZSwgJy5kc3RSR0I6JywgdmFyaWFibGUsICcuZHN0XSwnLFxuICAgICAgICAgICAgQkxFTkRfRlVOQ1MsXG4gICAgICAgICAgICAnW1wic3JjQWxwaGFcIiBpbiAnLCB2YXJpYWJsZSwgJz8nLCB2YXJpYWJsZSwgJy5zcmNBbHBoYTonLCB2YXJpYWJsZSwgJy5zcmNdLCcsXG4gICAgICAgICAgICBCTEVORF9GVU5DUyxcbiAgICAgICAgICAgICdbXCJkc3RBbHBoYVwiIGluICcsIHZhcmlhYmxlLCAnPycsIHZhcmlhYmxlLCAnLmRzdEFscGhhOicsIHZhcmlhYmxlLCAnLmRzdF0pOycpXG4gICAgICAgICAgZHluYW1pY0V4aXQoQkxFTkRfRlVOQ19TVEFDSywgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnYmxlbmQuZXF1YXRpb24nOlxuICAgICAgICAgIHZhciBCTEVORF9FUVVBVElPTl9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIHZhciBCTEVORF9FUVVBVElPTlMgPSBsaW5rKGJsZW5kRXF1YXRpb25zKVxuICAgICAgICAgIGR5bmFtaWNFbnRyeShcbiAgICAgICAgICAgICdpZih0eXBlb2YgJywgdmFyaWFibGUsICc9PT1cInN0cmluZ1wiKXsnLFxuICAgICAgICAgICAgICBCTEVORF9FUVVBVElPTl9TVEFDSywgJy5wdXNoKCcsXG4gICAgICAgICAgICAgIEJMRU5EX0VRVUFUSU9OUywgJ1snLCB2YXJpYWJsZSwgJ10sJyxcbiAgICAgICAgICAgICAgQkxFTkRfRVFVQVRJT05TLCAnWycsIHZhcmlhYmxlLCAnXSk7JyxcbiAgICAgICAgICAgICd9ZWxzZXsnLFxuICAgICAgICAgICAgICBCTEVORF9FUVVBVElPTl9TVEFDSywgJy5wdXNoKCcsXG4gICAgICAgICAgICAgIEJMRU5EX0VRVUFUSU9OUywgJ1snLCB2YXJpYWJsZSwgJy5yZ2JdLCcsXG4gICAgICAgICAgICAgIEJMRU5EX0VRVUFUSU9OUywgJ1snLCB2YXJpYWJsZSwgJy5hbHBoYV0pOycsXG4gICAgICAgICAgICAnfScpXG4gICAgICAgICAgZHluYW1pY0V4aXQoQkxFTkRfRVFVQVRJT05fU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2JsZW5kLmNvbG9yJzpcbiAgICAgICAgICB2YXIgQkxFTkRfQ09MT1JfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBkeW5hbWljRW50cnkoQkxFTkRfQ09MT1JfU1RBQ0ssICcucHVzaCgnLFxuICAgICAgICAgICAgdmFyaWFibGUsICdbMF0sJyxcbiAgICAgICAgICAgIHZhcmlhYmxlLCAnWzFdLCcsXG4gICAgICAgICAgICB2YXJpYWJsZSwgJ1syXSwnLFxuICAgICAgICAgICAgdmFyaWFibGUsICdbM10pOycpXG4gICAgICAgICAgZHluYW1pY0V4aXQoQkxFTkRfQ09MT1JfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3N0ZW5jaWwubWFzayc6XG4gICAgICAgICAgdmFyIFNURU5DSUxfTUFTS19TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGR5bmFtaWNFbnRyeShTVEVOQ0lMX01BU0tfU1RBQ0ssICcucHVzaCgnLCB2YXJpYWJsZSwgJyk7JylcbiAgICAgICAgICBkeW5hbWljRXhpdChTVEVOQ0lMX01BU0tfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3N0ZW5jaWwuZnVuYyc6XG4gICAgICAgICAgdmFyIFNURU5DSUxfRlVOQ19TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGR5bmFtaWNFbnRyeShTVEVOQ0lMX0ZVTkNfU1RBQ0ssICcucHVzaCgnLFxuICAgICAgICAgICAgQ09NUEFSRV9GVU5DUywgJ1snLCB2YXJpYWJsZSwgJy5jbXBdLCcsXG4gICAgICAgICAgICB2YXJpYWJsZSwgJy5yZWZ8MCwnLFxuICAgICAgICAgICAgJ1wibWFza1wiIGluICcsIHZhcmlhYmxlLCAnPycsIHZhcmlhYmxlLCAnLm1hc2s6LTEpOycpXG4gICAgICAgICAgZHluYW1pY0V4aXQoU1RFTkNJTF9GVU5DX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdzdGVuY2lsLm9wRnJvbnQnOlxuICAgICAgICBjYXNlICdzdGVuY2lsLm9wQmFjayc6XG4gICAgICAgICAgdmFyIFNURU5DSUxfT1BfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBkeW5hbWljRW50cnkoU1RFTkNJTF9PUF9TVEFDSywgJy5wdXNoKCcsXG4gICAgICAgICAgICBTVEVOQ0lMX09QUywgJ1snLCB2YXJpYWJsZSwgJy5mYWlsfHxcImtlZXBcIl0sJyxcbiAgICAgICAgICAgIFNURU5DSUxfT1BTLCAnWycsIHZhcmlhYmxlLCAnLnpmYWlsfHxcImtlZXBcIl0sJyxcbiAgICAgICAgICAgIFNURU5DSUxfT1BTLCAnWycsIHZhcmlhYmxlLCAnLnBhc3N8fFwia2VlcFwiXSk7JylcbiAgICAgICAgICBkeW5hbWljRXhpdChTVEVOQ0lMX09QX1NUQUNLLCAnLnBvcCgpOycpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdwb2x5Z29uT2Zmc2V0Lm9mZnNldCc6XG4gICAgICAgICAgdmFyIFBPTFlHT05fT0ZGU0VUX1NUQUNLID0gbGlua0NvbnRleHQocGFyYW0pXG4gICAgICAgICAgZHluYW1pY0VudHJ5KFBPTFlHT05fT0ZGU0VUX1NUQUNLLCAnLnB1c2goJyxcbiAgICAgICAgICAgIHZhcmlhYmxlLCAnLmZhY3Rvcnx8MCwnLFxuICAgICAgICAgICAgdmFyaWFibGUsICcudW5pdHN8fDApOycpXG4gICAgICAgICAgZHluYW1pY0V4aXQoUE9MWUdPTl9PRkZTRVRfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2N1bGwuZmFjZSc6XG4gICAgICAgICAgdmFyIENVTExfRkFDRV9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGR5bmFtaWNFbnRyeShDVUxMX0ZBQ0VfU1RBQ0ssICcucHVzaCgnLFxuICAgICAgICAgICAgdmFyaWFibGUsICc9PT1cImZyb250XCI/JywgR0xfRlJPTlQsICc6JywgR0xfQkFDSywgJyk7JylcbiAgICAgICAgICBkeW5hbWljRXhpdChDVUxMX0ZBQ0VfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2Zyb250RmFjZSc6XG4gICAgICAgICAgdmFyIEZST05UX0ZBQ0VfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBkeW5hbWljRW50cnkoRlJPTlRfRkFDRV9TVEFDSywgJy5wdXNoKCcsXG4gICAgICAgICAgICB2YXJpYWJsZSwgJz09PVwiY3dcIj8nLCBHTF9DVywgJzonLCBHTF9DQ1csICcpOycpXG4gICAgICAgICAgZHluYW1pY0V4aXQoRlJPTlRfRkFDRV9TVEFDSywgJy5wb3AoKTsnKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnY29sb3JNYXNrJzpcbiAgICAgICAgICB2YXIgQ09MT1JfTUFTS19TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGR5bmFtaWNFbnRyeShDT0xPUl9NQVNLX1NUQUNLLCAnLnB1c2goJyxcbiAgICAgICAgICAgIHZhcmlhYmxlLCAnWzBdLCcsXG4gICAgICAgICAgICB2YXJpYWJsZSwgJ1sxXSwnLFxuICAgICAgICAgICAgdmFyaWFibGUsICdbMl0sJyxcbiAgICAgICAgICAgIHZhcmlhYmxlLCAnWzNdKTsnKVxuICAgICAgICAgIGR5bmFtaWNFeGl0KENPTE9SX01BU0tfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3NhbXBsZS5jb3ZlcmFnZSc6XG4gICAgICAgICAgdmFyIFNBTVBMRV9DT1ZFUkFHRV9TVEFDSyA9IGxpbmtDb250ZXh0KHBhcmFtKVxuICAgICAgICAgIGR5bmFtaWNFbnRyeShTQU1QTEVfQ09WRVJBR0VfU1RBQ0ssICcucHVzaCgnLFxuICAgICAgICAgICAgdmFyaWFibGUsICcudmFsdWUsJyxcbiAgICAgICAgICAgIHZhcmlhYmxlLCAnLmludmVydCk7JylcbiAgICAgICAgICBkeW5hbWljRXhpdChTQU1QTEVfQ09WRVJBR0VfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3NjaXNzb3IuYm94JzpcbiAgICAgICAgY2FzZSAndmlld3BvcnQnOlxuICAgICAgICAgIHZhciBCT1hfU1RBQ0sgPSBsaW5rQ29udGV4dChwYXJhbSlcbiAgICAgICAgICBkeW5hbWljRW50cnkoQk9YX1NUQUNLLCAnLnB1c2goJyxcbiAgICAgICAgICAgIHZhcmlhYmxlLCAnLnh8fDAsJyxcbiAgICAgICAgICAgIHZhcmlhYmxlLCAnLnl8fDAsJyxcbiAgICAgICAgICAgICdcIndcIiBpbiAnLCB2YXJpYWJsZSwgJz8nLCB2YXJpYWJsZSwgJy53Oi0xLCcsXG4gICAgICAgICAgICAnXCJoXCIgaW4gJywgdmFyaWFibGUsICc/JywgdmFyaWFibGUsICcuaDotMSk7JylcbiAgICAgICAgICBkeW5hbWljRXhpdChCT1hfU1RBQ0ssICcucG9wKCk7JylcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2VsZW1lbnRzJzpcbiAgICAgICAgICB2YXIgaGFzUHJpbWl0aXZlID1cbiAgICAgICAgICAgICEoJ3ByaW1pdGl2ZScgaW4gZHluYW1pY09wdGlvbnMpICYmXG4gICAgICAgICAgICAhKCdwcmltaXRpdmUnIGluIHN0YXRpY09wdGlvbnMpXG4gICAgICAgICAgdmFyIGhhc0NvdW50ID1cbiAgICAgICAgICAgICEoJ2NvdW50JyBpbiBkeW5hbWljT3B0aW9ucykgJiZcbiAgICAgICAgICAgICEoJ2NvdW50JyBpbiBzdGF0aWNPcHRpb25zKVxuICAgICAgICAgIHZhciBoYXNPZmZzZXQgPVxuICAgICAgICAgICAgISgnb2Zmc2V0JyBpbiBkeW5hbWljT3B0aW9ucykgJiZcbiAgICAgICAgICAgICEoJ29mZnNldCcgaW4gc3RhdGljT3B0aW9ucylcbiAgICAgICAgICB2YXIgRUxFTUVOVFMgPSBkeW5hbWljRW50cnkuZGVmKClcbiAgICAgICAgICBkeW5hbWljRW50cnkoXG4gICAgICAgICAgICAnaWYoJywgdmFyaWFibGUsICcpeycsXG4gICAgICAgICAgICBFTEVNRU5UUywgJz0nLCB2YXJpYWJsZSwgJy5fZWxlbWVudHM7JyxcbiAgICAgICAgICAgIEVMRU1FTlRfU1RBVEUsICcucHVzaCgnLCBFTEVNRU5UUywgJyk7JyxcbiAgICAgICAgICAgICFoYXNQcmltaXRpdmUgPyAnJ1xuICAgICAgICAgICAgICA6IERSQVdfU1RBVEUucHJpbWl0aXZlICsgJy5wdXNoKCcgKyBFTEVNRU5UUyArICcucHJpbVR5cGUpOycsXG4gICAgICAgICAgICAhaGFzQ291bnQgPyAnJ1xuICAgICAgICAgICAgICA6IERSQVdfU1RBVEUuY291bnQgKyAnLnB1c2goJyArIEVMRU1FTlRTICsgJy52ZXJ0Q291bnQpOycsXG4gICAgICAgICAgICAhaGFzT2Zmc2V0ID8gJydcbiAgICAgICAgICAgICAgOiBEUkFXX1NUQVRFLm9mZnNldCArICcucHVzaCgnICsgRUxFTUVOVFMgKyAnLm9mZnNldCk7JyxcbiAgICAgICAgICAgICd9ZWxzZXsnLFxuICAgICAgICAgICAgRUxFTUVOVF9TVEFURSwgJy5wdXNoKG51bGwpOycsXG4gICAgICAgICAgICAnfScpXG4gICAgICAgICAgZHluYW1pY0V4aXQoXG4gICAgICAgICAgICBFTEVNRU5UX1NUQVRFLCAnLnBvcCgpOycsXG4gICAgICAgICAgICAnaWYoJywgdmFyaWFibGUsICcpeycsXG4gICAgICAgICAgICBoYXNQcmltaXRpdmUgPyBEUkFXX1NUQVRFLnByaW1pdGl2ZSArICcucG9wKCk7JyA6ICcnLFxuICAgICAgICAgICAgaGFzQ291bnQgPyBEUkFXX1NUQVRFLmNvdW50ICsgJy5wb3AoKTsnIDogJycsXG4gICAgICAgICAgICBoYXNPZmZzZXQgPyBEUkFXX1NUQVRFLm9mZnNldCArICcucG9wKCk7JyA6ICcnLFxuICAgICAgICAgICAgJ30nKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjaGVjay5yYWlzZSgndW5zdXBwb3J0ZWQgZHluYW1pYyBvcHRpb246ICcgKyBwYXJhbSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGR5bmFtaWMgdW5pZm9ybXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgT2JqZWN0LmtleXMoZHluYW1pY1VuaWZvcm1zKS5mb3JFYWNoKGZ1bmN0aW9uICh1bmlmb3JtKSB7XG4gICAgICB1bmlmb3JtU3RhdGUuZGVmKHVuaWZvcm0pXG4gICAgICB2YXIgU1RBQ0sgPSBsaW5rKHVuaWZvcm1TdGF0ZS51bmlmb3Jtc1t1bmlmb3JtXSlcbiAgICAgIHZhciBWQUxVRSA9IGR5bihkeW5hbWljVW5pZm9ybXNbdW5pZm9ybV0pXG4gICAgICBkeW5hbWljRW50cnkoU1RBQ0ssICcucHVzaCgnLCBWQUxVRSwgJyk7JylcbiAgICAgIGR5bmFtaWNFeGl0KFNUQUNLLCAnLnBvcCgpOycpXG4gICAgfSlcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBkeW5hbWljIGF0dHJpYnV0ZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgT2JqZWN0LmtleXMoZHluYW1pY0F0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlU3RhdGUuZGVmKGF0dHJpYnV0ZSlcbiAgICAgIHZhciBBVFRSSUJVVEUgPSBsaW5rKGF0dHJpYnV0ZVN0YXRlLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSlcbiAgICAgIHZhciBWQUxVRSA9IGR5bihkeW5hbWljQXR0cmlidXRlc1thdHRyaWJ1dGVdKVxuICAgICAgZHluYW1pY0VudHJ5KEFUVFJJQlVURSwgJy5wdXNoRHluKCcsIFZBTFVFLCAnKTsnKVxuICAgICAgZHluYW1pY0V4aXQoQVRUUklCVVRFLCAnLnBvcCgpOycpXG4gICAgfSlcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBTQ09QRSBQUk9DRURVUkVcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgdmFyIHNjb3BlID0gcHJvYygnc2NvcGUnKVxuICAgIHZhciBTQ09QRV9BUkdTID0gc2NvcGUuYXJnKClcbiAgICB2YXIgU0NPUEVfQk9EWSA9IHNjb3BlLmFyZygpXG4gICAgc2NvcGUoZW50cnkpXG4gICAgaWYgKGhhc0R5bmFtaWMpIHtcbiAgICAgIHNjb3BlKFxuICAgICAgICBEWU5BUkdTLCAnPScsIFNDT1BFX0FSR1MsICc7JyxcbiAgICAgICAgZHluYW1pY0VudHJ5KVxuICAgIH1cbiAgICBzY29wZShcbiAgICAgIFNDT1BFX0JPRFksICcoKTsnLFxuICAgICAgaGFzRHluYW1pYyA/IGR5bmFtaWNFeGl0IDogJycsXG4gICAgICBleGl0KVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIERSQVcgUFJPQ0VEVVJFXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHZhciBkcmF3ID0gcHJvYygnZHJhdycpXG4gICAgZHJhdyhlbnRyeSlcbiAgICBpZiAoaGFzRHluYW1pYykge1xuICAgICAgZHJhdyhcbiAgICAgICAgRFlOQVJHUywgJz0nLCBkcmF3LmFyZygpLCAnOycsXG4gICAgICAgIGR5bmFtaWNFbnRyeSlcbiAgICB9XG4gICAgdmFyIENVUlJFTlRfU0hBREVSID0gc3RhY2tUb3AoUFJPR1JBTV9TVEFURSlcbiAgICBkcmF3KFxuICAgICAgR0xfUE9MTCwgJygpOycsXG4gICAgICAnaWYoJywgQ1VSUkVOVF9TSEFERVIsICcpJyxcbiAgICAgIENVUlJFTlRfU0hBREVSLCAnLmRyYXcoJywgaGFzRHluYW1pYyA/IERZTkFSR1MgOiAnJywgJyk7JyxcbiAgICAgIGhhc0R5bmFtaWMgPyBkeW5hbWljRXhpdCA6ICcnLFxuICAgICAgZXhpdClcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBCQVRDSCBEUkFXXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHZhciBiYXRjaCA9IHByb2MoJ2JhdGNoJylcbiAgICBiYXRjaChlbnRyeSlcbiAgICB2YXIgQ1VSX1NIQURFUiA9IGJhdGNoLmRlZihzdGFja1RvcChQUk9HUkFNX1NUQVRFKSlcbiAgICB2YXIgRVhFQ19CQVRDSCA9IGxpbmsoZnVuY3Rpb24gKHByb2dyYW0sIGNvdW50LCBhcmdzKSB7XG4gICAgICB2YXIgcHJvYyA9IHByb2dyYW0uYmF0Y2hDYWNoZVtjYWxsSWRdXG4gICAgICBpZiAoIXByb2MpIHtcbiAgICAgICAgcHJvYyA9IHByb2dyYW0uYmF0Y2hDYWNoZVtjYWxsSWRdID0gY29tcGlsZUJhdGNoKFxuICAgICAgICAgIHByb2dyYW0sIGR5bmFtaWNPcHRpb25zLCBkeW5hbWljVW5pZm9ybXMsIGR5bmFtaWNBdHRyaWJ1dGVzLFxuICAgICAgICAgIHN0YXRpY09wdGlvbnMpXG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvYyhjb3VudCwgYXJncylcbiAgICB9KVxuICAgIGJhdGNoKFxuICAgICAgJ2lmKCcsIENVUl9TSEFERVIsICcpeycsXG4gICAgICBHTF9QT0xMLCAnKCk7JyxcbiAgICAgIEVYRUNfQkFUQ0gsICcoJyxcbiAgICAgIENVUl9TSEFERVIsICcsJyxcbiAgICAgIGJhdGNoLmFyZygpLCAnLCcsXG4gICAgICBiYXRjaC5hcmcoKSwgJyk7JylcbiAgICAvLyBTZXQgZGlydHkgb24gYWxsIGR5bmFtaWMgZmxhZ3NcbiAgICBPYmplY3Qua2V5cyhkeW5hbWljT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICB2YXIgU1RBVEUgPSBDT05URVhUX1NUQVRFW29wdGlvbl1cbiAgICAgIGlmIChTVEFURSkge1xuICAgICAgICBiYXRjaChTVEFURSwgJy5zZXREaXJ0eSgpOycpXG4gICAgICB9XG4gICAgfSlcbiAgICBiYXRjaCgnfScsIGV4aXQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZXZhbCBhbmQgYmluZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZXR1cm4gZW52LmNvbXBpbGUoKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkcmF3OiBjb21waWxlU2hhZGVyRHJhdyxcbiAgICBjb21tYW5kOiBjb21waWxlQ29tbWFuZFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6IDUxMjBcbiwgXCJbb2JqZWN0IEludDE2QXJyYXldXCI6IDUxMjJcbiwgXCJbb2JqZWN0IEludDMyQXJyYXldXCI6IDUxMjRcbiwgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6IDUxMjFcbiwgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOiA1MTIxXG4sIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjogNTEyM1xuLCBcIltvYmplY3QgVWludDMyQXJyYXldXCI6IDUxMjVcbiwgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjogNTEyNlxuLCBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOiA1MTIxXG4sIFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIjogNTEyMVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImFkZFwiOjMyNzc0LFxuICBcInN1YnRyYWN0XCI6MzI3NzgsXG4gIFwicmV2ZXJzZSBzdWJ0cmFjdFwiOjMyNzc5XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiMFwiOjAsXG4gIFwiMVwiOjEsXG4gIFwiemVyb1wiOjAsXG4gIFwib25lXCI6MSxcbiAgXCJzcmMgY29sb3JcIjogNzY4LFxuICBcIm9uZSBtaW51cyBzcmMgY29sb3JcIjo3NjksXG4gIFwic3JjIGFscGhhXCI6NzcwLFxuICBcIm9uZSBtaW51cyBzcmMgYWxwaGFcIjo3NzEsXG4gIFwiZHN0IGNvbG9yXCI6Nzc0LFxuICBcIm9uZSBtaW51cyBkc3QgY29sb3JcIjo3NzUsXG4gIFwiZHN0IGFscGhhXCI6NzcyLFxuICBcIm9uZSBtaW51cyBkc3QgYWxwaGFcIjo3NzMsXG4gIFwiY29uc3RhbnQgY29sb3JcIjogMzI3NjksXG4gIFwib25lIG1pbnVzIGNvbnN0YW50IGNvbG9yXCI6IDMyNzcwLFxuICBcImNvbnN0YW50IGFscGhhXCI6IDMyNzcxLFxuICBcIm9uZSBtaW51cyBjb25zdGFudCBhbHBoYVwiOiAzMjc3MixcbiAgXCJzcmMgYWxwaGEgc2F0dXJhdGVcIjogNzc2XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmV2ZXJcIjogNTEyLFxuICBcImxlc3NcIjogNTEzLFxuICBcIjxcIjogNTEzLFxuICBcImVxdWFsXCI6IDUxNCxcbiAgXCI9XCI6IDUxNCxcbiAgXCI9PVwiOiA1MTQsXG4gIFwiPT09XCI6IDUxNCxcbiAgXCJsZXF1YWxcIjogNTE1LFxuICBcIjw9XCI6IDUxNSxcbiAgXCJncmVhdGVyXCI6IDUxNixcbiAgXCI+XCI6IDUxNixcbiAgXCJub3RlcXVhbFwiOiA1MTcsXG4gIFwiIT1cIjogNTE3LFxuICBcIiE9PVwiOiA1MTcsXG4gIFwiZ2VxdWFsXCI6IDUxOCxcbiAgXCI+PVwiOiA1MTgsXG4gIFwiYWx3YXlzXCI6IDUxOVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImludDhcIjogNTEyMFxuLCBcImludDE2XCI6IDUxMjJcbiwgXCJpbnQzMlwiOiA1MTI0XG4sIFwidWludDhcIjogNTEyMVxuLCBcInVpbnQxNlwiOiA1MTIzXG4sIFwidWludDMyXCI6IDUxMjVcbiwgXCJmbG9hdFwiOiA1MTI2XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwicG9pbnRzXCI6IDAsXG4gIFwibGluZXNcIjogMSxcbiAgXCJsaW5lIGxvb3BcIjogMixcbiAgXCJsaW5lIHN0cmlwXCI6IDMsXG4gIFwidHJpYW5nbGVzXCI6IDQsXG4gIFwidHJpYW5nbGUgc3RyaXBcIjogNSxcbiAgXCJ0cmlhbmdsZSBmYW5cIjogNlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIjBcIjogMCxcbiAgXCJ6ZXJvXCI6IDAsXG4gIFwia2VlcFwiOiA3NjgwLFxuICBcInJlcGxhY2VcIjogNzY4MSxcbiAgXCJpbmNyZW1lbnRcIjogNzY4MixcbiAgXCJkZWNyZW1lbnRcIjogNzY4MyxcbiAgXCJpbmNyZW1lbnQgd3JhcFwiOiAzNDA1NSxcbiAgXCJkZWNyZW1lbnQgd3JhcFwiOiAzNDA1NixcbiAgXCJpbnZlcnRcIjogNTM4NlxufVxuIiwiLy8gQ29udGV4dCBhbmQgY2FudmFzIGNyZWF0aW9uIGhlbHBlciBmdW5jdGlvbnNcbi8qZ2xvYmFscyBIVE1MRWxlbWVudCxXZWJHTFJlbmRlcmluZ0NvbnRleHQqL1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJylcblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzIChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICB2YXIgYXJncyA9IGdldENvbnRleHQoY2FudmFzLCBvcHRpb25zKVxuXG4gIE9iamVjdC5hc3NpZ24oY2FudmFzLnN0eWxlLCB7XG4gICAgYm9yZGVyOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH0pXG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzKVxuXG4gIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwge1xuICAgICAgbWFyZ2luOiAwLFxuICAgICAgcGFkZGluZzogMFxuICAgIH0pXG4gIH1cblxuICB2YXIgc2NhbGUgPSArd2luZG93LmRldmljZVBpeGVsUmF0aW9cbiAgZnVuY3Rpb24gcmVzaXplICgpIHtcbiAgICB2YXIgdyA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgdmFyIGggPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICBpZiAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgdmFyIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIHcgPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdFxuICAgICAgaCA9IGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tXG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHNjYWxlICogd1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzY2FsZSAqIGhcbiAgICBPYmplY3QuYXNzaWduKGNhbnZhcy5zdHlsZSwge1xuICAgICAgd2lkdGg6IHcgKyAncHgnLFxuICAgICAgaGVpZ2h0OiBoICsgJ3B4J1xuICAgIH0pXG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplLCBmYWxzZSlcblxuICB2YXIgcHJldkRlc3Ryb3kgPSBhcmdzLm9wdGlvbnMub25EZXN0cm95XG4gIGFyZ3Mub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFyZ3Mub3B0aW9ucywge1xuICAgIG9uRGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSlcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoY2FudmFzKVxuICAgICAgcHJldkRlc3Ryb3kgJiYgcHJldkRlc3Ryb3koKVxuICAgIH1cbiAgfSlcblxuICByZXNpemUoKVxuXG4gIHJldHVybiBhcmdzXG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQgKGNhbnZhcywgb3B0aW9ucykge1xuICB2YXIgZ2xPcHRpb25zID0gb3B0aW9ucy5nbE9wdGlvbnNcblxuICBmdW5jdGlvbiBnZXQgKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KG5hbWUsIGdsT3B0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHZhciBnbCA9IGdldCgnd2ViZ2wnKSB8fFxuICAgICAgICAgICBnZXQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpIHx8XG4gICAgICAgICAgIGdldCgnd2ViZ2wtZXhwZXJpbWVudGFsJylcblxuICBjaGVjayhnbCwgJ3dlYmdsIG5vdCBzdXBwb3J0ZWQnKVxuXG4gIHJldHVybiB7XG4gICAgZ2w6IGdsLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlQXJncyAoYXJncykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7XG4gICAgICBnbDogYXJnc1swXSxcbiAgICAgIG9wdGlvbnM6IGFyZ3NbMV0gfHwge31cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmJvZHlcbiAgdmFyIG9wdGlvbnMgPSBhcmdzWzFdIHx8IHt9XG5cbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFyZ3NbMF0pIHx8IGRvY3VtZW50LmJvZHlcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gYXJnc1swXVxuICAgIH0gZWxzZSBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2w6IGFyZ3NbMF0sXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMF1cbiAgICB9XG4gIH1cblxuICBpZiAoZWxlbWVudC5ub2RlTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoZWxlbWVudCwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlQ2FudmFzKGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cbn1cbiIsInZhciBHTF9UUklBTkdMRVMgPSA0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd3JhcERyYXdTdGF0ZSAoZ2wpIHtcbiAgdmFyIHByaW1pdGl2ZSA9IFsgR0xfVFJJQU5HTEVTIF1cbiAgdmFyIGNvdW50ID0gWyAwIF1cbiAgdmFyIG9mZnNldCA9IFsgMCBdXG4gIHZhciBpbnN0YW5jZXMgPSBbIDAgXVxuXG4gIHJldHVybiB7XG4gICAgcHJpbWl0aXZlOiBwcmltaXRpdmUsXG4gICAgY291bnQ6IGNvdW50LFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGluc3RhbmNlczogaW5zdGFuY2VzXG4gIH1cbn1cbiIsInZhciBWQVJJQUJMRV9DT1VOVEVSID0gMFxuXG5mdW5jdGlvbiBEeW5hbWljVmFyaWFibGUgKGlzRnVuYywgZGF0YSkge1xuICB0aGlzLmlkID0gKFZBUklBQkxFX0NPVU5URVIrKylcbiAgdGhpcy5mdW5jID0gaXNGdW5jXG4gIHRoaXMuZGF0YSA9IGRhdGFcbn1cblxuZnVuY3Rpb24gZGVmaW5lRHluYW1pYyAoZGF0YSwgcGF0aCkge1xuICBzd2l0Y2ggKHR5cGVvZiBkYXRhKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUoZmFsc2UsIGRhdGEpXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUodHJ1ZSwgZGF0YSlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRlZmluZUR5bmFtaWNcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0R5bmFtaWMgKHgpIHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiAheC5fcmVnbFR5cGUpIHx8XG4gICAgICAgICB4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlXG59XG5cbmZ1bmN0aW9uIHVuYm94ICh4LCBwYXRoKSB7XG4gIGlmICh4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHhcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgIHggIT09IGRlZmluZUR5bmFtaWMpIHtcbiAgICByZXR1cm4gbmV3IER5bmFtaWNWYXJpYWJsZSh0cnVlLCB4KVxuICB9XG4gIHJldHVybiBuZXcgRHluYW1pY1ZhcmlhYmxlKGZhbHNlLCBwYXRoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmaW5lOiBkZWZpbmVEeW5hbWljLFxuICBpc0R5bmFtaWM6IGlzRHluYW1pYyxcbiAgdW5ib3g6IHVuYm94XG59XG4iLCJ2YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJylcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzLXR5cGVkLWFycmF5JylcbnZhciBwcmltVHlwZXMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9wcmltaXRpdmVzLmpzb24nKVxuXG52YXIgR0xfUE9JTlRTID0gMFxudmFyIEdMX0xJTkVTID0gMVxudmFyIEdMX1RSSUFOR0xFUyA9IDRcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUgPSA1MTIxXG52YXIgR0xfVU5TSUdORURfU0hPUlQgPSA1MTIzXG52YXIgR0xfVU5TSUdORURfSU5UID0gNTEyNVxuXG52YXIgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAzNDk2M1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdyYXBFbGVtZW50c1N0YXRlIChnbCwgZXh0ZW5zaW9uU3RhdGUsIGJ1ZmZlclN0YXRlKSB7XG4gIHZhciBleHRlbnNpb25zID0gZXh0ZW5zaW9uU3RhdGUuZXh0ZW5zaW9uc1xuXG4gIHZhciBlbGVtZW50cyA9IFsgbnVsbCBdXG5cbiAgZnVuY3Rpb24gUkVHTEVsZW1lbnRCdWZmZXIgKCkge1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbFxuICAgIHRoaXMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVNcbiAgICB0aGlzLnZlcnRDb3VudCA9IDBcbiAgICB0aGlzLnR5cGUgPSAwXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9wdGlvbnMgKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHR5cGU6ICdlbGVtZW50cydcbiAgICB9XG4gICAgdmFyIGV4dDMyYml0ID0gZXh0ZW5zaW9ucy5vZXNfZWxlbWVudF9pbmRleF91aW50XG4gICAgZWxlbWVudHMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVNcbiAgICBlbGVtZW50cy52ZXJ0Q291bnQgPSAwXG4gICAgZWxlbWVudHMudHlwZSA9IDBcblxuICAgIHZhciBkYXRhID0gbnVsbFxuXG4gICAgLy8gQ2hlY2sgb3B0aW9uIHR5cGVcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2sudHlwZShvcHRpb25zLCAnb2JqZWN0JywgJ2FyZ3VtZW50IHRvIGVsZW1lbnQgYnVmZmVyIG11c3QgYmUgb2JqZWN0JylcbiAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGEgfHwgb3B0aW9uc1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGF0YSA9IG51bGxcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhWzBdKSkge1xuICAgICAgICB2YXIgZGltID0gZGF0YVswXS5sZW5ndGhcbiAgICAgICAgaWYgKGRpbSA9PT0gMSkgZWxlbWVudHMucHJpbVR5cGUgPSBHTF9QT0lOVFNcbiAgICAgICAgaWYgKGRpbSA9PT0gMikgZWxlbWVudHMucHJpbVR5cGUgPSBHTF9MSU5FU1xuICAgICAgICBpZiAoZGltID09PSAzKSBlbGVtZW50cy5wcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgICAgICB2YXIgaVxuICAgICAgICB2YXIgY291bnQgPSAwXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY291bnQgKz0gZGF0YVtpXS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmxhdHRlbmVkID0gZXh0MzJiaXRcbiAgICAgICAgICA/IG5ldyBVaW50MzJBcnJheShjb3VudClcbiAgICAgICAgICA6IG5ldyBVaW50MTZBcnJheShjb3VudClcbiAgICAgICAgdmFyIHB0ciA9IDBcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgeCA9IGRhdGFbaV1cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHgubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFtwdHIrK10gPSB4W2pdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBmbGF0dGVuZWRcbiAgICAgIH0gZWxzZSBpZiAoZXh0MzJiaXQpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50MzJBcnJheShkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmICgoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8XG4gICAgICAgICAgKGRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkpIHtcbiAgICAgICAgZWxlbWVudHMudHlwZSA9IEdMX1VOU0lHTkVEX0JZVEVcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGVsZW1lbnRzLnR5cGUgPSBHTF9VTlNJR05FRF9TSE9SVFxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgY2hlY2soZXh0MzJiaXQsICczMi1iaXQgZWxlbWVudCBidWZmZXJzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICBlbGVtZW50cy50eXBlID0gR0xfVU5TSUdORURfSU5UXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjay5yYWlzZSgnaW52YWxpZCB0eXBlZCBhcnJheSBmb3IgZWxlbWVudCBidWZmZXInKVxuICAgICAgfVxuICAgICAgZWxlbWVudHMudmVydENvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgIHJlc3VsdC5kYXRhID0gZGF0YVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGVjayghZGF0YSwgJ2ludmFsaWQgZWxlbWVudCBidWZmZXIgZGF0YSB0eXBlJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoJ3ByaW1pdGl2ZScgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgcHJpbWl0aXZlID0gb3B0aW9ucy5wcmltaXRpdmVcbiAgICAgICAgY2hlY2sucGFyYW0ocHJpbWl0aXZlLCBwcmltVHlwZXMpXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gcHJpbVR5cGVzW3ByaW1pdGl2ZV1cbiAgICAgIH1cblxuICAgICAgaWYgKCd1c2FnZScgaW4gb3B0aW9ucykge1xuICAgICAgICByZXN1bHQudXNhZ2UgPSBvcHRpb25zLnVzYWdlXG4gICAgICB9XG5cbiAgICAgIGlmICgnY291bnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudHMudmVydENvdW50ID0gb3B0aW9ucy52ZXJ0Q291bnQgfCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihSRUdMRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlci5fYnVmZmVyLmJ1ZmZlcilcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmRlc3Ryb3koKVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudHMgKG9wdGlvbnMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBuZXcgUkVHTEVsZW1lbnRCdWZmZXIoKVxuXG4gICAgLy8gQ3JlYXRlIGJ1ZmZlclxuICAgIGVsZW1lbnRzLmJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmNyZWF0ZShcbiAgICAgIHBhcnNlT3B0aW9ucyhlbGVtZW50cywgb3B0aW9ucyksXG4gICAgICBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUilcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzIChvcHRpb25zKSB7XG4gICAgICBlbGVtZW50cy5idWZmZXIocGFyc2VPcHRpb25zKGVsZW1lbnRzLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50c1xuICAgIH1cblxuICAgIHVwZGF0ZUVsZW1lbnRzLl9yZWdsVHlwZSA9ICdlbGVtZW50cydcbiAgICB1cGRhdGVFbGVtZW50cy5fZWxlbWVudHMgPSBlbGVtZW50c1xuICAgIHVwZGF0ZUVsZW1lbnRzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IGVsZW1lbnRzLmRlc3Ryb3koKSB9XG5cbiAgICByZXR1cm4gdXBkYXRlRWxlbWVudHNcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlOiBjcmVhdGVFbGVtZW50cyxcbiAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgZ2V0RWxlbWVudHM6IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgaWYgKGVsZW1lbnRzICYmIGVsZW1lbnRzLl9lbGVtZW50cyBpbnN0YW5jZW9mIFJFR0xFbGVtZW50QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5fZWxlbWVudHNcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNhY2hlIChnbCkge1xuICB2YXIgZXh0ZW5zaW9ucyA9IHt9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaEV4dGVuc2lvbnMgKCkge1xuICAgIFtcbiAgICAgICdvZXNfdGV4dHVyZV9mbG9hdCcsXG4gICAgICAnb2VzX3RleHR1cmVfZmxvYXRfbGluZWFyJyxcbiAgICAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0JyxcbiAgICAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicsXG4gICAgICAnb2VzX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyxcbiAgICAgICdvZXNfZWxlbWVudF9pbmRleF91aW50JyxcbiAgICAgICdvZXNfZmJvX3JlbmRlcl9taXBtYXAnLFxuXG4gICAgICAnd2ViZ2xfZGVwdGhfdGV4dHVyZScsXG4gICAgICAnd2ViZ2xfZHJhd19idWZmZXJzJyxcbiAgICAgICd3ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQnLFxuXG4gICAgICAnZXh0X3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyxcbiAgICAgICdleHRfZnJhZ19kZXB0aCcsXG4gICAgICAnZXh0X2JsZW5kX21pbm1heCcsXG4gICAgICAnZXh0X3NoYWRlcl90ZXh0dXJlX2xvZCcsXG4gICAgICAnZXh0X2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyxcbiAgICAgICdleHRfc3JnYicsXG5cbiAgICAgICdhbmdsZV9pbnN0YW5jZWRfYXJyYXlzJyxcblxuICAgICAgJ3dlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyxcbiAgICAgICd3ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfYXRjJyxcbiAgICAgICd3ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnLFxuICAgICAgJ3dlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJ1xuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBleHRlbnNpb25zW2V4dF0gPSBnbC5nZXRFeHRlbnNpb24oZXh0KVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KVxuICB9XG5cbiAgcmVmcmVzaEV4dGVuc2lvbnMoKVxuXG4gIHJldHVybiB7XG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyxcbiAgICByZWZyZXNoOiByZWZyZXNoRXh0ZW5zaW9uc1xuICB9XG59XG4iLCIvLyBGcmFtZWJ1ZmZlciBvYmplY3Qgc3RhdGUgbWFuYWdlbWVudFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdyYXBGQk9TdGF0ZSAoXG4gIGdsLFxuICB0ZXh0dXJlQ2FjaGUpIHtcbiAgZnVuY3Rpb24gY3JlYXRlRkJPIChvcHRpb25zKSB7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hDYWNoZSAoKSB7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlRkJPLFxuICAgIGNsZWFyOiBjbGVhckNhY2hlLFxuICAgIHJlZnJlc2g6IHJlZnJlc2hDYWNoZSxcbiAgICBnZXRGQk86IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuIiwidmFyIGR0eXBlcyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2FycmF5dHlwZXMuanNvbicpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgaW4gZHR5cGVzXG59XG4iLCJ2YXIgR0xfU1VCUElYRUxfQklUUyA9IDB4MEQ1MFxudmFyIEdMX1JFRF9CSVRTID0gMHgwRDUyXG52YXIgR0xfR1JFRU5fQklUUyA9IDB4MEQ1M1xudmFyIEdMX0JMVUVfQklUUyA9IDB4MEQ1NFxudmFyIEdMX0FMUEhBX0JJVFMgPSAweDBENTVcbnZhciBHTF9ERVBUSF9CSVRTID0gMHgwRDU2XG52YXIgR0xfU1RFTkNJTF9CSVRTID0gMHgwRDU3XG5cbnZhciBHTF9BTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UgPSAweDg0NkRcbnZhciBHTF9BTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UgPSAweDg0NkVcblxudmFyIEdMX01BWF9URVhUVVJFX1NJWkUgPSAweDBEMzNcbnZhciBHTF9NQVhfVklFV1BPUlRfRElNUyA9IDB4MEQzQVxudmFyIEdMX01BWF9WRVJURVhfQVRUUklCUyA9IDB4ODg2OVxudmFyIEdMX01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTID0gMHg4REZCXG52YXIgR0xfTUFYX1ZBUllJTkdfVkVDVE9SUyA9IDB4OERGQ1xudmFyIEdMX01BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTID0gMHg4QjREXG52YXIgR0xfTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTID0gMHg4QjRDXG52YXIgR0xfTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSAweDg4NzJcbnZhciBHTF9NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTID0gMHg4REZEXG52YXIgR0xfTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSA9IDB4ODUxQ1xudmFyIEdMX01BWF9SRU5ERVJCVUZGRVJfU0laRSA9IDB4ODRFOFxuXG52YXIgR0xfVkVORE9SID0gMHgxRjAwXG52YXIgR0xfUkVOREVSRVIgPSAweDFGMDFcbnZhciBHTF9WRVJTSU9OID0gMHgxRjAyXG52YXIgR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OID0gMHg4QjhDXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zKSB7XG4gIHJldHVybiB7XG4gICAgLy8gZHJhd2luZyBidWZmZXIgYml0IGRlcHRoXG4gICAgY29sb3JCaXRzOiBbXG4gICAgICBnbC5nZXRQYXJhbWV0ZXIoR0xfUkVEX0JJVFMpLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0dSRUVOX0JJVFMpLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0JMVUVfQklUUyksXG4gICAgICBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxQSEFfQklUUylcbiAgICBdLFxuICAgIGRlcHRoQml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX0RFUFRIX0JJVFMpLFxuICAgIHN0ZW5jaWxCaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU1RFTkNJTF9CSVRTKSxcbiAgICBzdWJwaXhlbEJpdHM6IGdsLmdldFBhcmFtZXRlcihHTF9TVUJQSVhFTF9CSVRTKSxcblxuICAgIC8vIHN1cHBvcnRlZCBleHRlbnNpb25zXG4gICAgZXh0ZW5zaW9uczogT2JqZWN0LmtleXMoZXh0ZW5zaW9ucy5leHRlbnNpb25zKSxcblxuICAgIC8vIFRPRE8gY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuICAgIC8vIFRPRE8gbWF4IGFuaXNvIHNhbXBsZXNcblxuICAgIC8vIHBvaW50IGFuZCBsaW5lIHNpemUgcmFuZ2VzXG4gICAgcG9pbnRTaXplOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFKSxcbiAgICBsaW5lV2lkdGg6IGdsLmdldFBhcmFtZXRlcihHTF9BTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UpLFxuICAgIHZpZXdwb3J0OiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZJRVdQT1JUX0RJTVMpLFxuICAgIGNvbWJpbmVkVGV4dHVyZVVuaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgIGN1YmVNYXBTaXplOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSksXG4gICAgcmVuZGVyYnVmZmVyU2l6ZTogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9SRU5ERVJCVUZGRVJfU0laRSksXG4gICAgdGV4dHVyZVVuaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgIHRleHR1cmVTaXplOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1RFWFRVUkVfU0laRSksXG4gICAgYXR0cmlidXRlczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfQVRUUklCUyksXG4gICAgdmVydGV4VW5pZm9ybXM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyksXG4gICAgdmVydGV4VGV4dHVyZVVuaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTKSxcbiAgICB2YXJ5aW5nVmVjdG9yczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WQVJZSU5HX1ZFQ1RPUlMpLFxuICAgIGZyYWdtZW50VW5pZm9ybXM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTKSxcblxuICAgIC8vIHZlbmRvciBpbmZvXG4gICAgZ2xzbDogZ2wuZ2V0UGFyYW1ldGVyKEdMX1NIQURJTkdfTEFOR1VBR0VfVkVSU0lPTiksXG4gICAgcmVuZGVyZXI6IGdsLmdldFBhcmFtZXRlcihHTF9SRU5ERVJFUiksXG4gICAgdmVuZG9yOiBnbC5nZXRQYXJhbWV0ZXIoR0xfVkVORE9SKSxcbiAgICB2ZXJzaW9uOiBnbC5nZXRQYXJhbWV0ZXIoR0xfVkVSU0lPTilcbiAgfVxufVxuIiwiLyogZ2xvYmFscyBkb2N1bWVudCwgSW1hZ2UsIFhNTEh0dHBSZXF1ZXN0ICovXG5cbm1vZHVsZS5leHBvcnRzID0gbG9hZFRleHR1cmVcblxuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uICh1cmwpIHtcbiAgdmFyIHBhcnRzID0gL1xcLihcXHcrKShcXD8uKik/JC8uZXhlYyh1cmwpXG4gIGlmIChwYXJ0cyAmJiBwYXJ0c1sxXSkge1xuICAgIHJldHVybiBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWaWRlb0V4dGVuc2lvbiAodXJsKSB7XG4gIHJldHVybiBbXG4gICAgJ2F2aScsXG4gICAgJ2FzZicsXG4gICAgJ2dpZnYnLFxuICAgICdtb3YnLFxuICAgICdxdCcsXG4gICAgJ3l1dicsXG4gICAgJ21wZycsXG4gICAgJ21wZWcnLFxuICAgICdtMnYnLFxuICAgICdtcDQnLFxuICAgICdtNHAnLFxuICAgICdtNHYnLFxuICAgICdvZ2cnLFxuICAgICdvZ3YnLFxuICAgICd2b2InLFxuICAgICd3ZWJtJyxcbiAgICAnd212J1xuICBdLmluZGV4T2YodXJsKSA+PSAwXG59XG5cbmZ1bmN0aW9uIGlzQ29tcHJlc3NlZEV4dGVuc2lvbiAodXJsKSB7XG4gIHJldHVybiBbXG4gICAgLy8gJ2RkcydcbiAgXS5pbmRleE9mKHVybCkgPj0gMFxufVxuXG5mdW5jdGlvbiBsb2FkVmlkZW8gKHVybCkge1xuICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gIHZpZGVvLmF1dG9wbGF5ID0gdHJ1ZVxuICB2aWRlby5sb29wID0gdHJ1ZVxuICB2aWRlby5zcmMgPSB1cmxcbiAgcmV0dXJuIHZpZGVvXG59XG5cbmZ1bmN0aW9uIGxvYWRDb21wcmVzc2VkVGV4dHVyZSAodXJsKSB7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKVxuICB4aHIuc2VuZCgpXG4gIHJldHVybiB4aHJcbn1cblxuZnVuY3Rpb24gbG9hZEltYWdlICh1cmwpIHtcbiAgdmFyIGltYWdlID0gbmV3IEltYWdlKClcbiAgaW1hZ2Uuc3JjID0gdXJsXG4gIHJldHVybiBpbWFnZVxufVxuXG4vLyBDdXJyZW50bHkgdGhpcyBzdHVmZiBvbmx5IHdvcmtzIGluIGEgRE9NIGVudmlyb25tZW50XG5mdW5jdGlvbiBsb2FkVGV4dHVyZSAodXJsKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGV4dCA9IGdldEV4dGVuc2lvbih1cmwpXG4gICAgaWYgKGlzVmlkZW9FeHRlbnNpb24oZXh0KSkge1xuICAgICAgcmV0dXJuIGxvYWRWaWRlbyh1cmwpXG4gICAgfVxuICAgIGlmIChpc0NvbXByZXNzZWRFeHRlbnNpb24oZXh0KSkge1xuICAgICAgcmV0dXJuIGxvYWRDb21wcmVzc2VkVGV4dHVyZSh1cmwpXG4gICAgfVxuICAgIHJldHVybiBsb2FkSW1hZ2UodXJsKVxuICB9XG4gIHJldHVybiBudWxsXG59XG4iLCIvKiBnbG9iYWxzIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUgKi9cbmlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICh4KSB7IHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoeCkgfSxcbiAgICBjYW5jZWw6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZSh4KSB9XG4gIH1cbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uIChjYikge1xuICAgICAgc2V0VGltZW91dChjYiwgMzApXG4gICAgfSxcbiAgICBjYW5jZWw6IGNsZWFyVGltZW91dFxuICB9XG59XG4iLCJ2YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJylcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzLXR5cGVkLWFycmF5JylcblxudmFyIEdMX1JHQkEgPSA2NDA4XG52YXIgR0xfVU5TSUdORURfQllURSA9IDUxMjFcbnZhciBHTF9QQUNLX0FMSUdOTUVOVCA9IDB4MEQwNVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdyYXBSZWFkUGl4ZWxzIChnbCwgZ2xTdGF0ZSkge1xuICBmdW5jdGlvbiByZWFkUGl4ZWxzIChpbnB1dCkge1xuICAgIHZhciBvcHRpb25zID0gaW5wdXQgfHwge31cbiAgICBpZiAoaXNUeXBlZEFycmF5KGlucHV0KSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YTogb3B0aW9uc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IGFyZ3VtZW50c1swXSB8IDAsXG4gICAgICAgIGhlaWdodDogYXJndW1lbnRzWzFdIHwgMFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFdlYkdMIHN0YXRlXG4gICAgZ2xTdGF0ZS5wb2xsKClcblxuICAgIC8vIFJlYWQgdmlld3BvcnQgc3RhdGVcbiAgICB2YXIgdmlld3BvcnRTdGF0ZSA9IGdsU3RhdGUudmlld3BvcnRcbiAgICB2YXIgeCA9IG9wdGlvbnMueCB8fCAwXG4gICAgdmFyIHkgPSBvcHRpb25zLnkgfHwgMFxuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgdmlld3BvcnRTdGF0ZS53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB2aWV3cG9ydFN0YXRlLmhlaWdodFxuXG4gICAgLy8gQ29tcHV0ZSBzaXplXG4gICAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodCAqIDRcblxuICAgIC8vIEFsbG9jYXRlIGRhdGFcbiAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCBuZXcgVWludDhBcnJheShzaXplKVxuXG4gICAgLy8gVHlwZSBjaGVja1xuICAgIGNoZWNrLmlzVHlwZWRBcnJheShkYXRhKVxuICAgIGNoZWNrKGRhdGEuYnl0ZUxlbmd0aCA+PSBzaXplLCAnZGF0YSBidWZmZXIgdG9vIHNtYWxsJylcblxuICAgIC8vIFJ1biByZWFkIHBpeGVsc1xuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1BBQ0tfQUxJR05NRU5ULCA0KVxuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgR0xfUkdCQSwgR0xfVU5TSUdORURfQllURSwgZGF0YSlcblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICByZXR1cm4gcmVhZFBpeGVsc1xufVxuIiwidmFyIGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpXG5cbnZhciBERUZBVUxUX0ZSQUdfU0hBREVSID0gJ3ZvaWQgbWFpbigpe2dsX0ZyYWdDb2xvcj12ZWM0KDAsMCwwLDApO30nXG52YXIgREVGQVVMVF9WRVJUX1NIQURFUiA9ICd2b2lkIG1haW4oKXtnbF9Qb3NpdGlvbj12ZWM0KDAsMCwwLDApO30nXG5cbnZhciBHTF9GUkFHTUVOVF9TSEFERVIgPSAzNTYzMlxudmFyIEdMX1ZFUlRFWF9TSEFERVIgPSAzNTYzM1xuXG5mdW5jdGlvbiBBY3RpdmVJbmZvIChuYW1lLCBsb2NhdGlvbiwgaW5mbykge1xuICB0aGlzLm5hbWUgPSBuYW1lXG4gIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvblxuICB0aGlzLmluZm8gPSBpbmZvXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd3JhcFNoYWRlclN0YXRlIChcbiAgZ2wsXG4gIGV4dGVuc2lvbnMsXG4gIGF0dHJpYnV0ZVN0YXRlLFxuICB1bmlmb3JtU3RhdGUsXG4gIGNvbXBpbGVTaGFkZXJEcmF3KSB7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBnbHNsIGNvbXBpbGF0aW9uIGFuZCBsaW5raW5nXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgc2hhZGVycyA9IHt9XG5cbiAgdmFyIGZyYWdTaGFkZXJzID0gW0RFRkFVTFRfRlJBR19TSEFERVJdXG4gIHZhciB2ZXJ0U2hhZGVycyA9IFtERUZBVUxUX1ZFUlRfU0hBREVSXVxuXG4gIGZ1bmN0aW9uIGdldFNoYWRlciAodHlwZSwgc291cmNlKSB7XG4gICAgdmFyIGNhY2hlID0gc2hhZGVyc1t0eXBlXVxuICAgIHZhciBzaGFkZXIgPSBjYWNoZVtzb3VyY2VdXG5cbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcilcblxuICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgdmFyIGVyckxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKVxuICAgICAgICBjaGVjay5yYWlzZSgnRXJyb3IgY29tcGlsaW5nIHNoYWRlcjpcXG4nICsgZXJyTG9nKVxuICAgICAgfVxuICAgICAgY2FjaGVbc291cmNlXSA9IHNoYWRlclxuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hTaGFkZXJzICgpIHtcbiAgICBzaGFkZXJzW0dMX0ZSQUdNRU5UX1NIQURFUl0gPSB7fVxuICAgIHNoYWRlcnNbR0xfVkVSVEVYX1NIQURFUl0gPSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJTaGFkZXJzICgpIHtcbiAgICBPYmplY3Qua2V5cyhzaGFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBPYmplY3Qua2V5cyhzaGFkZXJzW3R5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcnNbdHlwZV1bc2hhZGVyXSlcbiAgICAgIH0pXG4gICAgfSlcbiAgICBzaGFkZXJzW0dMX0ZSQUdNRU5UX1NIQURFUl0gPSB7fVxuICAgIHNoYWRlcnNbR0xfVkVSVEVYX1NIQURFUl0gPSB7fVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIHByb2dyYW0gbGlua2luZ1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIHByb2dyYW1DYWNoZSA9IHt9XG4gIHZhciBwcm9ncmFtTGlzdCA9IFtdXG5cbiAgZnVuY3Rpb24gUkVHTFByb2dyYW0gKGZyYWdTcmMsIHZlcnRTcmMpIHtcbiAgICB0aGlzLmZyYWdTcmMgPSBmcmFnU3JjXG4gICAgdGhpcy52ZXJ0U3JjID0gdmVydFNyY1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGxcbiAgICB0aGlzLnVuaWZvcm1zID0gW11cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXVxuICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uICgpIHt9XG4gICAgdGhpcy5iYXRjaENhY2hlID0ge31cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oUkVHTFByb2dyYW0ucHJvdG90eXBlLCB7XG4gICAgbGluazogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGksIGluZm9cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gY29tcGlsZSAmIGxpbmtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIHZhciBmcmFnU2hhZGVyID0gZ2V0U2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgdGhpcy5mcmFnU3JjKVxuICAgICAgdmFyIHZlcnRTaGFkZXIgPSBnZXRTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiwgdGhpcy52ZXJ0U3JjKVxuXG4gICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpXG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydFNoYWRlcilcbiAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXG4gICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgIHZhciBlcnJMb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxuICAgICAgICBjaGVjay5yYWlzZSgnRXJyb3IgbGlua2luZyBwcm9ncmFtOlxcbicgKyBlcnJMb2cpXG4gICAgICB9XG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGdyYWIgdW5pZm9ybXNcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKVxuICAgICAgdmFyIHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcyA9IFtdXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVW5pZm9ybXM7ICsraSkge1xuICAgICAgICBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKVxuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgIGlmIChpbmZvLnNpemUgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZm8uc2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lLnJlcGxhY2UoJ1swXScsICdbJyArIGogKyAnXScpXG4gICAgICAgICAgICAgIHVuaWZvcm1zLnB1c2gobmV3IEFjdGl2ZUluZm8oXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSksXG4gICAgICAgICAgICAgICAgaW5mbykpXG4gICAgICAgICAgICAgIHVuaWZvcm1TdGF0ZS5kZWYobmFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pZm9ybXMucHVzaChuZXcgQWN0aXZlSW5mbyhcbiAgICAgICAgICAgICAgaW5mby5uYW1lLFxuICAgICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgaW5mby5uYW1lKSxcbiAgICAgICAgICAgICAgaW5mbykpXG4gICAgICAgICAgICB1bmlmb3JtU3RhdGUuZGVmKGluZm8ubmFtZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gZ3JhYiBhdHRyaWJ1dGVzXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICB2YXIgbnVtQXR0cmlidXRlcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcyA9IFtdXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQXR0cmlidXRlczsgKytpKSB7XG4gICAgICAgIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSlcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobmV3IEFjdGl2ZUluZm8oXG4gICAgICAgICAgICBpbmZvLm5hbWUsXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpLFxuICAgICAgICAgICAgaW5mbykpXG4gICAgICAgICAgYXR0cmlidXRlU3RhdGUuZGVmKGluZm8ubmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBjbGVhciBjYWNoZWQgcmVuZGVyaW5nIG1ldGhvZHNcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIHRoaXMuZHJhdyA9IGNvbXBpbGVTaGFkZXJEcmF3KHRoaXMpXG4gICAgICB0aGlzLmJhdGNoQ2FjaGUgPSB7fVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSlcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gZ2V0UHJvZ3JhbSAodmVydFNvdXJjZSwgZnJhZ1NvdXJjZSkge1xuICAgIHZhciBjYWNoZSA9IHByb2dyYW1DYWNoZVtmcmFnU291cmNlXVxuICAgIGlmICghY2FjaGUpIHtcbiAgICAgIGNhY2hlID0gcHJvZ3JhbUNhY2hlW3ZlcnRTb3VyY2VdID0ge31cbiAgICB9XG4gICAgdmFyIHByb2dyYW0gPSBjYWNoZVt2ZXJ0U291cmNlXVxuICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgcHJvZ3JhbSA9IG5ldyBSRUdMUHJvZ3JhbShmcmFnU291cmNlLCB2ZXJ0U291cmNlKVxuICAgICAgcHJvZ3JhbS5saW5rKClcbiAgICAgIGNhY2hlW3ZlcnRTb3VyY2VdID0gcHJvZ3JhbVxuICAgICAgcHJvZ3JhbUxpc3QucHVzaChwcm9ncmFtKVxuICAgIH1cbiAgICByZXR1cm4gcHJvZ3JhbVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJQcm9ncmFtcyAoKSB7XG4gICAgcHJvZ3JhbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgcHJvZ3JhbS5kZXN0cm95KClcbiAgICB9KVxuICAgIHByb2dyYW1MaXN0Lmxlbmd0aCA9IDBcbiAgICBwcm9ncmFtQ2FjaGUgPSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFByb2dyYW1zICgpIHtcbiAgICBwcm9ncmFtTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICBwcm9ncmFtLmxpbmsoKVxuICAgIH0pXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gcHJvZ3JhbSBzdGF0ZVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIHByb2dyYW1TdGF0ZSA9IFtudWxsXVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBjb250ZXh0IG1hbmFnZW1lbnRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBjbGVhclNoYWRlcnMoKVxuICAgIGNsZWFyUHJvZ3JhbXMoKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaCAoKSB7XG4gICAgcmVmcmVzaFNoYWRlcnMoKVxuICAgIHJlZnJlc2hQcm9ncmFtcygpXG4gIH1cblxuICAvLyBXZSBjYWxsIGNsZWFyIG9uY2UgdG8gaW5pdGlhbGl6ZSBhbGwgZGF0YSBzdHJ1Y3R1cmVzXG4gIGNsZWFyKClcblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogZ2V0UHJvZ3JhbSxcbiAgICBjbGVhcjogY2xlYXIsXG4gICAgcmVmcmVzaDogcmVmcmVzaCxcbiAgICBwcm9ncmFtczogcHJvZ3JhbVN0YXRlLFxuICAgIGZyYWdTaGFkZXJzOiBmcmFnU2hhZGVycyxcbiAgICB2ZXJ0U2hhZGVyczogdmVydFNoYWRlcnNcbiAgfVxufVxuIiwiLy8gQSBzdGFjayBmb3IgbWFuYWdpbmcgdGhlIHN0YXRlIG9mIGEgc2NhbGFyL3ZlY3RvciBwYXJhbWV0ZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVTdGFjayAoaW5pdCwgb25DaGFuZ2UpIHtcbiAgdmFyIG4gPSBpbml0Lmxlbmd0aFxuICB2YXIgc3RhY2sgPSBpbml0LnNsaWNlKClcbiAgdmFyIGRpcnR5ID0gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHBvbGwgKCkge1xuICAgIHZhciBwdHIgPSBzdGFjay5sZW5ndGggLSBuXG4gICAgaWYgKGRpcnR5KSB7XG4gICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG9uQ2hhbmdlKHN0YWNrW3B0cl0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG9uQ2hhbmdlKHN0YWNrW3B0cl0sIHN0YWNrW3B0ciArIDFdKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBvbkNoYW5nZShzdGFja1twdHJdLCBzdGFja1twdHIgKyAxXSwgc3RhY2tbcHRyICsgMl0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIG9uQ2hhbmdlKHN0YWNrW3B0cl0sIHN0YWNrW3B0ciArIDFdLCBzdGFja1twdHIgKyAyXSwgc3RhY2tbcHRyICsgM10pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIG9uQ2hhbmdlKHN0YWNrW3B0cl0sIHN0YWNrW3B0ciArIDFdLCBzdGFja1twdHIgKyAyXSwgc3RhY2tbcHRyICsgM10sIHN0YWNrW3B0ciArIDRdKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBvbkNoYW5nZShzdGFja1twdHJdLCBzdGFja1twdHIgKyAxXSwgc3RhY2tbcHRyICsgMl0sIHN0YWNrW3B0ciArIDNdLCBzdGFja1twdHIgKyA0XSwgc3RhY2tbcHRyICsgNV0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvbkNoYW5nZS5hcHBseShudWxsLCBzdGFjay5zbGljZShwdHIsIHN0YWNrLmxlbmd0aCkpXG4gICAgICB9XG4gICAgICBkaXJ0eSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzdGFjay5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICAgIH1cbiAgICAgIGRpcnR5ID0gdHJ1ZVxuICAgIH0sXG5cbiAgICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSBuXG4gICAgICBkaXJ0eSA9IHRydWVcbiAgICB9LFxuXG4gICAgcG9sbDogcG9sbCxcblxuICAgIHNldERpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkaXJ0eSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbiIsInZhciBjcmVhdGVTdGFjayA9IHJlcXVpcmUoJy4vc3RhY2snKVxudmFyIGNyZWF0ZUVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9jb2RlZ2VuJylcblxuLy8gV2ViR0wgY29uc3RhbnRzXG52YXIgR0xfQ1VMTF9GQUNFID0gMHgwQjQ0XG52YXIgR0xfQkxFTkQgPSAweDBCRTJcbnZhciBHTF9ESVRIRVIgPSAweDBCRDBcbnZhciBHTF9TVEVOQ0lMX1RFU1QgPSAweDBCOTBcbnZhciBHTF9ERVBUSF9URVNUID0gMHgwQjcxXG52YXIgR0xfU0NJU1NPUl9URVNUID0gMHgwQzExXG52YXIgR0xfUE9MWUdPTl9PRkZTRVRfRklMTCA9IDB4ODAzN1xudmFyIEdMX1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSA9IDB4ODA5RVxudmFyIEdMX1NBTVBMRV9DT1ZFUkFHRSA9IDB4ODBBMFxudmFyIEdMX0ZVTkNfQUREID0gMHg4MDA2XG52YXIgR0xfWkVSTyA9IDBcbnZhciBHTF9PTkUgPSAxXG52YXIgR0xfRlJPTlQgPSAxMDI4XG52YXIgR0xfQkFDSyA9IDEwMjlcbnZhciBHTF9MRVNTID0gNTEzXG52YXIgR0xfQ0NXID0gMjMwNVxudmFyIEdMX0FMV0FZUyA9IDUxOVxudmFyIEdMX0tFRVAgPSA3NjgwXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd3JhcENvbnRleHRTdGF0ZSAoZ2wsIHNoYWRlclN0YXRlKSB7XG4gIGZ1bmN0aW9uIGNhcFN0YWNrIChjYXAsIGRmbHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlU3RhY2soWyEhZGZsdF0sIGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICBnbC5lbmFibGUoY2FwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZGlzYWJsZShjYXApXG4gICAgICB9XG4gICAgfSlcbiAgICByZXN1bHQuZmxhZyA9IGNhcFxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHZhciB2aWV3cG9ydFN0YXRlID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9XG5cbiAgLy8gQ2FwcywgZmxhZ3MgYW5kIG90aGVyIHJhbmRvbSBXZWJHTCBjb250ZXh0IHN0YXRlXG4gIHZhciBjb250ZXh0U3RhdGUgPSB7XG4gICAgLy8gRGl0aGVyaW5nXG4gICAgJ2RpdGhlcic6IGNhcFN0YWNrKEdMX0RJVEhFUiksXG5cbiAgICAvLyBCbGVuZGluZ1xuICAgICdibGVuZC5lbmFibGUnOiBjYXBTdGFjayhHTF9CTEVORCksXG4gICAgJ2JsZW5kLmNvbG9yJzogY3JlYXRlU3RhY2soWzAsIDAsIDAsIDBdLCBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICAgICAgZ2wuYmxlbmRDb2xvcihyLCBnLCBiLCBhKVxuICAgIH0pLFxuICAgICdibGVuZC5lcXVhdGlvbic6IGNyZWF0ZVN0YWNrKFtHTF9GVU5DX0FERCwgR0xfRlVOQ19BRERdLCBmdW5jdGlvbiAocmdiLCBhKSB7XG4gICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUocmdiLCBhKVxuICAgIH0pLFxuICAgICdibGVuZC5mdW5jJzogY3JlYXRlU3RhY2soW1xuICAgICAgR0xfT05FLCBHTF9aRVJPLCBHTF9PTkUsIEdMX1pFUk9cbiAgICBdLCBmdW5jdGlvbiAoc3JjUkdCLCBkc3RSR0IsIHNyY0FscGhhLCBkc3RBbHBoYSkge1xuICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoc3JjUkdCLCBkc3RSR0IsIHNyY0FscGhhLCBkc3RBbHBoYSlcbiAgICB9KSxcblxuICAgIC8vIERlcHRoXG4gICAgJ2RlcHRoLmVuYWJsZSc6IGNhcFN0YWNrKEdMX0RFUFRIX1RFU1QsIHRydWUpLFxuICAgICdkZXB0aC5mdW5jJzogY3JlYXRlU3RhY2soW0dMX0xFU1NdLCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgZ2wuZGVwdGhGdW5jKGZ1bmMpXG4gICAgfSksXG4gICAgJ2RlcHRoLnJhbmdlJzogY3JlYXRlU3RhY2soWzAsIDFdLCBmdW5jdGlvbiAobmVhciwgZmFyKSB7XG4gICAgICBnbC5kZXB0aFJhbmdlKG5lYXIsIGZhcilcbiAgICB9KSxcbiAgICAnZGVwdGgubWFzayc6IGNyZWF0ZVN0YWNrKFt0cnVlXSwgZnVuY3Rpb24gKG0pIHtcbiAgICAgIGdsLmRlcHRoTWFzayhtKVxuICAgIH0pLFxuXG4gICAgLy8gRmFjZSBjdWxsaW5nXG4gICAgJ2N1bGwuZW5hYmxlJzogY2FwU3RhY2soR0xfQ1VMTF9GQUNFKSxcbiAgICAnY3VsbC5mYWNlJzogY3JlYXRlU3RhY2soW0dMX0JBQ0tdLCBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgZ2wuY3VsbEZhY2UobW9kZSlcbiAgICB9KSxcblxuICAgIC8vIEZyb250IGZhY2Ugb3JpZW50YXRpb25cbiAgICAnZnJvbnRGYWNlJzogY3JlYXRlU3RhY2soW0dMX0NDV10sIGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICBnbC5mcm9udEZhY2UobW9kZSlcbiAgICB9KSxcblxuICAgIC8vIFdyaXRlIG1hc2tzXG4gICAgJ2NvbG9yTWFzayc6IGNyZWF0ZVN0YWNrKFt0cnVlLCB0cnVlLCB0cnVlLCB0cnVlXSwgZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICAgIGdsLmNvbG9yTWFzayhyLCBnLCBiLCBhKVxuICAgIH0pLFxuXG4gICAgLy8gTGluZSB3aWR0aFxuICAgICdsaW5lV2lkdGgnOiBjcmVhdGVTdGFjayhbMV0sIGZ1bmN0aW9uICh3KSB7XG4gICAgICBnbC5saW5lV2lkdGgodylcbiAgICB9KSxcblxuICAgIC8vIFBvbHlnb24gb2Zmc2V0XG4gICAgJ3BvbHlnb25PZmZzZXQuZW5hYmxlJzogY2FwU3RhY2soR0xfUE9MWUdPTl9PRkZTRVRfRklMTCksXG4gICAgJ3BvbHlnb25PZmZzZXQub2Zmc2V0JzogY3JlYXRlU3RhY2soWzAsIDBdLCBmdW5jdGlvbiAoZmFjdG9yLCB1bml0cykge1xuICAgICAgZ2wucG9seWdvbk9mZnNldChmYWN0b3IsIHVuaXRzKVxuICAgIH0pLFxuXG4gICAgLy8gU2FtcGxlIGNvdmVyYWdlXG4gICAgJ3NhbXBsZS5hbHBoYSc6IGNhcFN0YWNrKEdMX1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSksXG4gICAgJ3NhbXBsZS5lbmFibGUnOiBjYXBTdGFjayhHTF9TQU1QTEVfQ09WRVJBR0UpLFxuICAgICdzYW1wbGUuY292ZXJhZ2UnOiBjcmVhdGVTdGFjayhbMSwgZmFsc2VdLCBmdW5jdGlvbiAodmFsdWUsIGludmVydCkge1xuICAgICAgZ2wuc2FtcGxlQ292ZXJhZ2UodmFsdWUsIGludmVydClcbiAgICB9KSxcblxuICAgIC8vIFN0ZW5jaWxcbiAgICAnc3RlbmNpbC5lbmFibGUnOiBjYXBTdGFjayhHTF9TVEVOQ0lMX1RFU1QpLFxuICAgICdzdGVuY2lsLm1hc2snOiBjcmVhdGVTdGFjayhbLTFdLCBmdW5jdGlvbiAobWFzaykge1xuICAgICAgZ2wuc3RlbmNpbE1hc2sobWFzaylcbiAgICB9KSxcbiAgICAnc3RlbmNpbC5mdW5jJzogY3JlYXRlU3RhY2soW1xuICAgICAgR0xfQUxXQVlTLCAwLCAtMVxuICAgIF0sIGZ1bmN0aW9uIChmdW5jLCByZWYsIG1hc2spIHtcbiAgICAgIGdsLnN0ZW5jaWxGdW5jKGZ1bmMsIHJlZiwgbWFzaylcbiAgICB9KSxcbiAgICAnc3RlbmNpbC5vcEZyb250JzogY3JlYXRlU3RhY2soW1xuICAgICAgR0xfS0VFUCwgR0xfS0VFUCwgR0xfS0VFUFxuICAgIF0sIGZ1bmN0aW9uIChmYWlsLCB6ZmFpbCwgcGFzcykge1xuICAgICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoR0xfRlJPTlQsIGZhaWwsIHpmYWlsLCBwYXNzKVxuICAgIH0pLFxuICAgICdzdGVuY2lsLm9wQmFjayc6IGNyZWF0ZVN0YWNrKFtcbiAgICAgIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBcbiAgICBdLCBmdW5jdGlvbiAoZmFpbCwgemZhaWwsIHBhc3MpIHtcbiAgICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKEdMX0JBQ0ssIGZhaWwsIHpmYWlsLCBwYXNzKVxuICAgIH0pLFxuXG4gICAgLy8gU2Npc3NvclxuICAgICdzY2lzc29yLmVuYWJsZSc6IGNhcFN0YWNrKEdMX1NDSVNTT1JfVEVTVCksXG4gICAgJ3NjaXNzb3IuYm94JzogY3JlYXRlU3RhY2soWzAsIDAsIC0xLCAtMV0sIGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICB2YXIgd18gPSB3XG4gICAgICBpZiAodyA8IDApIHtcbiAgICAgICAgd18gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGggLSB4XG4gICAgICB9XG4gICAgICB2YXIgaF8gPSBoXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaF8gPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC0geVxuICAgICAgfVxuICAgICAgZ2wuc2Npc3Nvcih4LCB5LCB3XywgaF8pXG4gICAgfSksXG5cbiAgICAvLyBWaWV3cG9ydFxuICAgICd2aWV3cG9ydCc6IGNyZWF0ZVN0YWNrKFswLCAwLCAtMSwgLTFdLCBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgdmFyIHdfID0gd1xuICAgICAgaWYgKHcgPCAwKSB7XG4gICAgICAgIHdfID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoIC0geFxuICAgICAgfVxuICAgICAgdmFyIGhfID0gaFxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGhfID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAtIHlcbiAgICAgIH1cbiAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHdfLCBoXylcbiAgICAgIHZpZXdwb3J0U3RhdGUud2lkdGggPSB3X1xuICAgICAgdmlld3BvcnRTdGF0ZS5oZWlnaHQgPSBoX1xuICAgIH0pXG4gIH1cblxuICB2YXIgZW52ID0gY3JlYXRlRW52aXJvbm1lbnQoKVxuICB2YXIgcG9sbCA9IGVudi5wcm9jKCdwb2xsJylcbiAgdmFyIHJlZnJlc2ggPSBlbnYucHJvYygncmVmcmVzaCcpXG4gIE9iamVjdC5rZXlzKGNvbnRleHRTdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciBTVEFDSyA9IGVudi5saW5rKGNvbnRleHRTdGF0ZVtwcm9wXSlcbiAgICBwb2xsKFNUQUNLLCAnLnBvbGwoKTsnKVxuICAgIHJlZnJlc2goU1RBQ0ssICcuc2V0RGlydHkoKTsnKVxuICB9KVxuICB2YXIgcHJvY3MgPSBlbnYuY29tcGlsZSgpXG5cbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0U3RhdGU6IGNvbnRleHRTdGF0ZSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRTdGF0ZSxcbiAgICBwb2xsOiBwcm9jcy5wb2xsLFxuICAgIHJlZnJlc2g6IHByb2NzLnJlZnJlc2gsXG5cbiAgICBub3RpZnlWaWV3cG9ydENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnRleHRTdGF0ZS52aWV3cG9ydC5zZXREaXJ0eSgpXG4gICAgICBjb250ZXh0U3RhdGVbJ3NjaXNzb3IuYm94J10uc2V0RGlydHkoKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pcy10eXBlZC1hcnJheScpXG52YXIgbG9hZFRleHR1cmUgPSByZXF1aXJlKCcuL2xvYWQtdGV4dHVyZScpXG5cbnZhciBHTF9URVhUVVJFXzJEID0gMHgwREUxXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YID0gMHg4NTE1XG5cbnZhciBHTF9SR0JBID0gMHgxOTA4XG52YXIgR0xfQUxQSEEgPSAweDE5MDZcbnZhciBHTF9SR0IgPSAweDE5MDdcbnZhciBHTF9MVU1JTkFOQ0UgPSAweDE5MDlcbnZhciBHTF9MVU1JTkFOQ0VfQUxQSEEgPSAweDE5MEFcblxudmFyIEdMX1JHQkE0ID0gMHg4MDU2XG52YXIgR0xfUkdCNV9BMSA9IDB4ODA1N1xudmFyIEdMX1JHQjU2NSA9IDB4OEQ2MlxuXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCA9IDB4ODAzM1xudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgPSAweDgwMzRcbnZhciBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2M1xudmFyIEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMID0gMHg4NEZBXG5cbnZhciBHTF9ERVBUSF9DT01QT05FTlQgPSAweDE5MDJcbnZhciBHTF9ERVBUSF9TVEVOQ0lMID0gMHg4NEY5XG5cbnZhciBHTF9TUkdCX0VYVCA9IDB4OEM0MFxudmFyIEdMX1NSR0JfQUxQSEFfRVhUID0gMHg4QzQyXG5cbnZhciBHTF9IQUxGX0ZMT0FUX09FUyA9IDB4OEQ2MVxuXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCA9IDB4ODNGMFxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUID0gMHg4M0YxXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQgPSAweDgzRjJcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCA9IDB4ODNGM1xuXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMID0gMHg4QzkyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTCA9IDB4OEM5M1xudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMID0gMHg4N0VFXG5cbnZhciBHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HID0gMHg4QzAwXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRyA9IDB4OEMwMVxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HID0gMHg4QzAyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUcgPSAweDhDMDNcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wgPSAweDhENjRcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUgPSAweDE0MDFcbnZhciBHTF9VTlNJR05FRF9TSE9SVCA9IDB4MTQwM1xudmFyIEdMX1VOU0lHTkVEX0lOVCA9IDB4MTQwNVxudmFyIEdMX0ZMT0FUID0gMHgxNDA2XG5cbnZhciBHTF9URVhUVVJFX1dSQVBfUyA9IDB4MjgwMlxudmFyIEdMX1RFWFRVUkVfV1JBUF9UID0gMHgyODAzXG5cbnZhciBHTF9SRVBFQVQgPSAweDI5MDFcbnZhciBHTF9DTEFNUF9UT19FREdFID0gMHg4MTJGXG52YXIgR0xfTUlSUk9SRURfUkVQRUFUID0gMHg4MzcwXG5cbnZhciBHTF9URVhUVVJFX01BR19GSUxURVIgPSAweDI4MDBcbnZhciBHTF9URVhUVVJFX01JTl9GSUxURVIgPSAweDI4MDFcblxudmFyIEdMX05FQVJFU1QgPSAweDI2MDBcbnZhciBHTF9MSU5FQVIgPSAweDI2MDFcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUID0gMHgyNzAwXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUID0gMHgyNzAxXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSID0gMHgyNzAyXG52YXIgR0xfTElORUFSX01JUE1BUF9MSU5FQVIgPSAweDI3MDNcblxudmFyIEdMX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUID0gMHg4NEZFXG5cbnZhciBHTF9VTlBBQ0tfQUxJR05NRU5UID0gMHgwQ0Y1XG52YXIgR0xfVU5QQUNLX0ZMSVBfWV9XRUJHTCA9IDB4OTI0MFxudmFyIEdMX1VOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCA9IDB4OTI0MVxudmFyIEdMX1VOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wgPSAweDkyNDNcblxudmFyIEdMX0JST1dTRVJfREVGQVVMVF9XRUJHTCA9IDB4OTI0NFxuXG52YXIgR0xfVEVYVFVSRTAgPSAweDg0QzBcblxudmFyIHdyYXBNb2RlcyA9IHtcbiAgJ3JlcGVhdCc6IEdMX1JFUEVBVCxcbiAgJ2NsYW1wJzogR0xfQ0xBTVBfVE9fRURHRSxcbiAgJ21pcnJvcic6IEdMX01JUlJPUkVEX1JFUEVBVFxufVxuXG52YXIgbWFnRmlsdGVycyA9IHtcbiAgJ25lYXJlc3QnOiBHTF9ORUFSRVNULFxuICAnbGluZWFyJzogR0xfTElORUFSXG59XG5cbnZhciBtaW5GaWx0ZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICduZWFyZXN0IG1pcG1hcCBuZWFyZXN0JzogR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxcbiAgJ2xpbmVhciBtaXBtYXAgbmVhcmVzdCc6IEdMX0xJTkVBUl9NSVBNQVBfTkVBUkVTVCxcbiAgJ25lYXJlc3QgbWlwbWFwIGxpbmVhcic6IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUixcbiAgJ2xpbmVhciBtaXBtYXAgbGluZWFyJzogR0xfTElORUFSX01JUE1BUF9MSU5FQVIsXG4gICdtaXBtYXAnOiBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUlxufSwgbWFnRmlsdGVycylcblxuZnVuY3Rpb24gaXNQb3cyICh2KSB7XG4gIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KVxufVxuXG5mdW5jdGlvbiBpc051bWVyaWNBcnJheSAoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhcnIpICYmXG4gICAgKGFyci5sZW5ndGggPT09IDAgfHxcbiAgICB0eXBlb2YgYXJyWzBdID09PSAnbnVtYmVyJykpXG59XG5cbmZ1bmN0aW9uIGlzTkRBcnJheUxpa2UgKG9iaikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgQXJyYXkuaXNBcnJheShvYmouc2hhcGUpICYmXG4gICAgQXJyYXkuaXNBcnJheShvYmouc3RyaWRlKSAmJlxuICAgIHR5cGVvZiBvYmoub2Zmc2V0ID09PSAnbnVtYmVyJyAmJlxuICAgIG9iai5zaGFwZS5sZW5ndGggPT09IG9iai5zdHJpZGUubGVuZ3RoICYmXG4gICAgKEFycmF5LmlzQXJyYXkob2JqLmRhdGEpIHx8XG4gICAgICBpc1R5cGVkQXJyYXkob2JqLmRhdGEpKSlcbn1cblxuZnVuY3Rpb24gaXNSZWN0QXJyYXkgKGFycikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIHdpZHRoID0gYXJyLmxlbmd0aFxuICBpZiAod2lkdGggPT09IDAgfHwgIUFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGhlaWdodCA9IGFyclswXS5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB3aWR0aDsgKytpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycltpXSkgfHwgYXJyW2ldLmxlbmd0aCAhPT0gaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY2xhc3NTdHJpbmcgKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KVxufVxuXG5mdW5jdGlvbiBpc0NhbnZhc0VsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJ1xufVxuXG5mdW5jdGlvbiBpc0NvbnRleHQyRCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSAnW29iamVjdCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdJ1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlRWxlbWVudCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XSdcbn1cblxuZnVuY3Rpb24gaXNWaWRlb0VsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gJ1tvYmplY3QgSFRNTFZpZGVvRWxlbWVudF0nXG59XG5cbmZ1bmN0aW9uIGlzUGVuZGluZ1hIUiAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSAnW29iamVjdCBYTUxIdHRwUmVxdWVzdF0nXG59XG5cbmZ1bmN0aW9uIGlzUGl4ZWxEYXRhIChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyB8fFxuICAgIGlzVHlwZWRBcnJheShvYmplY3QpIHx8XG4gICAgaXNOdW1lcmljQXJyYXkob2JqZWN0KSB8fFxuICAgIGlzTkRBcnJheUxpa2Uob2JqZWN0KSB8fFxuICAgIGlzQ2FudmFzRWxlbWVudChvYmplY3QpIHx8XG4gICAgaXNDb250ZXh0MkQob2JqZWN0KSB8fFxuICAgIGlzSW1hZ2VFbGVtZW50KG9iamVjdCkgfHxcbiAgICBpc1ZpZGVvRWxlbWVudChvYmplY3QpIHx8XG4gICAgaXNSZWN0QXJyYXkob2JqZWN0KSlcbn1cblxuLy8gVGhpcyBjb252ZXJ0cyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gMTYgYml0IGhhbGYgcHJlY2lzaW9uIGZsb2F0c1xuZnVuY3Rpb24gY29udmVydFRvSGFsZkZsb2F0IChhcnJheSkge1xuICB2YXIgZmxvYXRzID0gbmV3IEZsb2F0MzJBcnJheShhcnJheSlcbiAgdmFyIHVpbnRzID0gbmV3IFVpbnQzMkFycmF5KGZsb2F0cy5idWZmZXIpXG4gIHZhciB1c2hvcnRzID0gbmV3IFVpbnQxNkFycmF5KGFycmF5Lmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGlzTmFOKGFycmF5W2ldKSkge1xuICAgICAgdXNob3J0c1tpXSA9IDB4ZmZmZlxuICAgIH0gZWxzZSBpZiAoYXJyYXlbaV0gPT09IEluZmluaXR5KSB7XG4gICAgICB1c2hvcnRzW2ldID0gMHg3YzAwXG4gICAgfSBlbHNlIGlmIChhcnJheVtpXSA9PT0gLUluZmluaXR5KSB7XG4gICAgICB1c2hvcnRzW2ldID0gMHhmYzAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4ID0gdWludHNbaV1cblxuICAgICAgdmFyIHNnbiA9ICh4ID4+PiAzMSkgPDwgMTVcbiAgICAgIHZhciBleHAgPSAoKHggPDwgMSkgPj4+IDI0KSAtIDEyN1xuICAgICAgdmFyIGZyYWMgPSAoeCA+PiAxMykgJiAoKDEgPDwgMTApIC0gMSlcblxuICAgICAgaWYgKGV4cCA8IC0yNCkge1xuICAgICAgICAvLyByb3VuZCBub24tcmVwcmVzZW50YWJsZSBkZW5vcm1hbHMgdG8gMFxuICAgICAgICB1c2hvcnRzW2ldID0gc2duXG4gICAgICB9IGVsc2UgaWYgKGV4cCA8IC0xNCkge1xuICAgICAgICAvLyBoYW5kbGUgZGVub3JtYWxzXG4gICAgICAgIHZhciBzID0gLTE0IC0gZXhwXG4gICAgICAgIHVzaG9ydHNbaV0gPSBzZ24gKyAoKGZyYWMgKyAoMSA8PCAxMCkpID4+IHMpXG4gICAgICB9IGVsc2UgaWYgKGV4cCA+IDE1KSB7XG4gICAgICAgIC8vIHJvdW5kIG92ZXJmbG93IHRvICsvLSBJbmZpbml0eVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgMHg3YzAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgY29udmVydCBkaXJlY3RseVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgKChleHAgKyAxNSkgPDwgMTApICsgZnJhY1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1c2hvcnRzXG59XG5cbi8vIFRyYW5zcG9zZSBhbiBhcnJheSBvZiBwaXhlbHNcbmZ1bmN0aW9uIHRyYW5zcG9zZVBpeGVscyAoZGF0YSwgbngsIG55LCBuYywgc3gsIHN5LCBzYywgb2ZmKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgZGF0YS5jb25zdHJ1Y3RvcihueCAqIG55ICogbmMpXG4gIHZhciBwdHIgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnk7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbng7ICsraikge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuYzsgKytrKSB7XG4gICAgICAgIHJlc3VsdFtwdHIrK10gPSBkYXRhW3N5ICogaSArIHN4ICogaiArIHNjICogayArIG9mZl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVTZXQgKGdsLCBleHRlbnNpb25TdGF0ZSwgbGltaXRzLCByZWdsUG9sbCkge1xuICB2YXIgZXh0ZW5zaW9ucyA9IGV4dGVuc2lvblN0YXRlLmV4dGVuc2lvbnNcblxuICB2YXIgY29sb3JTcGFjZSA9IHtcbiAgICAnbm9uZSc6IDAsXG4gICAgJ2Jyb3dzZXInOiBHTF9CUk9XU0VSX0RFRkFVTFRfV0VCR0xcbiAgfVxuXG4gIHZhciB0ZXh0dXJlVHlwZXMgPSB7XG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSxcbiAgICAncmdiYTQnOiBHTF9VTlNJR05FRF9TSE9SVF80XzRfNF80LFxuICAgICdyZ2I1NjUnOiBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSxcbiAgICAncmdiNSBhMSc6IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzFcbiAgfVxuXG4gIHZhciB0ZXh0dXJlRm9ybWF0cyA9IHtcbiAgICAnYWxwaGEnOiBHTF9BTFBIQSxcbiAgICAnbHVtaW5hbmNlJzogR0xfTFVNSU5BTkNFLFxuICAgICdsdW1pbmFuY2UgYWxwaGEnOiBHTF9MVU1JTkFOQ0VfQUxQSEEsXG4gICAgJ3JnYic6IEdMX1JHQixcbiAgICAncmdiYSc6IEdMX1JHQkEsXG4gICAgJ3JnYmE0JzogR0xfUkdCQTQsXG4gICAgJ3JnYjUgYTEnOiBHTF9SR0I1X0ExLFxuICAgICdyZ2I1NjUnOiBHTF9SR0I1NjVcbiAgfVxuXG4gIHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSB7fVxuXG4gIGlmIChleHRlbnNpb25zLmV4dF9zcmdiKSB7XG4gICAgdGV4dHVyZUZvcm1hdHMuc3JnYiA9IEdMX1NSR0JfRVhUXG4gICAgdGV4dHVyZUZvcm1hdHMuc3JnYmEgPSBHTF9TUkdCX0FMUEhBX0VYVFxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQpIHtcbiAgICB0ZXh0dXJlVHlwZXMuZmxvYXQgPSBHTF9GTE9BVFxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfaGFsZl9mbG9hdCkge1xuICAgIHRleHR1cmVUeXBlc1snaGFsZiBmbG9hdCddID0gR0xfSEFMRl9GTE9BVF9PRVNcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUpIHtcbiAgICBPYmplY3QuYXNzaWduKHRleHR1cmVGb3JtYXRzLCB7XG4gICAgICAnZGVwdGgnOiBHTF9ERVBUSF9DT01QT05FTlQsXG4gICAgICAnZGVwdGggc3RlbmNpbCc6IEdMX0RFUFRIX1NURU5DSUxcbiAgICB9KVxuXG4gICAgT2JqZWN0LmFzc2lnbih0ZXh0dXJlVHlwZXMsIHtcbiAgICAgICd1aW50MTYnOiBHTF9VTlNJR05FRF9TSE9SVCxcbiAgICAgICd1aW50MzInOiBHTF9VTlNJR05FRF9JTlQsXG4gICAgICAnZGVwdGggc3RlbmNpbCc6IEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMXG4gICAgfSlcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjKSB7XG4gICAgT2JqZWN0LmFzc2lnbihjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgczN0YyBkeHQxJzogR0xfQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCxcbiAgICAgICdyZ2JhIHMzdGMgZHh0MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICAgICAgJ3JnYmEgczN0YyBkeHQzJzogR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gICAgICAncmdiYSBzM3RjIGR4dDUnOiBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfYXRjKSB7XG4gICAgT2JqZWN0LmFzc2lnbihjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgYXJjJzogR0xfQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMLFxuICAgICAgJ3JnYmEgYXRjIGV4cGxpY2l0IGFscGhhJzogR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTCxcbiAgICAgICdyZ2JhIGF0YyBpbnRlcnBvbGF0ZWQgYWxwaGEnOiBHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTFxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMpIHtcbiAgICBPYmplY3QuYXNzaWduKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xuICAgICAgJ3JnYiBwdnJ0YyA0YnBwdjEnOiBHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HLFxuICAgICAgJ3JnYiBwdnJ0YyAyYnBwdjEnOiBHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HLFxuICAgICAgJ3JnYmEgcHZydGMgNGJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcsXG4gICAgICAncmdiYSBwdnJ0YyAyYnBwdjEnOiBHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNR1xuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMSkge1xuICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0c1sncmdiIGV0YzEnXSA9IEdMX0NPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0xcbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24odGV4dHVyZUZvcm1hdHMsIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cylcblxuICB2YXIgc3VwcG9ydGVkRm9ybWF0cyA9IE9iamVjdC5rZXlzKHRleHR1cmVGb3JtYXRzKVxuICBsaW1pdHMudGV4dHVyZUZvcm1hdHMgPSBzdXBwb3J0ZWRGb3JtYXRzXG5cbiAgdmFyIGNvbG9yRm9ybWF0cyA9IHN1cHBvcnRlZEZvcm1hdHMucmVkdWNlKGZ1bmN0aW9uIChjb2xvciwga2V5KSB7XG4gICAgdmFyIGdsZW51bSA9IHRleHR1cmVGb3JtYXRzW2tleV1cbiAgICBpZiAoZ2xlbnVtID09PSBHTF9MVU1JTkFOQ0UgfHxcbiAgICAgICAgZ2xlbnVtID09PSBHTF9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRV9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX0NPTVBPTkVOVCB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX1NURU5DSUwpIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBnbGVudW1cbiAgICB9IGVsc2UgaWYgKGdsZW51bSA9PT0gR0xfUkdCNV9BMSB8fCBrZXkuaW5kZXhPZigncmdiYScpID49IDApIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBHTF9SR0JBXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBHTF9SR0JcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yXG4gIH0sIHt9KVxuXG4gIHZhciBjb21wcmVzc2VkRm9ybWF0RW51bXMgPSBPYmplY3Qua2V5cyhjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMpLm1hcChcbiAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzW2tleV1cbiAgICB9KVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGl4ZWxTdG9yYWdlIChvcHRpb25zLCBkZWZhdWx0cywgcmVzdWx0KSB7XG4gICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICByZXN1bHQuZmxpcFkgPSBkZWZhdWx0cy5mbGlwWVxuICAgICAgcmVzdWx0LnByZW11bHRpcGx5QWxwaGEgPSBkZWZhdWx0cy5wcmVtdWx0aXBseUFscGhhXG4gICAgICByZXN1bHQudW5wYWNrQWxpZ25tZW50ID0gZGVmYXVsdHMudW5wYWNrQWxpZ25tZW50XG4gICAgICByZXN1bHQuY29sb3JTcGFjZSA9IGRlZmF1bHRzLmNvbG9yU3BhY2VcbiAgICB9XG5cbiAgICBpZiAoJ3ByZW11bHRpcGx5QWxwaGEnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrLnR5cGUob3B0aW9ucy5wcmVtdWx0aXBseUFscGhhLCAnYm9vbGVhbicsICdpbnZhbGlkIHByZW11bHRpcGx5QWxwaGEnKVxuICAgICAgcmVzdWx0LnByZW11bHRpcGx5QWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGFcbiAgICB9XG5cbiAgICBpZiAoJ2ZsaXBZJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjay50eXBlKG9wdGlvbnMuZmxpcFksICdib29sZWFuJywgJ2ludmFsaWQgdGV4dHVyZSBmbGlwJylcbiAgICAgIHJlc3VsdC5mbGlwWSA9IG9wdGlvbnMuZmxpcFlcbiAgICB9XG5cbiAgICBpZiAoJ2FsaWdubWVudCcgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2sub25lT2YoXG4gICAgICAgIG9wdGlvbnMuYWxpZ25tZW50LFxuICAgICAgICBbMSwgMiwgNCwgOF0sXG4gICAgICAgICdpbnZhbGlkIHRleHR1cmUgdW5wYWNrIGFsaWdubWVudCcpXG4gICAgICByZXN1bHQudW5wYWNrQWxpZ25tZW50ID0gb3B0aW9ucy5hbGlnbm1lbnRcbiAgICB9XG5cbiAgICBpZiAoJ2NvbG9yU3BhY2UnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrLnBhcmFtZXRlcihvcHRpb25zLmNvbG9yU3BhY2UsIGNvbG9yU3BhY2UsICdpbnZhbGlkIGNvbG9yU3BhY2UnKVxuICAgICAgcmVzdWx0LmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlW29wdGlvbnMuY29sb3JTcGFjZV1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVRleFBhcmFtcyAob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBjaGFubmVsczogMCxcbiAgICAgIGZvcm1hdDogMCxcbiAgICAgIHR5cGU6IDAsXG4gICAgICB3cmFwUzogR0xfQ0xBTVBfVE9fRURHRSxcbiAgICAgIHdyYXBUOiBHTF9DTEFNUF9UT19FREdFLFxuICAgICAgbWluRmlsdGVyOiBHTF9ORUFSRVNULFxuICAgICAgbWFnRmlsdGVyOiBHTF9ORUFSRVNULFxuICAgICAgZ2VuTWlwbWFwczogZmFsc2UsXG4gICAgICBhbmlzb1NhbXBsZXM6IDEsXG4gICAgICBmbGlwWTogZmFsc2UsXG4gICAgICBwcmVtdWx0aXBseUFscGhhOiBmYWxzZSxcbiAgICAgIHVucGFja0FsaWdubWVudDogMSxcbiAgICAgIGNvbG9yU3BhY2U6IEdMX0JST1dTRVJfREVGQVVMVF9XRUJHTCxcbiAgICAgIHBvbGw6IGZhbHNlLFxuICAgICAgbmVlZHNMaXN0ZW5lcnM6IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgZGVmYXVsdHMpXG4gICAgICBwYXJzZVBpeGVsU3RvcmFnZShvcHRpb25zLCBkZWZhdWx0cywgcmVzdWx0KVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZVBpeGVsU3RvcmFnZShvcHRpb25zLCBudWxsLCByZXN1bHQpXG4gICAgfVxuXG4gICAgaWYgKCdzaGFwZScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2soQXJyYXkuaXNBcnJheShvcHRpb25zLnNoYXBlKSAmJiBvcHRpb25zLnNoYXBlLmxlbmd0aCA+PSAyLFxuICAgICAgICAnc2hhcGUgbXVzdCBiZSBhbiBhcnJheScpXG4gICAgICByZXN1bHQud2lkdGggPSBvcHRpb25zLnNoYXBlWzBdIHwgMFxuICAgICAgcmVzdWx0LmhlaWdodCA9IG9wdGlvbnMuc2hhcGVbMV0gfCAwXG4gICAgICBpZiAob3B0aW9ucy5zaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmVzdWx0LmNoYW5uZWxzID0gb3B0aW9ucy5zaGFwZVsyXSB8IDBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCdyYWRpdXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmhlaWdodCA9IG9wdGlvbnMucmFkaXVzIHwgMFxuICAgICAgfVxuICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICByZXN1bHQud2lkdGggPSBvcHRpb25zLndpZHRoIHwgMFxuICAgICAgfVxuICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHwgMFxuICAgICAgfVxuICAgICAgaWYgKCdjaGFubmVscycgaW4gb3B0aW9ucykge1xuICAgICAgICByZXN1bHQuY2hhbm5lbHMgPSBvcHRpb25zLmNoYW5uZWxzIHwgMFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnbWluJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjay5wYXJhbWV0ZXIob3B0aW9ucy5taW4sIG1pbkZpbHRlcnMpXG4gICAgICByZXN1bHQubWluRmlsdGVyID0gbWluRmlsdGVyc1tvcHRpb25zLm1pbl1cbiAgICB9XG5cbiAgICBpZiAoJ21hZycgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2sucGFyYW1ldGVyKG9wdGlvbnMubWFnLCBtYWdGaWx0ZXJzKVxuICAgICAgcmVzdWx0Lm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlcnNbb3B0aW9ucy5tYWddXG4gICAgfVxuXG4gICAgaWYgKCd3cmFwJyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgd3JhcCA9IG9wdGlvbnMud3JhcFxuICAgICAgaWYgKHR5cGVvZiB3cmFwID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaGVjay5wYXJhbWV0ZXIod3JhcCwgd3JhcE1vZGVzKVxuICAgICAgICByZXN1bHQud3JhcFMgPSByZXN1bHQud3JhcFQgPSB3cmFwTW9kZXNbd3JhcF1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh3cmFwKSkge1xuICAgICAgICBjaGVjay5wYXJhbWV0ZXIod3JhcFswXSwgd3JhcE1vZGVzKVxuICAgICAgICBjaGVjay5wYXJhbWV0ZXIod3JhcFsxXSwgd3JhcE1vZGVzKVxuICAgICAgICByZXN1bHQud3JhcFMgPSB3cmFwTW9kZXNbd3JhcFswXV1cbiAgICAgICAgcmVzdWx0LndyYXBUID0gd3JhcE1vZGVzW3dyYXBbMV1dXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnd3JhcFMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hlY2sucGFyYW1ldGVyKG9wdGlvbnMud3JhcFMsIHdyYXBNb2RlcylcbiAgICAgICAgcmVzdWx0LndyYXBTID0gd3JhcE1vZGVzW29wdGlvbnMud3JhcFNdXG4gICAgICB9XG4gICAgICBpZiAoJ3dyYXBUJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNoZWNrLnBhcmFtZXRlcihvcHRpb25zLndyYXBULCB3cmFwTW9kZXMpXG4gICAgICAgIHJlc3VsdC53cmFwVCA9IHdyYXBNb2Rlc1tvcHRpb25zLndyYXBUXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnYW5pc28nIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrLnR5cGUoXG4gICAgICAgIG9wdGlvbnMuYW5pc28sXG4gICAgICAgICdudW1iZXInLFxuICAgICAgICAnbnVtYmVyIG9mIGFuaXNvIHNhbXBsZXMgbXVzdCBiZSBhIG51bWJlcicpXG4gICAgICByZXN1bHQuYW5pc28gPSArb3B0aW9ucy5hbmlzb1xuICAgIH1cblxuICAgIGlmICgnbWlwbWFwJyBpbiBvcHRpb25zKSB7XG4gICAgICByZXN1bHQuZ2VuTWlwbWFwcyA9ICEhb3B0aW9ucy5taXBtYXBcbiAgICB9IGVsc2UgaWYgKFtcbiAgICAgIEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QsXG4gICAgICBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIsXG4gICAgICBHTF9MSU5FQVJfTUlQTUFQX05FQVJFU1QsXG4gICAgICBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUlxuICAgIF0uaW5kZXhPZihyZXN1bHQubWluRmlsdGVyKSA+PSAwKSB7XG4gICAgICByZXN1bHQuZ2VuTWlwbWFwcyA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoJ2Zvcm1hdCcgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2sucGFyYW1ldGVyKG9wdGlvbnMuZm9ybWF0LCB0ZXh0dXJlRm9ybWF0cywgJ2ludmFsaWQgdGV4dHVyZSBmb3JtYXQnKVxuICAgICAgcmVzdWx0LmZvcm1hdCA9IHRleHR1cmVGb3JtYXRzW29wdGlvbnMuZm9ybWF0XVxuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0IGluIHRleHR1cmVUeXBlcykge1xuICAgICAgICByZXN1bHQudHlwZSA9IHRleHR1cmVUeXBlc1tvcHRpb25zLmZvcm1hdF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrLnBhcmFtZXRlcihvcHRpb25zLnR5cGUsIHRleHR1cmVUeXBlcywgJ2ludmFsaWQgdGV4dHVyZSB0eXBlJylcbiAgICAgIHJlc3VsdC50eXBlID0gdGV4dHVyZVR5cGVzW29wdGlvbnMudHlwZV1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pcEltYWdlIChpbWFnZSwgdGV4UGFyYW1zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0gdGV4UGFyYW1zXG5cbiAgICBpZiAoaW1hZ2UpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGltYWdlLm1pcG1hcCkpIHtcbiAgICAgICAgZGVmYXVsdHMgPSBwYXJzZVRleFBhcmFtcyhpbWFnZSwgdGV4UGFyYW1zKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1pcG1hcDogaW1hZ2UubWlwbWFwLm1hcChmdW5jdGlvbiAobGV2ZWwsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVBpeGVsRGF0YShcbiAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgIHRleFBhcmFtcy53aWR0aCA+PiBpLFxuICAgICAgICAgICAgICB0ZXhQYXJhbXMuaGVpZ2h0ID4+IGksXG4gICAgICAgICAgICAgIGkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwaXhlbHM6IHBhcnNlUGl4ZWxEYXRhKGltYWdlLCB0ZXhQYXJhbXMud2lkdGgsIHRleFBhcmFtcy5oZWlnaHQsIDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQaXhlbERhdGEgKHBpeGVsRGF0YSwgd2lkdGgsIGhlaWdodCwgbWlwbGV2ZWwpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZVBpeGVsU3RvcmFnZShwaXhlbERhdGEsIGRlZmF1bHRzLCB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIGNoYW5uZWxzOiBkZWZhdWx0cy5jaGFubmVscyxcbiAgICAgICAgZm9ybWF0OiBkZWZhdWx0cy5mb3JtYXQsXG4gICAgICAgIGludGVybmFsZm9ybWF0OiAwLFxuICAgICAgICB0eXBlOiBkZWZhdWx0cy50eXBlLFxuICAgICAgICBjb3B5OiBmYWxzZSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgIGNhbnZhczogbnVsbCxcbiAgICAgICAgdmlkZW86IG51bGwsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGFycmF5OiBudWxsLFxuICAgICAgICBuZWVkc0NvbnZlcnQ6IGZhbHNlLFxuICAgICAgICBuZWVkc1RyYW5zcG9zZTogZmFsc2UsXG4gICAgICAgIG5lZWRzTGlzdGVuZXJzOiBmYWxzZSxcbiAgICAgICAgc3RyaWRlWDogMCxcbiAgICAgICAgc3RyaWRlWTogMCxcbiAgICAgICAgc3RyaWRlQzogMCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBmbGlwWTogZGVmYXVsdHMuZmxpcFksXG4gICAgICAgIHByZW11bHRpcGx5QWxwaGE6IGRlZmF1bHRzLnByZW11bHRpcGx5QWxwaGEsXG4gICAgICAgIHVucGFja0FsaWdubWVudDogZGVmYXVsdHMudW5wYWNrQWxpZ25tZW50LFxuICAgICAgICBjb2xvclNwYWNlOiBkZWZhdWx0cy5jb2xvclNwYWNlLFxuICAgICAgICBwb2xsOiBmYWxzZVxuICAgICAgfSlcblxuICAgICAgaWYgKCFwaXhlbERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICBjaGVjay50eXBlKHBpeGVsRGF0YSwgJ29iamVjdCcsICdpbnZhbGlkIHBpeGVsIGRhdGEnKVxuXG4gICAgICBmdW5jdGlvbiBzZXRPYmplY3RQcm9wcyAoKSB7XG4gICAgICAgIGlmICgnc2hhcGUnIGluIHBpeGVsRGF0YSkge1xuICAgICAgICAgIHZhciBzaGFwZSA9IHBpeGVsRGF0YS5zaGFwZVxuICAgICAgICAgIGNoZWNrKFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzaGFwZSkgJiYgc2hhcGUubGVuZ3RoID49IDIsXG4gICAgICAgICAgICAnaW1hZ2Ugc2hhcGUgbXVzdCBiZSBhbiBhcnJheScpXG4gICAgICAgICAgcmVzdWx0LndpZHRoID0gc2hhcGVbMF0gfCAwXG4gICAgICAgICAgcmVzdWx0LmhlaWdodCA9IHNoYXBlWzFdIHwgMFxuICAgICAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFubmVscyA9IHNoYXBlWzJdIHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoJ3dpZHRoJyBpbiBwaXhlbERhdGEpIHtcbiAgICAgICAgICAgIHJlc3VsdC53aWR0aCA9IHBpeGVsRGF0YS53aWR0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQud2lkdGggPSB3aWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2hlaWdodCcgaW4gcGl4ZWxEYXRhKSB7XG4gICAgICAgICAgICByZXN1bHQuaGVpZ2h0ID0gcGl4ZWxEYXRhLmhlaWdodFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnY2hhbm5lbHMnIGluIHBpeGVsRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYW5uZWxzID0gcGl4ZWxEYXRhLmNoYW5uZWxzXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdzdHJpZGUnIGluIHBpeGVsRGF0YSkge1xuICAgICAgICAgIHZhciBzdHJpZGUgPSBwaXhlbERhdGEuc3RyaWRlXG4gICAgICAgICAgY2hlY2soQXJyYXkuaXNBcnJheShzdHJpZGUpICYmIHN0cmlkZS5sZW5ndGggPj0gMixcbiAgICAgICAgICAgICdpbnZhbGlkIHN0cmlkZSB2ZWN0b3InKVxuICAgICAgICAgIHJlc3VsdC5zdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgICAgcmVzdWx0LnN0cmlkZVkgPSBzdHJpZGVbMV1cbiAgICAgICAgICBpZiAoc3RyaWRlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcmVzdWx0LnN0cmlkZUMgPSBzdHJpZGVbMl1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnN0cmlkZUMgPSAxXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5uZWVkc1RyYW5zcG9zZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuc3RyaWRlQyA9IDFcbiAgICAgICAgICByZXN1bHQuc3RyaWRlWCA9IHJlc3VsdC5zdHJpZGVDICogcmVzdWx0LmNoYW5uZWxzXG4gICAgICAgICAgcmVzdWx0LnN0cmlkZVkgPSByZXN1bHQuc3RyaWRlWCAqIHJlc3VsdC53aWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdvZmZzZXQnIGluIHBpeGVsRGF0YSkge1xuICAgICAgICAgIHJlc3VsdC5vZmZzZXQgPSBwaXhlbERhdGEub2Zmc2V0IHwgMFxuICAgICAgICAgIHJlc3VsdC5uZWVkc1RyYW5zcG9zZSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZm9ybWF0JyBpbiBwaXhlbERhdGEpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gcGl4ZWxEYXRhLmZvcm1hdFxuICAgICAgICAgIGNoZWNrLnBhcmFtZXRlcihmb3JtYXQsIHRleHR1cmVGb3JtYXRzKVxuICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSB0ZXh0dXJlRm9ybWF0c1tmb3JtYXRdXG4gICAgICAgICAgaWYgKGZvcm1hdCBpbiB0ZXh0dXJlVHlwZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdGV4dHVyZVR5cGVzW2Zvcm1hdF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3R5cGUnIGluIHBpeGVsRGF0YSkge1xuICAgICAgICAgIHZhciB0eXBlID0gcGl4ZWxEYXRhLnR5cGVcbiAgICAgICAgICBjaGVjay5wYXJhbWV0ZXIodHlwZSwgdGV4dHVyZVR5cGVzKVxuICAgICAgICAgIHJlc3VsdC50eXBlID0gdGV4dHVyZVR5cGVzW3R5cGVdXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICByZXN1bHQudHlwZSA9IEdMX0ZMT0FUXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0RGVmYXVsdFByb3BzICgpIHtcbiAgICAgICAgcmVzdWx0LnR5cGUgPSBHTF9VTlNJR05FRF9CWVRFXG4gICAgICAgIHJlc3VsdC5mb3JtYXQgPSBHTF9SR0JBXG4gICAgICAgIHJlc3VsdC5jaGFubmVscyA9IDRcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBwaXhlbERhdGFcbiAgICAgIGlmIChpc1BpeGVsRGF0YShwaXhlbERhdGEuZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHBpeGVsRGF0YS5kYXRhXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IGxvYWRUZXh0dXJlKGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhXG4gICAgICAgIHNldE9iamVjdFByb3BzKClcbiAgICAgIH0gZWxzZSBpZiAoaXNOdW1lcmljQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmVzdWx0LmFycmF5ID0gZGF0YVxuICAgICAgICByZXN1bHQubmVlZHNDb252ZXJ0ID0gdHJ1ZVxuICAgICAgICBzZXRPYmplY3RQcm9wcygpXG4gICAgICB9IGVsc2UgaWYgKGlzTkRBcnJheUxpa2UoZGF0YSkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKSkge1xuICAgICAgICAgIHJlc3VsdC5hcnJheSA9IGRhdGEuZGF0YVxuICAgICAgICAgIHJlc3VsdC5uZWVkc0NvbnZlcnQgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhXG4gICAgICAgIH1cblxuICAgICAgICBzZXRPYmplY3RQcm9wcygpXG5cbiAgICAgICAgdmFyIHNoYXBlID0gZGF0YS5zaGFwZVxuICAgICAgICByZXN1bHQud2lkdGggPSBzaGFwZVswXVxuICAgICAgICByZXN1bHQuaGVpZ2h0ID0gc2hhcGVbMV1cbiAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIHJlc3VsdC5jaGFubmVscyA9IHNoYXBlWzJdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LmNoYW5uZWxzID0gMVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlXG4gICAgICAgIHJlc3VsdC5zdHJpZGVYID0gZGF0YS5zdHJpZGVbMF1cbiAgICAgICAgcmVzdWx0LnN0cmlkZVkgPSBkYXRhLnN0cmlkZVsxXVxuICAgICAgICBpZiAoc3RyaWRlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIHJlc3VsdC5zdHJpZGVDID0gZGF0YS5zdHJpZGVbMl1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuc3RyaWRlQyA9IDFcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5vZmZzZXQgPSBkYXRhLm9mZnNldFxuXG4gICAgICAgIHJlc3VsdC5uZWVkc1RyYW5zcG9zZSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpIHx8IGlzQ29udGV4dDJEKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0NhbnZhc0VsZW1lbnQoZGF0YSkpIHtcbiAgICAgICAgICByZXN1bHQuY2FudmFzID0gZGF0YVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5jYW52YXMgPSBkYXRhLmNhbnZhc1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC53aWR0aCA9IHJlc3VsdC53aWR0aCB8fCByZXN1bHQuY2FudmFzLndpZHRoXG4gICAgICAgIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQuaGVpZ2h0IHx8IHJlc3VsdC5jYW52YXMuaGVpZ2h0XG4gICAgICAgIHNldERlZmF1bHRQcm9wcygpXG4gICAgICB9IGVsc2UgaWYgKGlzSW1hZ2VFbGVtZW50KGRhdGEpKSB7XG4gICAgICAgIHJlc3VsdC5pbWFnZSA9IGRhdGFcbiAgICAgICAgcmVzdWx0LndpZHRoID0gcmVzdWx0LndpZHRoIHx8IGRhdGEubmF0dXJhbFdpZHRoXG4gICAgICAgIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQuaGVpZ2h0IHx8IGRhdGEubmF0dXJhbEhlaWdodFxuICAgICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgcmVzdWx0Lm5lZWRzTGlzdGVuZXJzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHNldERlZmF1bHRQcm9wcygpXG4gICAgICAgIGlmICgncG9sbCcgaW4gcGl4ZWxEYXRhKSB7XG4gICAgICAgICAgcmVzdWx0LnBvbGwgPSAhIXBpeGVsRGF0YS5wb2xsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNWaWRlb0VsZW1lbnQoZGF0YSkpIHtcbiAgICAgICAgcmVzdWx0LnZpZGVvID0gZGF0YVxuICAgICAgICByZXN1bHQud2lkdGggPSByZXN1bHQud2lkdGggfHwgZGF0YS53aWR0aFxuICAgICAgICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LmhlaWdodCB8fCBkYXRhLmhlaWdodFxuICAgICAgICByZXN1bHQucG9sbCA9IHRydWVcbiAgICAgICAgc2V0RGVmYXVsdFByb3BzKClcbiAgICAgICAgaWYgKCdwb2xsJyBpbiBwaXhlbERhdGEpIHtcbiAgICAgICAgICByZXN1bHQucG9sbCA9ICEhcGl4ZWxEYXRhLnBvbGxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1BlbmRpbmdYSFIoZGF0YSkpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIHBlbmRpbmcgeGhyIHJlcXVlc3RcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWN0QXJyYXkoZGF0YSkpIHtcbiAgICAgICAgdmFyIHcgPSBkYXRhLmxlbmd0aFxuICAgICAgICB2YXIgaCA9IGRhdGFbMF0ubGVuZ3RoXG4gICAgICAgIHZhciBjID0gMVxuICAgICAgICB2YXIgcGl4ZWxzLCBpLCBqLCBrLCBwXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF1bMF0pKSB7XG4gICAgICAgICAgYyA9IGRhdGFbMF1bMF0ubGVuZ3RoXG4gICAgICAgICAgY2hlY2soYyA+PSAwICYmIGMgPD0gNCwgJ2ludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzIGZvciBpbWFnZSBkYXRhJylcbiAgICAgICAgICBwaXhlbHMgPSBBcnJheSh3ICogaCAqIGMpXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdzsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaDsgKytqKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjOyArK2spIHtcbiAgICAgICAgICAgICAgICBwaXhlbHNbcCsrXSA9IGRhdGFbaV1bal1ba11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwaXhlbHMgPSBBcnJheSh3ICogaClcbiAgICAgICAgICBwID0gMFxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB3OyArK2kpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoOyArK2opIHtcbiAgICAgICAgICAgICAgcGl4ZWxzW3ArK10gPSBkYXRhW2ldW2pdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC53aWR0aCA9IHdcbiAgICAgICAgcmVzdWx0LmhlaWdodCA9IGhcbiAgICAgICAgcmVzdWx0LmNoYW5uZWxzID0gY1xuICAgICAgICByZXN1bHQuYXJyYXkgPSBwaXhlbHNcbiAgICAgICAgcmVzdWx0Lm5lZWRzQ29udmVydCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAocGl4ZWxEYXRhLmNvcHkpIHtcbiAgICAgICAgcmVzdWx0LmNvcHkgPSB0cnVlXG4gICAgICAgIHJlc3VsdC54ID0gcGl4ZWxEYXRhLnggfCAwXG4gICAgICAgIHJlc3VsdC55ID0gcGl4ZWxEYXRhLnkgfCAwXG4gICAgICAgIHJlc3VsdC53aWR0aCA9IHBpeGVsRGF0YS53aWR0aCB8IDBcbiAgICAgICAgcmVzdWx0LmhlaWdodCA9IHBpeGVsRGF0YS5oZWlnaHQgfCAwXG4gICAgICAgIHNldERlZmF1bHRQcm9wcygpXG4gICAgICB9XG5cbiAgICAgIC8vIEZpeCB1cCBtaXNzaW5nIHR5cGUgaW5mbyBmb3IgdHlwZWQgYXJyYXlzXG4gICAgICBpZiAoIXJlc3VsdC50eXBlICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgIGlmIChyZXN1bHQuZm9ybWF0ID09PSBHTF9ERVBUSF9DT01QT05FTlQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBHTF9VTlNJR05FRF9TSE9SVFxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmRhdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBHTF9VTlNJR05FRF9JTlRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICByZXN1bHQudHlwZSA9IEdMX0ZMT0FUXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVjb25jaWxlIHdpdGggdGV4UGFyYW1zXG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGUgKHBhcmFtKSB7XG4gICAgICAgIGlmIChyZXN1bHRbcGFyYW1dKSB7XG4gICAgICAgICAgdGV4UGFyYW1zW3BhcmFtXSA9IHRleFBhcmFtc1twYXJhbV0gfHwgcmVzdWx0W3BhcmFtXVxuICAgICAgICAgIGNoZWNrKHJlc3VsdFtwYXJhbV0gPT09IHRleFBhcmFtc1twYXJhbV0sICdpbmNvbXBhdGlibGUgaW1hZ2UgcGFyYW06ICcgKyBwYXJhbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbcGFyYW1dID0gdGV4UGFyYW1zW3BhcmFtXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvbmNpbGUoJ3R5cGUnKVxuICAgICAgcmVjb25jaWxlKCdmb3JtYXQnKVxuICAgICAgcmVjb25jaWxlKCdjaGFubmVscycpXG5cbiAgICAgIHRleFBhcmFtcy5wb2xsID0gdGV4UGFyYW1zLnBvbGwgfHwgcmVzdWx0LnBvbGxcbiAgICAgIHRleFBhcmFtcy5uZWVkc0xpc3RlbmVycyA9IHRleFBhcmFtcy5uZWVkc0xpc3RlbmVycyB8fCByZXN1bHQubmVlZHNMaXN0ZW5lcnNcbiAgICAgIHRleFBhcmFtcy53aWR0aCA9IHRleFBhcmFtcy53aWR0aCB8fCAocmVzdWx0LndpZHRoIDw8IG1pcGxldmVsKVxuICAgICAgdGV4UGFyYW1zLmhlaWdodCA9IHRleFBhcmFtcy5oZWlnaHQgfHwgKHJlc3VsdC5oZWlnaHQgPDwgbWlwbGV2ZWwpXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsTWlzc2luZ1RleFBhcmFtcyAocGFyYW1zKSB7XG4gICAgLy8gSW5mZXIgZGVmYXVsdCBmb3JtYXRcbiAgICBpZiAoIXBhcmFtcy5mb3JtYXQpIHtcbiAgICAgIHBhcmFtcy5jaGFubmVscyA9IHBhcmFtcy5jaGFubmVscyB8fCA0XG4gICAgICBzd2l0Y2ggKHBhcmFtcy5jaGFubmVscykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcGFyYW1zLmZvcm1hdCA9IEdMX0xVTUlOQU5DRVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBwYXJhbXMuZm9ybWF0ID0gR0xfTFVNSU5BTkNFX0FMUEhBXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSBHTF9SR0JcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSBHTF9SR0JBXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gcGFyYW1zLmZvcm1hdFxuICAgIGlmIChmb3JtYXQgPT09IEdMX0RFUFRIX0NPTVBPTkVOVCB8fCBmb3JtYXQgPT09IEdMX0RFUFRIX1NURU5DSUwpIHtcbiAgICAgIGNoZWNrKFxuICAgICAgICBleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUsXG4gICAgICAgICdkZXB0aC9zdGVuY2lsIHRleHR1cmUgbm90IHN1cHBvcnRlZCcpXG4gICAgICBpZiAoZm9ybWF0ID09PSBHTF9ERVBUSF9DT01QT05FTlQpIHtcbiAgICAgICAgY2hlY2soXG4gICAgICAgICAgcGFyYW1zLnR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUIHx8IEdMX1VOU0lHTkVEX0lOVCxcbiAgICAgICAgICAnZGVwdGggdGV4dHVyZSB0eXBlIG11c3QgYmUgdWludDE2IG9yIHVpbnQzMicpXG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0ID09PSBHTF9ERVBUSF9TVEVOQ0lMKSB7XG4gICAgICAgIGNoZWNrKFxuICAgICAgICAgIHBhcmFtcy50eXBlID09PSBHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCxcbiAgICAgICAgICAnZGVwdGggc3RlbmNpbCB0ZXh0dXJlIGZvcm1hdCBtdXN0IG1hdGNoIHR5cGUnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgZm9ybWF0IHRvIGludGVybmFsIGZvcm1hdFxuICAgIHBhcmFtcy5pbnRlcm5hbGZvcm1hdCA9IGZvcm1hdFxuXG4gICAgLy8gU2V0IGNvbG9yIGZvcm1hdFxuICAgIHBhcmFtcy5mb3JtYXQgPSBjb2xvckZvcm1hdHNbZm9ybWF0XVxuICAgIGlmICghcGFyYW1zLmNoYW5uZWxzKSB7XG4gICAgICBzd2l0Y2ggKHBhcmFtcy5mb3JtYXQpIHtcbiAgICAgICAgY2FzZSBHTF9MVU1JTkFOQ0U6XG4gICAgICAgIGNhc2UgR0xfQUxQSEE6XG4gICAgICAgIGNhc2UgR0xfREVQVEhfQ09NUE9ORU5UOlxuICAgICAgICAgIHBhcmFtcy5jaGFubmVscyA9IDFcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfREVQVEhfU1RFTkNJTDpcbiAgICAgICAgY2FzZSBHTF9MVU1JTkFOQ0VfQUxQSEE6XG4gICAgICAgICAgcGFyYW1zLmNoYW5uZWxzID0gMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9SR0I6XG4gICAgICAgICAgcGFyYW1zLmNoYW5uZWxzID0gM1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwYXJhbXMuY2hhbm5lbHMgPSA0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCB0ZXh0dXJlIHR5cGUgaXMgc3VwcG9ydGVkXG4gICAgcGFyYW1zLnR5cGUgPSBwYXJhbXMudHlwZSB8fCBHTF9VTlNJR05FRF9CWVRFXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSBHTF9GTE9BVCkge1xuICAgICAgY2hlY2soXG4gICAgICAgIGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQsXG4gICAgICAgICdmbG9hdCB0ZXh0dXJlIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH0gZWxzZSBpZiAocGFyYW1zLnR5cGUgPT09IEdMX0hBTEZfRkxPQVRfT0VTKSB7XG4gICAgICBjaGVjayhcbiAgICAgICAgZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0LFxuICAgICAgICAnaGFsZiBmbG9hdCB0ZXh0dXJlIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZsb2F0X2xpbmVhciBhbmQgaGFsZl9mbG9hdF9saW5lYXIgZXh0ZW5zaW9uc1xuICAgIGlmICgocGFyYW1zLnR5cGUgPT09IEdMX0ZMT0FUICYmICFleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0X2xpbmVhcikgfHxcbiAgICAgICAgKHBhcmFtcy50eXBlID09PSBHTF9IQUxGX0ZMT0FUX09FUyAmJlxuICAgICAgICAgICFleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyKSkge1xuICAgICAgcGFyYW1zLm1hZ0ZpbHRlciA9IEdMX05FQVJFU1RcbiAgICAgIGlmIChwYXJhbXMubWluRmlsdGVyID09PSBHTF9MSU5FQVIpIHtcbiAgICAgICAgcGFyYW1zLm1pbkZpbHRlciA9IEdMX05FQVJFU1RcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLm1pbkZpbHRlciA9PT0gR0xfTElORUFSX01JUE1BUF9MSU5FQVIgfHxcbiAgICAgICAgICAgICAgICAgcGFyYW1zLm1pbkZpbHRlciA9PT0gR0xfTElORUFSX01JUE1BUF9ORUFSRVNUIHx8XG4gICAgICAgICAgICAgICAgIHBhcmFtcy5taW5GaWx0ZXIgPT09IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUikge1xuICAgICAgICBwYXJhbXMubWluRmlsdGVyID0gR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBmb3Igd2lkdGggYW5kIGhlaWdodFxuICAgIHBhcmFtcy53aWR0aCA9IHBhcmFtcy53aWR0aCB8fCAwXG4gICAgcGFyYW1zLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgfHwgMFxuXG4gICAgLy8gU2V0IGNvbXByZXNzZWQgZmxhZ1xuICAgIHBhcmFtcy5jb21wcmVzc2VkID1cbiAgICAgIGNvbXByZXNzZWRGb3JtYXRFbnVtcy5pbmRleE9mKHBhcmFtcy5pbnRlcm5hbGZvcm1hdCkgPj0gMFxuXG4gICAgaWYgKHBhcmFtcy5nZW5NaXBtYXBzKSB7XG4gICAgICBjaGVjayhwYXJhbXMud2lkdGggPT09IHBhcmFtcy5oZWlnaHQgJiYgaXNQb3cyKHBhcmFtcy53aWR0aCksXG4gICAgICAgICdtdXN0IGJlIGEgc3F1YXJlIHBvd2VyIG9mIDIgdG8gc3VwcG9ydCBtaXBtYXBzJylcbiAgICAgIGNoZWNrKCFwYXJhbXMuY29tcHJlc3NlZCxcbiAgICAgICAgJ21pcG1hcCBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMnKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxNaXNzaW5nSW1hZ2VQYXJhbXMgKGltYWdlLCB0ZXhQYXJhbXMpIHtcbiAgICBpZiAoaW1hZ2UubWlwbWFwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlLm1pcG1hcC5sZW5ndGg7ICsraSkge1xuICAgICAgICBmaWxsTWlzc2luZ1BpeGVsUGFyYW1zKFxuICAgICAgICAgIGltYWdlLm1pcG1hcFtpXSxcbiAgICAgICAgICB0ZXhQYXJhbXMud2lkdGggPj4+IGksXG4gICAgICAgICAgdGV4UGFyYW1zLmhlaWdodCA+Pj4gaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGltYWdlLnBpeGVscykge1xuICAgICAgZmlsbE1pc3NpbmdQaXhlbFBhcmFtcyhpbWFnZS5waXhlbHMsIHRleFBhcmFtcy53aWR0aCwgdGV4UGFyYW1zLmhlaWdodClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsTWlzc2luZ1BpeGVsUGFyYW1zIChwaXhlbHMsIHcsIGgpIHtcbiAgICAgIGZ1bmN0aW9uIGNoZWNrUHJvcCAocHJvcCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKHBpeGVsc1twcm9wXSkge1xuICAgICAgICAgIGNoZWNrKHBpeGVsc1twcm9wXSA9PT0gZXhwZWN0ZWQsICdpbnZhbGlkICcgKyBwcm9wKVxuICAgICAgICB9XG4gICAgICAgIHBpeGVsc1twcm9wXSA9IGV4cGVjdGVkXG4gICAgICB9XG5cbiAgICAgIGNoZWNrUHJvcCgnd2lkdGgnLCB3KVxuICAgICAgY2hlY2tQcm9wKCdoZWlnaHQnLCBoKVxuICAgICAgY2hlY2tQcm9wKCdjaGFubmVscycsIHRleFBhcmFtcy5jaGFubmVscylcbiAgICAgIGNoZWNrUHJvcCgnZm9ybWF0JywgdGV4UGFyYW1zLmludGVybmFsZm9ybWF0KVxuICAgICAgY2hlY2tQcm9wKCd0eXBlJywgdGV4UGFyYW1zLnR5cGUpXG5cbiAgICAgIHBpeGVscy5mb3JtYXQgPSB0ZXhQYXJhbXMuZm9ybWF0XG4gICAgICBwaXhlbHMuaW50ZXJuYWxmb3JtYXQgPSB0ZXhQYXJhbXMuaW50ZXJuYWxmb3JtYXRcblxuICAgICAgaWYgKHBpeGVscy5uZWVkc0NvbnZlcnQpIHtcbiAgICAgICAgc3dpdGNoIChwaXhlbHMudHlwZSkge1xuICAgICAgICAgIGNhc2UgR0xfVU5TSUdORURfQllURTpcbiAgICAgICAgICAgIHBpeGVscy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkocGl4ZWxzLmFycmF5KVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX1NIT1JUOlxuICAgICAgICAgICAgcGl4ZWxzLmRhdGEgPSBuZXcgVWludDE2QXJyYXkocGl4ZWxzLmFycmF5KVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX0lOVDpcbiAgICAgICAgICAgIHBpeGVscy5kYXRhID0gbmV3IFVpbnQzMkFycmF5KHBpeGVscy5hcnJheSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVDpcbiAgICAgICAgICAgIHBpeGVscy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShwaXhlbHMuYXJyYXkpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfSEFMRl9GTE9BVF9PRVM6XG4gICAgICAgICAgICBwaXhlbHMuZGF0YSA9IGNvbnZlcnRUb0hhbGZGbG9hdChwaXhlbHMuYXJyYXkpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVF81XzZfNTpcbiAgICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzE6XG4gICAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVF80XzRfNF80OlxuICAgICAgICAgIGNhc2UgR0xfVU5TSUdORURfSU5UXzI0XzhfV0VCR0w6XG4gICAgICAgICAgICBjaGVjay5yYWlzZSgndW5zdXBwb3J0ZWQgZm9ybWF0IGZvciBhdXRvbWF0aWMgY29udmVyc2lvbicpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNoZWNrLnJhaXNlKCd1bnN1cHBvcnRlZCB0eXBlIGNvbnZlcnNpb24nKVxuICAgICAgICB9XG4gICAgICAgIHBpeGVscy5uZWVkc0NvbnZlcnQgPSBmYWxzZVxuICAgICAgICBwaXhlbHMuYXJyYXkgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChwaXhlbHMubmVlZHNUcmFuc3Bvc2UpIHtcbiAgICAgICAgcGl4ZWxzLmRhdGEgPSB0cmFuc3Bvc2VQaXhlbHMoXG4gICAgICAgICAgcGl4ZWxzLmRhdGEsXG4gICAgICAgICAgcGl4ZWxzLndpZHRoLFxuICAgICAgICAgIHBpeGVscy5oZWlnaHQsXG4gICAgICAgICAgcGl4ZWxzLmNoYW5uZWxzLFxuICAgICAgICAgIHBpeGVscy5zdHJpZGVYLFxuICAgICAgICAgIHBpeGVscy5zdHJpZGVZLFxuICAgICAgICAgIHBpeGVscy5zdHJpZGVDLFxuICAgICAgICAgIHBpeGVscy5vZmZzZXQpXG4gICAgICB9XG5cbiAgICAgIGlmIChwaXhlbHMuZGF0YSkge1xuICAgICAgICBzd2l0Y2ggKHBpeGVscy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9CWVRFOlxuICAgICAgICAgICAgY2hlY2socGl4ZWxzLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgICAgICAgICAgICBwaXhlbHMuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgICAgICAgICAgICAgICAgJ2luY29tcGF0aWJsZSBwaXhlbCB0eXBlJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVF81XzZfNTpcbiAgICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzE6XG4gICAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVF80XzRfNF80OlxuICAgICAgICAgIGNhc2UgR0xfVU5TSUdORURfU0hPUlQ6XG4gICAgICAgICAgY2FzZSBHTF9IQUxGX0ZMT0FUX09FUzpcbiAgICAgICAgICAgIGNoZWNrKHBpeGVscy5kYXRhIGluc3RhbmNlb2YgVWludDE2QXJyYXksXG4gICAgICAgICAgICAgICAgICAnaW5jb21wYXRpYmxlIHBpeGVsIHR5cGUnKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX0lOVDpcbiAgICAgICAgICAgIGNoZWNrKHBpeGVscy5kYXRhIGluc3RhbmNlb2YgVWludDMyQXJyYXksXG4gICAgICAgICAgICAgICAgICAnaW5jb21wYXRpYmxlIHBpeGVsIHR5cGUnKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgR0xfRkxPQVQ6XG4gICAgICAgICAgICBjaGVjayhwaXhlbHMuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAgICAgICAgICdpbmNvbXBhdGlibGUgcGl4ZWwgdHlwZScpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNoZWNrLnJhaXNlKCdiYWQgb3IgbWlzc2luZyBwaXhlbCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVGV4dHVyZTJEIChvYmplY3QpIHtcbiAgICAvLyBmaXJzdCBwYXNzOiBpbml0aWFsbHkgcGFyc2UgYWxsIGRhdGFcbiAgICB2YXIgcGFyYW1zID0gcGFyc2VUZXhQYXJhbXMob2JqZWN0KVxuICAgIHZhciBpbWFnZSA9IHBhcnNlTWlwSW1hZ2Uob2JqZWN0LCBwYXJhbXMpXG5cbiAgICAvLyBzZWNvbmQgcGFzczogZmlsbCBpbiBkZWZhdWx0cyBiYXNlZCBvbiBpbmZlcnJlZCBwYXJhbWV0ZXJzXG4gICAgZmlsbE1pc3NpbmdUZXhQYXJhbXMocGFyYW1zKVxuICAgIGZpbGxNaXNzaW5nSW1hZ2VQYXJhbXMoaW1hZ2UsIHBhcmFtcylcblxuICAgIHJldHVybiB7XG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGltYWdlOiBpbWFnZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ3ViZSAob2JqZWN0KSB7XG4gICAgdmFyIGZhY2VzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgZmFjZXMgPSBvYmplY3RcbiAgICB9IGVsc2UgaWYgKCdmYWNlcycgaW4gb2JqZWN0KSB7XG4gICAgICBmYWNlcyA9IG9iamVjdC5mYWNlc1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWNlcyA9IFt7fSwge30sIHt9LCB7fSwge30sIHt9XVxuICAgIH1cblxuICAgIGNoZWNrKEFycmF5LmlzQXJyYXkoZmFjZXMpICYmIGZhY2VzLmxlbmd0aCA9PT0gNixcbiAgICAgICdpbnZhbGlkIGZhY2VzIGZvciBjdWJlbWFwJylcblxuICAgIHZhciBwYXJhbXMgPSBwYXJzZVRleFBhcmFtcyhvYmplY3QpXG4gICAgdmFyIHBhcnNlZEZhY2VzID0gZmFjZXMubWFwKGZ1bmN0aW9uIChmYWNlKSB7XG4gICAgICByZXR1cm4gcGFyc2VNaXBJbWFnZShmYWNlLCBwYXJhbXMpXG4gICAgfSlcblxuICAgIGZpbGxNaXNzaW5nVGV4UGFyYW1zKHBhcmFtcylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgZmlsbE1pc3NpbmdJbWFnZVBhcmFtcyhwYXJzZWRGYWNlc1tpXSwgcGFyYW1zKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGZhY2VzOiBwYXJzZWRGYWNlc1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY3RpdmVUZXh0dXJlID0gMFxuICB2YXIgdGV4dHVyZUNvdW50ID0gMFxuICB2YXIgdGV4dHVyZVNldCA9IHt9XG4gIHZhciBwb2xsU2V0ID0gW11cbiAgdmFyIG51bVRleFVuaXRzID0gbGltaXRzLnRleHR1cmVVbml0c1xuICB2YXIgdGV4dHVyZVVuaXRzID0gQXJyYXkobnVtVGV4VW5pdHMpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSlcblxuICBmdW5jdGlvbiBSRUdMVGV4dHVyZSAodGFyZ2V0LCB0ZXh0dXJlKSB7XG4gICAgdGhpcy5pZCA9IHRleHR1cmVDb3VudCsrXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXRcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlXG5cbiAgICB0aGlzLnBvbGxJZCA9IC0xXG5cbiAgICB0aGlzLnVuaXQgPSAtMVxuICAgIHRoaXMuYmluZENvdW50ID0gMFxuXG4gICAgLy8gY2FuY2VscyBhbGwgcGVuZGluZyBjYWxsYmFja3NcbiAgICB0aGlzLmNhbmNlbFBlbmRpbmcgPSBudWxsXG5cbiAgICAvLyBwYXJzZWQgdXNlciBpbnB1dHNcbiAgICB0aGlzLmRhdGEgPSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUZXhQaXhlbHMgKHRhcmdldCwgaW1hZ2UsIGxvZCkge1xuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19GTElQX1lfV0VCR0wsIGltYWdlLmZsaXBZKVxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgaW1hZ2UucHJlbXVsdGlwbHlBbHBoYSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBpbWFnZS5jb2xvclNwYWNlKVxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19BTElHTk1FTlQsIGltYWdlLnVucGFja0FsaWdubWVudClcblxuICAgIHZhciBlbGVtZW50ID0gaW1hZ2UuaW1hZ2UgfHwgaW1hZ2UudmlkZW8gfHwgaW1hZ2UuY2FudmFzXG4gICAgdmFyIGludGVybmFsZm9ybWF0ID0gaW1hZ2UuaW50ZXJuYWxmb3JtYXRcbiAgICB2YXIgZm9ybWF0ID0gaW1hZ2UuZm9ybWF0XG4gICAgdmFyIHR5cGUgPSBpbWFnZS50eXBlXG4gICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0XG4gICAgaWYgKGlzQ2FudmFzRWxlbWVudChlbGVtZW50KSB8fFxuICAgICAgKGlzSW1hZ2VFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQuY29tcGxldGUpIHx8XG4gICAgICAoaXNWaWRlb0VsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5yZWFkeVN0YXRlID4gMikpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgbG9kLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZWxlbWVudClcbiAgICB9IGVsc2UgaWYgKGltYWdlLmNvbXByZXNzZWQpIHtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGxvZCxcbiAgICAgICAgaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIGltYWdlLmRhdGEpXG4gICAgfSBlbHNlIGlmIChpbWFnZS5jb3B5KSB7XG4gICAgICByZWdsUG9sbCgpXG4gICAgICBnbC5jb3B5VGV4SW1hZ2UyRChcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBsb2QsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgaW1hZ2UueCxcbiAgICAgICAgaW1hZ2UueSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgMClcbiAgICB9IGVsc2UgaWYgKGltYWdlLmRhdGEpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgbG9kLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaW1hZ2UuZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBsb2QsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgd2lkdGggfHwgMSxcbiAgICAgICAgaGVpZ2h0IHx8IDEsXG4gICAgICAgIDAsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbnVsbClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUZXhJbWFnZSAodGFyZ2V0LCBpbWFnZSkge1xuICAgIHZhciBtaXBtYXAgPSBpbWFnZS5taXBtYXBcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtaXBtYXApKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pcG1hcC5sZW5ndGg7ICsraSkge1xuICAgICAgICBzZXRUZXhQaXhlbHModGFyZ2V0LCBtaXBtYXBbaV0sIGkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRleFBpeGVscyh0YXJnZXQsIGltYWdlLnBpeGVscywgMClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhclBvbGwgKHRleHR1cmUpIHtcbiAgICB2YXIgaWQgPSB0ZXh0dXJlLnBvbGxJZFxuICAgIGlmIChpZCA+PSAwKSB7XG4gICAgICB2YXIgb3RoZXIgPSBwb2xsU2V0W2lkXSA9IHBvbGxTZXRbcG9sbFNldC5sZW5ndGggLSAxXVxuICAgICAgb3RoZXIuaWQgPSBpZFxuICAgICAgcG9sbFNldC5wb3AoKVxuICAgICAgdGV4dHVyZS5wb2xsSWQgPSAtMVxuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oUkVHTFRleHR1cmUucHJvdG90eXBlLCB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJpbmRDb3VudCArPSAxXG4gICAgICB2YXIgdW5pdCA9IHRoaXMudW5pdFxuICAgICAgaWYgKHVuaXQgPCAwKSB7XG4gICAgICAgIC8vIEZJWE1FOiBzaG91bGQgd2UgdXNlIGFuIExSVSB0byBhbGxvY2F0ZSB0ZXh0dXJlcyBoZXJlP1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgICAgICBpZiAoIW90aGVyIHx8IG90aGVyLmJpbmRDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgb3RoZXIudW5pdCA9IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0dXJlVW5pdHNbaV0gPSB0aGlzXG4gICAgICAgICAgICB1bml0ID0gaVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bml0ID0gdW5pdFxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwICsgdW5pdClcbiAgICAgICAgZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIHRoaXMudGV4dHVyZSlcbiAgICAgICAgYWN0aXZlVGV4dHVyZSA9IHVuaXRcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bml0XG4gICAgfSxcblxuICAgIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5iaW5kQ291bnQgLT0gMVxuICAgIH0sXG5cbiAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXRcbiAgICAgIHZhciB1bml0ID0gdGhpcy51bml0XG4gICAgICBpZiAodW5pdCA+PSAwKSB7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTAgKyB1bml0KVxuICAgICAgICBhY3RpdmVUZXh0dXJlID0gdW5pdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0aGlzLnRleHR1cmUpXG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhXG5cbiAgICAgIGlmICh0YXJnZXQgPT09IEdMX1RFWFRVUkVfMkQpIHtcbiAgICAgICAgc2V0VGV4SW1hZ2UoR0xfVEVYVFVSRV8yRCwgZGF0YS5pbWFnZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgc2V0VGV4SW1hZ2UoR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgZGF0YS5mYWNlc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGV4IHBhcmFtc1xuICAgICAgdmFyIHBhcmFtcyA9IGRhdGEucGFyYW1zXG5cbiAgICAgIC8vIEdlbmVyYXRlIG1pcG1hcHNcbiAgICAgIGlmIChwYXJhbXMuZ2VuTWlwbWFwcykge1xuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpXG4gICAgICB9XG5cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtcy5taW5GaWx0ZXIpXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgR0xfVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbXMubWFnRmlsdGVyKVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfV1JBUF9TLCBwYXJhbXMud3JhcFMpXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgR0xfVEVYVFVSRV9XUkFQX1QsIHBhcmFtcy53cmFwVClcbiAgICAgIGlmIChleHRlbnNpb25zLmV4dF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYykge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgR0xfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIHBhcmFtcy5hbmlzb1NhbXBsZXMpXG4gICAgICB9XG5cbiAgICAgIC8vIFJlc3RvcmUgYmluZGluZyBzdGF0ZVxuICAgICAgaWYgKHVuaXQgPCAwKSB7XG4gICAgICAgIHZhciBhY3RpdmUgPSB0ZXh0dXJlVW5pdHNbYWN0aXZlVGV4dHVyZV1cbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgIC8vIHJlc3RvcmUgYmluZGluZyBzdGF0ZVxuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGFjdGl2ZS50YXJnZXQsIGFjdGl2ZS50ZXh0dXJlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBiZWNvbWUgbmV3IGFjdGl2ZVxuICAgICAgICAgIHRoaXMudW5pdCA9IGFjdGl2ZVRleHR1cmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVjayh0aGlzLnRleHR1cmUsICdtdXN0IG5vdCBkb3VibGUgZnJlZSB0ZXh0dXJlJylcbiAgICAgIGlmICh0aGlzLnVuaXQgPj0gMCkge1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwICsgdGhpcy51bml0KVxuICAgICAgICBhY3RpdmVUZXh0dXJlID0gdGhpcy51bml0XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRoaXMudGFyZ2V0LCBudWxsKVxuICAgICAgICB0ZXh0dXJlVW5pdHNbdGhpcy51bml0XSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbmNlbFBlbmRpbmcpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nKClcbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nID0gbnVsbFxuICAgICAgfVxuICAgICAgY2xlYXJQb2xsKHRoaXMpXG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSlcbiAgICAgIHRoaXMudGV4dHVyZSA9IG51bGxcbiAgICAgIHRoaXMudW5pdCA9IC0xXG4gICAgICB0aGlzLmJpbmRDb3VudCA9IDBcbiAgICAgIGRlbGV0ZSB0ZXh0dXJlU2V0W3RoaXMuaWRdXG4gICAgfVxuICB9KVxuXG4gIGZ1bmN0aW9uIGhvb2tMaXN0ZW5lcnMgKHRleHR1cmUpIHtcbiAgICB2YXIgZGF0YSA9IHRleHR1cmUuZGF0YVxuICAgIHZhciBpbWFnZXMgPSBkYXRhLmZhY2VzIHx8IFsgZGF0YS5pbWFnZSBdXG4gICAgdmFyIHBpeGVscyA9IFtdXG5cbiAgICBpbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIGlmIChpbWFnZS5waXhlbHMpIHtcbiAgICAgICAgcGl4ZWxzLnB1c2goaW1hZ2UucGl4ZWxzKVxuICAgICAgfSBlbHNlIGlmIChpbWFnZS5taXBtYXApIHtcbiAgICAgICAgcGl4ZWxzLnB1c2guYXBwbHkocGl4ZWxzLCBpbWFnZS5taXBtYXApXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIHJlZnJlc2ggKCkge1xuICAgICAgaWYgKCFkYXRhLndpZHRoIHx8ICFkYXRhLmhlaWdodCkge1xuICAgICAgICAvLyB0cnkgdG8gcmVjb21wdXRlIHNpemVcbiAgICAgICAgcGl4ZWxzLmZvckVhY2goZnVuY3Rpb24gKHBpeGVsRGF0YSkge1xuICAgICAgICAgIGlmIChwaXhlbERhdGEuaW1hZ2UpIHtcbiAgICAgICAgICAgIGRhdGEud2lkdGggPSBkYXRhLndpZHRoIHx8IHBpeGVsRGF0YS5pbWFnZS5uYXR1cmFsV2lkdGhcbiAgICAgICAgICAgIGRhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgcGl4ZWxEYXRhLmltYWdlLm5hdHVyYWxXaWR0aFxuICAgICAgICAgIH0gZWxzZSBpZiAocGl4ZWxEYXRhLnZpZGVvKSB7XG4gICAgICAgICAgICBkYXRhLndpZHRoID0gZGF0YS53aWR0aCB8fCBwaXhlbERhdGEudmlkZW8ud2lkdGhcbiAgICAgICAgICAgIGRhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgcGl4ZWxEYXRhLnZpZGVvLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRleHR1cmUucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgcGl4ZWxzLmZvckVhY2goZnVuY3Rpb24gKHBpeGVsRGF0YSkge1xuICAgICAgaWYgKHBpeGVsRGF0YS5pbWFnZSAmJiAhcGl4ZWxEYXRhLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgIHBpeGVsRGF0YS5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVmcmVzaClcbiAgICAgIH0gZWxzZSBpZiAocGl4ZWxEYXRhLnZpZGVvICYmIHBpeGVsRGF0YS5yZWFkeVN0YXRlIDwgMSkge1xuICAgICAgICBwaXhlbERhdGEudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCByZWZyZXNoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBkZXRhY2hMaXN0ZW5lcnMgKCkge1xuICAgICAgcGl4ZWxzLmZvckVhY2goZnVuY3Rpb24gKHBpeGVsRGF0YSkge1xuICAgICAgICBpZiAocGl4ZWxEYXRhLmltYWdlKSB7XG4gICAgICAgICAgcGl4ZWxEYXRhLmltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZWZyZXNoKVxuICAgICAgICB9IGVsc2UgaWYgKHBpeGVsRGF0YS52aWRlbykge1xuICAgICAgICAgIHBpeGVsRGF0YS52aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlZnJlc2gpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGRldGFjaExpc3RlbmVyc1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZSAob3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgdmFyIHRleHR1cmUgPSBuZXcgUkVHTFRleHR1cmUodGFyZ2V0LCBnbC5jcmVhdGVUZXh0dXJlKCkpXG4gICAgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXSA9IHRleHR1cmVcblxuICAgIHZhciBwYXJzZSA9IHRhcmdldCA9PT0gR0xfVEVYVFVSRV8yRFxuICAgICAgPyBwYXJzZVRleHR1cmUyRFxuICAgICAgOiBwYXJzZUN1YmVcblxuICAgIGZ1bmN0aW9uIHJlZ2xUZXh0dXJlIChvcHRpb25zKSB7XG4gICAgICBpZiAodGV4dHVyZS5jYW5jZWxQZW5kaW5nKSB7XG4gICAgICAgIHRleHR1cmUuY2FuY2VsUGVuZGluZygpXG4gICAgICAgIHRleHR1cmUuY2FuY2VsUGVuZGluZyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgY2xlYXJQb2xsKHRleHR1cmUpXG5cbiAgICAgIHZhciBpbnB1dCA9IG9wdGlvbnMgfHwge31cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlucHV0ID0ge1xuICAgICAgICAgIGRhdGE6IGlucHV0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gcGFyc2UoaW5wdXQpXG4gICAgICB2YXIgcGFyYW1zID0gYXJncy5wYXJhbXNcbiAgICAgIHRleHR1cmUuZGF0YSA9IGFyZ3NcblxuICAgICAgaWYgKHBhcmFtcy5uZWVkc0xpc3RlbmVycykge1xuICAgICAgICB0ZXh0dXJlLmNhbmNlbFBlbmRpbmcgPSBob29rTGlzdGVuZXJzKHRleHR1cmUpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMucG9sbCkge1xuICAgICAgICB0ZXh0dXJlLnBvbGxJZCA9IHBvbGxTZXQubGVuZ3RoXG4gICAgICAgIHBvbGxTZXQucHVzaCh0ZXh0dXJlKVxuICAgICAgfVxuXG4gICAgICB0ZXh0dXJlLnJlZnJlc2goKVxuICAgIH1cblxuICAgIHJlZ2xUZXh0dXJlKG9wdGlvbnMpXG5cbiAgICByZWdsVGV4dHVyZS5fcmVnbFR5cGUgPSAndGV4dHVyZSdcbiAgICByZWdsVGV4dHVyZS5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICByZWdsVGV4dHVyZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGV4dHVyZS5kZXN0cm95KClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbFRleHR1cmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hUZXh0dXJlcyAoKSB7XG4gICAgT2JqZWN0LmtleXModGV4dHVyZVNldCkuZm9yRWFjaChmdW5jdGlvbiAodGV4SWQpIHtcbiAgICAgIHRleHR1cmVTZXRbdGV4SWRdLnJlZnJlc2goKVxuICAgIH0pXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UZXhVbml0czsgKytpKSB7XG4gICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgfVxuICAgIGFjdGl2ZVRleHR1cmUgPSAwXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMClcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lUZXh0dXJlcyAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UZXhVbml0czsgKytpKSB7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwICsgaSlcbiAgICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQsIG51bGwpXG4gICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgfVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTApXG4gICAgYWN0aXZlVGV4dHVyZSA9IDBcbiAgICBPYmplY3Qua2V5cyh0ZXh0dXJlU2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXhJZCkge1xuICAgICAgdGV4dHVyZVNldFt0ZXhJZF0uZGVzdHJveSgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIFVwZGF0ZSBhbnkgdGV4dHVyZXNcbiAgZnVuY3Rpb24gcG9sbFRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbGxTZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBvbGxTZXRbaV0ucmVmcmVzaCgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGNyZWF0ZVRleHR1cmUsXG4gICAgcmVmcmVzaDogcmVmcmVzaFRleHR1cmVzLFxuICAgIGNsZWFyOiBkZXN0cm95VGV4dHVyZXMsXG4gICAgcG9sbDogcG9sbFRleHR1cmVzLFxuICAgIGdldFRleHR1cmU6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3cmFwVW5pZm9ybVN0YXRlICgpIHtcbiAgdmFyIHVuaWZvcm1TdGF0ZSA9IHt9XG5cbiAgZnVuY3Rpb24gZGVmVW5pZm9ybSAobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHVuaWZvcm1TdGF0ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHVuaWZvcm1TdGF0ZVtuYW1lXSA9IFsgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdIF1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdW5pZm9ybXM6IHVuaWZvcm1TdGF0ZSxcbiAgICBkZWY6IGRlZlVuaWZvcm1cbiAgfVxufVxuIiwidmFyIGNoZWNrID0gcmVxdWlyZSgnLi9saWIvY2hlY2snKVxudmFyIGdldENvbnRleHQgPSByZXF1aXJlKCcuL2xpYi9jb250ZXh0JylcbnZhciB3cmFwRXh0ZW5zaW9ucyA9IHJlcXVpcmUoJy4vbGliL2V4dGVuc2lvbicpXG52YXIgd3JhcExpbWl0cyA9IHJlcXVpcmUoJy4vbGliL2xpbWl0cycpXG52YXIgd3JhcEJ1ZmZlcnMgPSByZXF1aXJlKCcuL2xpYi9idWZmZXInKVxudmFyIHdyYXBFbGVtZW50cyA9IHJlcXVpcmUoJy4vbGliL2VsZW1lbnRzJylcbnZhciB3cmFwVGV4dHVyZXMgPSByZXF1aXJlKCcuL2xpYi90ZXh0dXJlJylcbnZhciB3cmFwRkJPcyA9IHJlcXVpcmUoJy4vbGliL2ZibycpXG52YXIgd3JhcFVuaWZvcm1zID0gcmVxdWlyZSgnLi9saWIvdW5pZm9ybScpXG52YXIgd3JhcEF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2xpYi9hdHRyaWJ1dGUnKVxudmFyIHdyYXBTaGFkZXJzID0gcmVxdWlyZSgnLi9saWIvc2hhZGVyJylcbnZhciB3cmFwRHJhdyA9IHJlcXVpcmUoJy4vbGliL2RyYXcnKVxudmFyIHdyYXBDb250ZXh0ID0gcmVxdWlyZSgnLi9saWIvc3RhdGUnKVxudmFyIGNyZWF0ZUNvbXBpbGVyID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZScpXG52YXIgd3JhcFJlYWQgPSByZXF1aXJlKCcuL2xpYi9yZWFkJylcbnZhciBkeW5hbWljID0gcmVxdWlyZSgnLi9saWIvZHluYW1pYycpXG52YXIgcmFmID0gcmVxdWlyZSgnLi9saWIvcmFmJylcbnZhciBjbG9jayA9IHJlcXVpcmUoJy4vbGliL2Nsb2NrJylcblxudmFyIEdMX0NPTE9SX0JVRkZFUl9CSVQgPSAxNjM4NFxudmFyIEdMX0RFUFRIX0JVRkZFUl9CSVQgPSAyNTZcbnZhciBHTF9TVEVOQ0lMX0JVRkZFUl9CSVQgPSAxMDI0XG5cbnZhciBHTF9BUlJBWV9CVUZGRVIgPSAzNDk2MlxudmFyIEdMX1RFWFRVUkVfMkQgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQID0gMHg4NTEzXG5cbnZhciBDT05URVhUX0xPU1RfRVZFTlQgPSAnd2ViZ2xjb250ZXh0bG9zdCdcbnZhciBDT05URVhUX1JFU1RPUkVEX0VWRU5UID0gJ3dlYmdsY29udGV4dHJlc3RvcmVkJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdyYXBSRUdMICgpIHtcbiAgdmFyIGFyZ3MgPSBnZXRDb250ZXh0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gIHZhciBnbCA9IGFyZ3MuZ2xcbiAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnNcblxuICB2YXIgZXh0ZW5zaW9uU3RhdGUgPSB3cmFwRXh0ZW5zaW9ucyhnbClcbiAgdmFyIGxpbWl0cyA9IHdyYXBMaW1pdHMoZ2wsIGV4dGVuc2lvblN0YXRlKVxuICB2YXIgYnVmZmVyU3RhdGUgPSB3cmFwQnVmZmVycyhnbClcbiAgdmFyIGVsZW1lbnRTdGF0ZSA9IHdyYXBFbGVtZW50cyhnbCwgZXh0ZW5zaW9uU3RhdGUsIGJ1ZmZlclN0YXRlKVxuICB2YXIgdW5pZm9ybVN0YXRlID0gd3JhcFVuaWZvcm1zKClcbiAgdmFyIGF0dHJpYnV0ZVN0YXRlID0gd3JhcEF0dHJpYnV0ZXMoZ2wsIGV4dGVuc2lvblN0YXRlLCBidWZmZXJTdGF0ZSlcbiAgdmFyIHRleHR1cmVTdGF0ZSA9IHdyYXBUZXh0dXJlcyhnbCwgZXh0ZW5zaW9uU3RhdGUsIGxpbWl0cywgcG9sbClcbiAgdmFyIGZib1N0YXRlID0gd3JhcEZCT3MoZ2wsIGV4dGVuc2lvblN0YXRlLCB0ZXh0dXJlU3RhdGUpXG4gIHZhciBzaGFkZXJTdGF0ZSA9IHdyYXBTaGFkZXJzKFxuICAgIGdsLFxuICAgIGV4dGVuc2lvblN0YXRlLFxuICAgIGF0dHJpYnV0ZVN0YXRlLFxuICAgIHVuaWZvcm1TdGF0ZSxcbiAgICBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIGNvbXBpbGVyLmRyYXcocHJvZ3JhbSlcbiAgICB9KVxuICB2YXIgZHJhd1N0YXRlID0gd3JhcERyYXcoZ2wsIGV4dGVuc2lvblN0YXRlLCBidWZmZXJTdGF0ZSlcbiAgdmFyIGdsU3RhdGUgPSB3cmFwQ29udGV4dChnbCwgc2hhZGVyU3RhdGUpXG4gIHZhciBmcmFtZVN0YXRlID0ge1xuICAgIGNvdW50OiAwLFxuICAgIHN0YXJ0OiBjbG9jaygpLFxuICAgIGR0OiAwLFxuICAgIHQ6IGNsb2NrKCksXG4gICAgcmVuZGVyVGltZTogMCxcbiAgICB3aWR0aDogZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLFxuICAgIGhlaWdodDogZ2wuZHJhd2luZ0J1ZmZlckhlaWdodFxuICB9XG4gIHZhciByZWFkUGl4ZWxzID0gd3JhcFJlYWQoZ2wsIGdsU3RhdGUpXG5cbiAgdmFyIGNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXIoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9uU3RhdGUsXG4gICAgYnVmZmVyU3RhdGUsXG4gICAgZWxlbWVudFN0YXRlLFxuICAgIHRleHR1cmVTdGF0ZSxcbiAgICBmYm9TdGF0ZSxcbiAgICBnbFN0YXRlLFxuICAgIHVuaWZvcm1TdGF0ZSxcbiAgICBhdHRyaWJ1dGVTdGF0ZSxcbiAgICBzaGFkZXJTdGF0ZSxcbiAgICBkcmF3U3RhdGUsXG4gICAgZnJhbWVTdGF0ZSlcblxuICB2YXIgY2FudmFzID0gZ2wuY2FudmFzXG5cbiAgLy8gcmFmIHN0dWZmXG4gIHZhciByYWZDYWxsYmFja3MgPSBbXVxuICB2YXIgYWN0aXZlUkFGID0gMFxuICBmdW5jdGlvbiBoYW5kbGVSQUYgKCkge1xuICAgIGFjdGl2ZVJBRiA9IHJhZi5uZXh0KGhhbmRsZVJBRilcbiAgICBmcmFtZVN0YXRlLmNvdW50ICs9IDFcblxuICAgIGlmIChmcmFtZVN0YXRlLndpZHRoICE9PSBnbC5kcmF3aW5nQnVmZmVyV2lkdGggfHxcbiAgICAgICAgZnJhbWVTdGF0ZS5oZWlnaHQgIT09IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpIHtcbiAgICAgIGZyYW1lU3RhdGUud2lkdGggPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGhcbiAgICAgIGZyYW1lU3RhdGUuaGVpZ2h0ID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodFxuICAgICAgZ2xTdGF0ZS5ub3RpZnlWaWV3cG9ydENoYW5nZWQoKVxuICAgIH1cblxuICAgIHZhciBub3cgPSBjbG9jaygpXG4gICAgZnJhbWVTdGF0ZS5kdCA9IG5vdyAtIGZyYW1lU3RhdGUudFxuICAgIGZyYW1lU3RhdGUudCA9IG5vd1xuXG4gICAgdGV4dHVyZVN0YXRlLnBvbGwoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYWZDYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjYiA9IHJhZkNhbGxiYWNrc1tpXVxuICAgICAgY2IoZnJhbWVTdGF0ZS5jb3VudCwgZnJhbWVTdGF0ZS50LCBmcmFtZVN0YXRlLmR0KVxuICAgIH1cbiAgICBmcmFtZVN0YXRlLnJlbmRlclRpbWUgPSBjbG9jaygpIC0gbm93XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFJBRiAoKSB7XG4gICAgaWYgKCFhY3RpdmVSQUYgJiYgcmFmQ2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIGhhbmRsZVJBRigpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFJBRiAoKSB7XG4gICAgaWYgKGFjdGl2ZVJBRikge1xuICAgICAgcmFmLmNhbmNlbChoYW5kbGVSQUYpXG4gICAgICBhY3RpdmVSQUYgPSAwXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dExvc3MgKGV2ZW50KSB7XG4gICAgc3RvcFJBRigpXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGlmIChvcHRpb25zLm9uQ29udGV4dExvc3QpIHtcbiAgICAgIG9wdGlvbnMub25Db250ZXh0TG9zdCgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dFJlc3RvcmVkIChldmVudCkge1xuICAgIGdsLmdldEVycm9yKClcbiAgICBleHRlbnNpb25TdGF0ZS5yZWZyZXNoKClcbiAgICBidWZmZXJTdGF0ZS5yZWZyZXNoKClcbiAgICB0ZXh0dXJlU3RhdGUucmVmcmVzaCgpXG4gICAgZmJvU3RhdGUucmVmcmVzaCgpXG4gICAgc2hhZGVyU3RhdGUucmVmcmVzaCgpXG4gICAgZ2xTdGF0ZS5yZWZyZXNoKClcbiAgICBpZiAob3B0aW9ucy5vbkNvbnRleHRSZXN0b3JlZCkge1xuICAgICAgb3B0aW9ucy5vbkNvbnRleHRSZXN0b3JlZCgpXG4gICAgfVxuICAgIGhhbmRsZVJBRigpXG4gIH1cblxuICBpZiAoY2FudmFzKSB7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoQ09OVEVYVF9MT1NUX0VWRU5ULCBoYW5kbGVDb250ZXh0TG9zcywgZmFsc2UpXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoQ09OVEVYVF9SRVNUT1JFRF9FVkVOVCwgaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSlcbiAgfVxuXG4gIC8vIFJlc291cmNlIGRlc3RydWN0dWlvblxuICBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICBzdG9wUkFGKClcblxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKENPTlRFWFRfTE9TVF9FVkVOVCwgaGFuZGxlQ29udGV4dExvc3MpXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05URVhUX1JFU1RPUkVEX0VWRU5ULCBoYW5kbGVDb250ZXh0UmVzdG9yZWQpXG4gICAgfVxuXG4gICAgc2hhZGVyU3RhdGUuY2xlYXIoKVxuICAgIGZib1N0YXRlLmNsZWFyKClcbiAgICB0ZXh0dXJlU3RhdGUuY2xlYXIoKVxuICAgIGJ1ZmZlclN0YXRlLmNsZWFyKClcblxuICAgIGlmIChvcHRpb25zLm9uRGVzdHJveSkge1xuICAgICAgb3B0aW9ucy5vbkRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBpbGVzIGEgc2V0IG9mIHByb2NlZHVyZXMgZm9yIGFuIG9iamVjdFxuICBmdW5jdGlvbiBjb21waWxlUHJvY2VkdXJlIChvcHRpb25zKSB7XG4gICAgY2hlY2soISFvcHRpb25zLCAnaW52YWxpZCBhcmdzIHRvIHJlZ2woey4uLn0pJylcbiAgICBjaGVjay50eXBlKG9wdGlvbnMsICdvYmplY3QnLCAnaW52YWxpZCBhcmdzIHRvIHJlZ2woey4uLn0pJylcblxuICAgIHZhciBoYXNEeW5hbWljID0gZmFsc2VcblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRPcHRpb25zIChvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucylcbiAgICAgIGRlbGV0ZSByZXN1bHQudW5pZm9ybXNcbiAgICAgIGRlbGV0ZSByZXN1bHQuYXR0cmlidXRlc1xuXG4gICAgICBmdW5jdGlvbiBtZXJnZSAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSBpbiByZXN1bHQpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSByZXN1bHRbbmFtZV1cbiAgICAgICAgICBkZWxldGUgcmVzdWx0W25hbWVdXG4gICAgICAgICAgT2JqZWN0LmtleXMoY2hpbGQpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lICsgJy4nICsgcHJvcF0gPSBjaGlsZFtwcm9wXVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lcmdlKCdibGVuZCcpXG4gICAgICBtZXJnZSgnZGVwdGgnKVxuICAgICAgbWVyZ2UoJ2N1bGwnKVxuICAgICAgbWVyZ2UoJ3N0ZW5jaWwnKVxuICAgICAgbWVyZ2UoJ3BvbHlnb25PZmZzZXQnKVxuICAgICAgbWVyZ2UoJ3NjaXNzb3InKVxuICAgICAgbWVyZ2UoJ3NhbXBsZScpXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBzZXBhcmF0ZSB0aGUgb3B0aW9ucyBpbnRvIHN0YXRpYyBhbmQgZHluYW1pYyBjb21wb25lbnRzXG4gICAgZnVuY3Rpb24gc2VwYXJhdGVEeW5hbWljIChvYmplY3QpIHtcbiAgICAgIHZhciBzdGF0aWNJdGVtcyA9IHt9XG4gICAgICB2YXIgZHluYW1pY0l0ZW1zID0ge31cbiAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtvcHRpb25dXG4gICAgICAgIGlmIChkeW5hbWljLmlzRHluYW1pYyh2YWx1ZSkpIHtcbiAgICAgICAgICBoYXNEeW5hbWljID0gdHJ1ZVxuICAgICAgICAgIGR5bmFtaWNJdGVtc1tvcHRpb25dID0gZHluYW1pYy51bmJveCh2YWx1ZSwgb3B0aW9uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRpY0l0ZW1zW29wdGlvbl0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZHluYW1pY0l0ZW1zLFxuICAgICAgICBzdGF0aWM6IHN0YXRpY0l0ZW1zXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuaWZvcm1zID0gc2VwYXJhdGVEeW5hbWljKG9wdGlvbnMudW5pZm9ybXMgfHwge30pXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzZXBhcmF0ZUR5bmFtaWMob3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9KVxuICAgIHZhciBvcHRzID0gc2VwYXJhdGVEeW5hbWljKGZsYXR0ZW5OZXN0ZWRPcHRpb25zKG9wdGlvbnMpKVxuXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZXIuY29tbWFuZChcbiAgICAgIG9wdHMuc3RhdGljLCB1bmlmb3Jtcy5zdGF0aWMsIGF0dHJpYnV0ZXMuc3RhdGljLFxuICAgICAgb3B0cy5keW5hbWljLCB1bmlmb3Jtcy5keW5hbWljLCBhdHRyaWJ1dGVzLmR5bmFtaWMsXG4gICAgICBoYXNEeW5hbWljKVxuXG4gICAgdmFyIGRyYXcgPSBjb21waWxlZC5kcmF3XG4gICAgdmFyIGJhdGNoID0gY29tcGlsZWQuYmF0Y2hcbiAgICB2YXIgc2NvcGUgPSBjb21waWxlZC5zY29wZVxuXG4gICAgdmFyIEVNUFRZX0FSUkFZID0gW11cbiAgICBmdW5jdGlvbiByZXNlcnZlIChjb3VudCkge1xuICAgICAgd2hpbGUgKEVNUFRZX0FSUkFZLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgIEVNUFRZX0FSUkFZLnB1c2gobnVsbClcbiAgICAgIH1cbiAgICAgIHJldHVybiBFTVBUWV9BUlJBWVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJFR0xDb21tYW5kIChhcmdzLCBib2R5KSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBiYXRjaChhcmdzIHwgMCwgcmVzZXJ2ZShhcmdzIHwgMCkpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgcmV0dXJuIGJhdGNoKGFyZ3MubGVuZ3RoLCBhcmdzKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2NvcGUobnVsbCwgYXJncylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlKGFyZ3MsIGJvZHkpXG4gICAgICB9XG4gICAgICByZXR1cm4gZHJhdyhhcmdzKVxuICAgIH1cblxuICAgIHJldHVybiBSRUdMQ29tbWFuZFxuICB9XG5cbiAgZnVuY3Rpb24gcG9sbCAoKSB7XG4gICAgZ2xTdGF0ZS5wb2xsKClcbiAgfVxuXG4gIC8vIENsZWFycyB0aGUgY3VycmVudGx5IGJvdW5kIGZyYW1lIGJ1ZmZlclxuICBmdW5jdGlvbiBjbGVhciAob3B0aW9ucykge1xuICAgIHZhciBjbGVhckZsYWdzID0gMFxuXG4gICAgLy8gVXBkYXRlIGNvbnRleHQgc3RhdGVcbiAgICBnbFN0YXRlLnBvbGwoKVxuXG4gICAgdmFyIGMgPSBvcHRpb25zLmNvbG9yXG4gICAgaWYgKGMpIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoK2NbMF0gfHwgMCwgK2NbMV0gfHwgMCwgK2NbMl0gfHwgMCwgK2NbM10gfHwgMClcbiAgICAgIGNsZWFyRmxhZ3MgfD0gR0xfQ09MT1JfQlVGRkVSX0JJVFxuICAgIH1cblxuICAgIGlmICgnZGVwdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgIGdsLmNsZWFyRGVwdGgoK29wdGlvbnMuZGVwdGgpXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX0RFUFRIX0JVRkZFUl9CSVRcbiAgICB9XG5cbiAgICBpZiAoJ3N0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgIGdsLmNsZWFyU3RlbmNpbChvcHRpb25zLnN0ZW5jaWwgfCAwKVxuICAgICAgY2xlYXJGbGFncyB8PSBHTF9TVEVOQ0lMX0JVRkZFUl9CSVRcbiAgICB9XG5cbiAgICBjaGVjayghIWNsZWFyRmxhZ3MsICdjYWxsZWQgcmVnbC5jbGVhciB3aXRoIG5vIGJ1ZmZlciBzcGVjaWZpZWQnKVxuICAgIGdsLmNsZWFyKGNsZWFyRmxhZ3MpXG4gIH1cblxuICAvLyBSZWdpc3RlcnMgYW5vdGhlciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2tcbiAgZnVuY3Rpb24gZnJhbWUgKGNiKSB7XG4gICAgcmFmQ2FsbGJhY2tzLnB1c2goY2IpXG5cbiAgICBmdW5jdGlvbiBjYW5jZWwgKCkge1xuICAgICAgdmFyIGluZGV4ID0gcmFmQ2FsbGJhY2tzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IGNiXG4gICAgICB9KVxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJhZkNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICBpZiAocmFmQ2FsbGJhY2tzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHN0b3BSQUYoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0UkFGKClcblxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGNhbmNlbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbXBpbGVQcm9jZWR1cmUsIHtcbiAgICAvLyBDbGVhciBjdXJyZW50IEZCT1xuICAgIGNsZWFyOiBjbGVhcixcblxuICAgIC8vIER5bmFtaWMgdmFyaWFibGUgYmluZGluZ1xuICAgIHByb3A6IGR5bmFtaWMuZGVmaW5lLFxuXG4gICAgLy8gT2JqZWN0IGNvbnN0cnVjdG9yc1xuICAgIGVsZW1lbnRzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGVsZW1lbnRTdGF0ZS5jcmVhdGUob3B0aW9ucylcbiAgICB9LFxuICAgIGJ1ZmZlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBidWZmZXJTdGF0ZS5jcmVhdGUob3B0aW9ucywgR0xfQVJSQVlfQlVGRkVSKVxuICAgIH0sXG4gICAgdGV4dHVyZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0ZXh0dXJlU3RhdGUuY3JlYXRlKG9wdGlvbnMsIEdMX1RFWFRVUkVfMkQpXG4gICAgfSxcbiAgICBjdWJlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRleHR1cmVTdGF0ZS5jcmVhdGUob3B0aW9ucywgR0xfVEVYVFVSRV9DVUJFX01BUClcbiAgICB9LFxuICAgIC8vIGZibzogY3JlYXRlKGZib1N0YXRlKSxcblxuICAgIC8vIEZyYW1lIHJlbmRlcmluZ1xuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBzdGF0czogZnJhbWVTdGF0ZSxcblxuICAgIC8vIFN5c3RlbSBsaW1pdHNcbiAgICBsaW1pdHM6IGxpbWl0cyxcblxuICAgIC8vIFJlYWQgcGl4ZWxzXG4gICAgcmVhZDogcmVhZFBpeGVscyxcblxuICAgIC8vIERlc3Ryb3kgcmVnbCBhbmQgYWxsIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gICAgZGVzdHJveTogZGVzdHJveVxuICB9KVxufVxuIl19

              </script>
              </body>
            </html>